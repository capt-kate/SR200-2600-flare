<?xml version="1.0" encoding="utf-8"?><html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd"><head><title>hifi1_wrapper</title></head>

<body>

<h1>hifi1_wrapper

        </h1>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl">hifi1_wrapper_Ctrl</a></p>

</td>

<td><p>32'h00000000</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_OCDHaltOnReset">OCDHaltOnReset</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enters OCDHaltMode if this signal is sampled asserted on reset</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_DoubleExceptionErrorClr">DoubleExceptionErrorClr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: clear;</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_PFaultInfoClr">PFaultInfoClr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1:clear</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_RunStall">RunStall</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>When set, causes the HiFi1 processor1 to stall.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_StatVectorSel">StatVectorSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select between one of the two stationary vector bases. 

0:default, 1: alternative 

It must be held stable for at least 10 CLK cycles before the 

falling edge of BReset , and for 10 CLK cycles after the 

falling edge of BReset.</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_en_xt_trace">en_xt_trace</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>External trace buffer enable, when this bit is set to 1, 

predefined PDebug* data will be logged into hifi1 trace buffer 

(128x64-bit), ‘Ored” result (with each LS counter enable bit in 

LSCNTEN) will drive HiFi1 core PDebugEnable input. This bit will 

be cleared by HW automatically once predefined number 

(LSWCTRL.wlimit+1) of entries has been logged in trace buffer, 

an interrupt will be triggered in the same time. 

The PDebugEnable signal is used to save power in 

configurations with the Traceport and functional clock gating. 

When the Traceport output from the Xtensa core is to be 

consumed, as in an active debug session, PDebugEnable must be 

set high. At other times, PDebugEnable can be set low. If the 

configuration has functional clock gating, setting PDebugEnable 

low gates off clocks to the flip-flops in the Traceport logic. 

This eliminates toggles in the Traceport logic and in the 

Xtensa Traceport interface, preventing wasted power. 

PDebugEnable is registered once inside the Xtensa core and the 

registered version of the signal is used to gate the clock to 

the flip-flops in the Traceport logic. Due to the pipelining of 

trace data within the processor, the Traceport output will be 

undefined for several cycles after PDebugEnable is asserted. In 

the cycles where data is undefined, PDebugStatus[5:0] will be 

"1111_00," to indicate "All other pipeline bubbles." 

PDebugEnable can be changed dynamically while the processor is 

running. It is the designer’s responsibility to control this 

interface using logic external to the processor. The signal can 

be tied high to always enable trace output, tied low to prevent 

any trace output, or controlled by external logic that can 

dynamically change the value. 

There are internal users of the Traceport — such as TRAX and the 

Performance Monitor — which also assert the PDebugEnable signal 

when the functions (i.e. PC tracing or performance monitoring) 

are enabled. This is achieved via an OR gate inside Xtensa that 

combines the respective PDebugEnable signals.</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_tbcg_en">tbcg_en</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>All trace buffer resources (including flops and TBUFFER) in 

Hifi1 wrapper is running with clock hifi1_cclk_tbcg, which is 

CG version of hifi1_clk, CG’s enable is controlled by ORed 

result of Ctrl.en_xt_trace and LSCNTEN automatically, but there 

is still a chance to enable this clock by this bit (set to 1), 

to save power, this bit should be kept in low in normal 

operation.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Prid">hifi1_wrapper_Prid</a></p>

</td>

<td><p>32'h00000004</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Prid_Prid">Prid</a></p>

</td>

<td><p>0x271</p>

</td>

<td><p>The processor ID (PRID) allows the system logic to provide each 

Xtensa processor with a unique identity by adding a 16-bit 

input bus, PRID , as an input to the processor core. When the 

processor comes out of reset, this input is latched into the 

low 16- bits of special register 235, which can be read by an 

RSR.PRID instruction. The PRID port is not a dynamic input. The 

processor only latches the value of the PRID port at reset time. 

The PRID input must be stable for 10 cycles following the 

deassertion of BReset. Changing the PRID input before this 

point produces unpredictable results. Changing the PRID input 

after this point has no effect on the PRID register.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_AltResetVec">hifi1_wrapper_AltResetVec</a></p>

</td>

<td><p>32'h00000008</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_AltResetVec_AltResetVec">AltResetVec</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When the Relocatable Vectors option is configured, then the 

sub-option External Reset Vector can be selected. When 

selected, these pins provide an alternate reset vector address. 

The timing of these signals is exactly the same as StatVectorSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_PFatalInfoL">hifi1_wrapper_PFatalInfoL</a></p>

</td>

<td><p>32'h0000000C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_PFatalInfoL_PFaultInfoL">PFaultInfoL</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Togeter with PFaultInfoH as 64-bit Fault information signal. 

PFaultInfoL mirrors the processor’s internal FIR, using the 

same bit encoding to provide the source and severity of the 

fault. This signal is set to the encoding of the most recent 

and most severe fault. The PFaultInfo signal is cleared by core 

reset 

Uses PFaultInfoValid to capture.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_PFatalInfoH">hifi1_wrapper_PFatalInfoH</a></p>

</td>

<td><p>32'h00000010</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_PFatalInfoH_PFaultInfoH">PFaultInfoH</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Togeter with PFaultInfoL as 64-bit Fault information signal. 

PFaultInfoL mirrors the processor’s internal FIR, using the 

same bit encoding to provide the source and severity of the 

fault. This signal is set to the encoding of the most recent 

and most severe fault. The PFaultInfo signal is cleared by core 

reset 

Uses PFaultInfoValid to capture PfaultInfoH[17:0]; uses 

PfaultInfoNonSpecValid to capture PfaultInfoH[18] and 

PfaultInfoH[31:21]</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Status">hifi1_wrapper_Status</a></p>

</td>

<td><p>32'h00000014</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Status_PFaultError">PFaultError</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Sticky fatal error notification signal that is asserted when a 

fatal error condition occurs (e.g., parity error on AXI 

handshake signal, or core trapped in the double exception 

vector). It is expected that the system will use the 

information presented on the PFaultInfo register and decide 

whether to reset the core or the whole system. The PFatalError 

signal is cleared by core reset.</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Status_DebugMode">DebugMode</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Same as XOCDMode but not maskable by software</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Status_XOCDMode">XOCDMode</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Indicates that the processor is in OCD halt mode</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Status_DoubleExceptionError">DoubleExceptionError</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Single cycle assertion every time a double exception fault 

occurs. Unlike PfatalError, this signal is not sticky. This bit 

is latched into the register</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Status_PWaitMode">PWaitMode</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Serves as an early warning indicator that the processor is about 

to begin its shutdown procedure and should no longer be 

interacted with. Once this signal and PWaitMode are both driven 

high, the PCM module will begin the shutdown sequence for the 

Core domain. Once the processor has completed its wakeup 

sequence, this signal is driven logic 

low again</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel0_BYTE</a></p>

</td>

<td><p>32'h00000018</p>

</td>

<td><p>used to select one of 256 SoC interrupt sources to each of 24 

hifi1 BInterrupt input, the Array size is equal to the hifi1 

BInterrupt bus width</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel1_BYTE</a></p>

</td>

<td><p>32'h0000001C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel2_BYTE</a></p>

</td>

<td><p>32'h00000020</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel3_BYTE</a></p>

</td>

<td><p>32'h00000024</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel4_BYTE</a></p>

</td>

<td><p>32'h00000028</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel5_BYTE</a></p>

</td>

<td><p>32'h0000002C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel6_BYTE</a></p>

</td>

<td><p>32'h00000030</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel7_BYTE</a></p>

</td>

<td><p>32'h00000034</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel8_BYTE</a></p>

</td>

<td><p>32'h00000038</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel9_BYTE</a></p>

</td>

<td><p>32'h0000003C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel10_BYTE</a></p>

</td>

<td><p>32'h00000040</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel11_BYTE</a></p>

</td>

<td><p>32'h00000044</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel12_BYTE</a></p>

</td>

<td><p>32'h00000048</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel13_BYTE</a></p>

</td>

<td><p>32'h0000004C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel14_BYTE</a></p>

</td>

<td><p>32'h00000050</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel15_BYTE</a></p>

</td>

<td><p>32'h00000054</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel16_BYTE</a></p>

</td>

<td><p>32'h00000058</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel17_BYTE</a></p>

</td>

<td><p>32'h0000005C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel18_BYTE</a></p>

</td>

<td><p>32'h00000060</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel19_BYTE</a></p>

</td>

<td><p>32'h00000064</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel20_BYTE</a></p>

</td>

<td><p>32'h00000068</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel21_BYTE</a></p>

</td>

<td><p>32'h0000006C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel22_BYTE</a></p>

</td>

<td><p>32'h00000070</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel23_BYTE</a></p>

</td>

<td><p>32'h00000074</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force0_DWORD</a></p>

</td>

<td><p>32'h00000078</p>

</td>

<td><p>used to assert interrupt by biu register write 

Array size should equal to ceil(SYSINTRNUM/32), for example, 

if SYSINTRNUM is 40, array size is 2; if SYSINTRNUM is 256, 

array size is 8</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force1_DWORD</a></p>

</td>

<td><p>32'h0000007C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force2_DWORD</a></p>

</td>

<td><p>32'h00000080</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force3_DWORD</a></p>

</td>

<td><p>32'h00000084</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force4_DWORD</a></p>

</td>

<td><p>32'h00000088</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force5_DWORD</a></p>

</td>

<td><p>32'h0000008C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force6_DWORD</a></p>

</td>

<td><p>32'h00000090</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force7_DWORD</a></p>

</td>

<td><p>32'h00000094</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit00_PC_LO</a></p>

</td>

<td><p>32'h00000098</p>

</td>

<td><p>Hifi1 Load & Store unit#0 has 8 counters, each counter is used 

to count the occurring of predefined event specified by 

corresponding $LSPORT.unit0[i], i = 0 ~ 7</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter 

the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates 

the Hifi core internal Program Counter value associated with the 

instruction completed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit00_PC_HI</a></p>

</td>

<td><p>32'h0000009C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter 

the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0] 

indicates the Hifi core internal Program Counter associated 

with the instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit00_LS_LO</a></p>

</td>

<td><p>32'h000000A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store low threshold (LS_LO) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit00_LS_HI</a></p>

</td>

<td><p>32'h000000A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store high threshold (LS_HI) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit00_LS_CNT</a></p>

</td>

<td><p>32'h000000A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>used to count three filtered condition occurrence: filter#1 on 

PDebugInst[7:0] != 0 and PDebugLS&lt; 0/1 >Stat[3:0] is either 

LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is 

specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]]; 

filter#3 on Trace bus PDebugLS&lt; 0/1 >Addr[27:0] is specified by 

range register [LS&lt; 0/1 >_LO[i][27:0], LS&lt; 0/1 >_HI[i][27:0]]. 

Counter[i] increments by 1 when all 3 filters conditions are 

met. Counter[i] will be capped on the value specified by 

register LSCNTSAT.cntsat, if counter[i] hits this value, an 

interrupt will be issued if it is not masked. Counter[i] will 

be cleared when register LSCNTCLR.ls&lt; 0/1 >_cnt&lt; i >_clr is 

asserted or register LSCNTEN.ls&lt; 0/1 >_cnt&lt; i >_en is de-asserted, 

i is 0~7, each LS&lt; 0/1 > has 8 counters.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit01_PC_LO</a></p>

</td>

<td><p>32'h000000AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter 

the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates 

the Hifi core internal Program Counter value associated with the 

instruction completed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit01_PC_HI</a></p>

</td>

<td><p>32'h000000B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter 

the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0] 

indicates the Hifi core internal Program Counter associated 

with the instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit01_LS_LO</a></p>

</td>

<td><p>32'h000000B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store low threshold (LS_LO) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit01_LS_HI</a></p>

</td>

<td><p>32'h000000B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store high threshold (LS_HI) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit01_LS_CNT</a></p>

</td>

<td><p>32'h000000BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>used to count three filtered condition occurrence: filter#1 on 

PDebugInst[7:0] != 0 and PDebugLS&lt; 0/1 >Stat[3:0] is either 

LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is 

specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]]; 

filter#3 on Trace bus PDebugLS&lt; 0/1 >Addr[27:0] is specified by 

range register [LS&lt; 0/1 >_LO[i][27:0], LS&lt; 0/1 >_HI[i][27:0]]. 

Counter[i] increments by 1 when all 3 filters conditions are 

met. Counter[i] will be capped on the value specified by 

register LSCNTSAT.cntsat, if counter[i] hits this value, an 

interrupt will be issued if it is not masked. Counter[i] will 

be cleared when register LSCNTCLR.ls&lt; 0/1 >_cnt&lt; i >_clr is 

asserted or register LSCNTEN.ls&lt; 0/1 >_cnt&lt; i >_en is de-asserted, 

i is 0~7, each LS&lt; 0/1 > has 8 counters.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit02_PC_LO</a></p>

</td>

<td><p>32'h000000C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter 

the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates 

the Hifi core internal Program Counter value associated with the 

instruction completed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit02_PC_HI</a></p>

</td>

<td><p>32'h000000C4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter 

the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0] 

indicates the Hifi core internal Program Counter associated 

with the instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit02_LS_LO</a></p>

</td>

<td><p>32'h000000C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store low threshold (LS_LO) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit02_LS_HI</a></p>

</td>

<td><p>32'h000000CC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store high threshold (LS_HI) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit02_LS_CNT</a></p>

</td>

<td><p>32'h000000D0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>used to count three filtered condition occurrence: filter#1 on 

PDebugInst[7:0] != 0 and PDebugLS&lt; 0/1 >Stat[3:0] is either 

LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is 

specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]]; 

filter#3 on Trace bus PDebugLS&lt; 0/1 >Addr[27:0] is specified by 

range register [LS&lt; 0/1 >_LO[i][27:0], LS&lt; 0/1 >_HI[i][27:0]]. 

Counter[i] increments by 1 when all 3 filters conditions are 

met. Counter[i] will be capped on the value specified by 

register LSCNTSAT.cntsat, if counter[i] hits this value, an 

interrupt will be issued if it is not masked. Counter[i] will 

be cleared when register LSCNTCLR.ls&lt; 0/1 >_cnt&lt; i >_clr is 

asserted or register LSCNTEN.ls&lt; 0/1 >_cnt&lt; i >_en is de-asserted, 

i is 0~7, each LS&lt; 0/1 > has 8 counters.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit03_PC_LO</a></p>

</td>

<td><p>32'h000000D4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter 

the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates 

the Hifi core internal Program Counter value associated with the 

instruction completed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit03_PC_HI</a></p>

</td>

<td><p>32'h000000D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter 

the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0] 

indicates the Hifi core internal Program Counter associated 

with the instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit03_LS_LO</a></p>

</td>

<td><p>32'h000000DC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store low threshold (LS_LO) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit03_LS_HI</a></p>

</td>

<td><p>32'h000000E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store high threshold (LS_HI) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit03_LS_CNT</a></p>

</td>

<td><p>32'h000000E4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>used to count three filtered condition occurrence: filter#1 on 

PDebugInst[7:0] != 0 and PDebugLS&lt; 0/1 >Stat[3:0] is either 

LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is 

specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]]; 

filter#3 on Trace bus PDebugLS&lt; 0/1 >Addr[27:0] is specified by 

range register [LS&lt; 0/1 >_LO[i][27:0], LS&lt; 0/1 >_HI[i][27:0]]. 

Counter[i] increments by 1 when all 3 filters conditions are 

met. Counter[i] will be capped on the value specified by 

register LSCNTSAT.cntsat, if counter[i] hits this value, an 

interrupt will be issued if it is not masked. Counter[i] will 

be cleared when register LSCNTCLR.ls&lt; 0/1 >_cnt&lt; i >_clr is 

asserted or register LSCNTEN.ls&lt; 0/1 >_cnt&lt; i >_en is de-asserted, 

i is 0~7, each LS&lt; 0/1 > has 8 counters.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit04_PC_LO</a></p>

</td>

<td><p>32'h000000E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter 

the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates 

the Hifi core internal Program Counter value associated with the 

instruction completed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit04_PC_HI</a></p>

</td>

<td><p>32'h000000EC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter 

the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0] 

indicates the Hifi core internal Program Counter associated 

with the instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit04_LS_LO</a></p>

</td>

<td><p>32'h000000F0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store low threshold (LS_LO) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit04_LS_HI</a></p>

</td>

<td><p>32'h000000F4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store high threshold (LS_HI) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit04_LS_CNT</a></p>

</td>

<td><p>32'h000000F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>used to count three filtered condition occurrence: filter#1 on 

PDebugInst[7:0] != 0 and PDebugLS&lt; 0/1 >Stat[3:0] is either 

LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is 

specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]]; 

filter#3 on Trace bus PDebugLS&lt; 0/1 >Addr[27:0] is specified by 

range register [LS&lt; 0/1 >_LO[i][27:0], LS&lt; 0/1 >_HI[i][27:0]]. 

Counter[i] increments by 1 when all 3 filters conditions are 

met. Counter[i] will be capped on the value specified by 

register LSCNTSAT.cntsat, if counter[i] hits this value, an 

interrupt will be issued if it is not masked. Counter[i] will 

be cleared when register LSCNTCLR.ls&lt; 0/1 >_cnt&lt; i >_clr is 

asserted or register LSCNTEN.ls&lt; 0/1 >_cnt&lt; i >_en is de-asserted, 

i is 0~7, each LS&lt; 0/1 > has 8 counters.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit05_PC_LO</a></p>

</td>

<td><p>32'h000000FC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter 

the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates 

the Hifi core internal Program Counter value associated with the 

instruction completed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit05_PC_HI</a></p>

</td>

<td><p>32'h00000100</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter 

the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0] 

indicates the Hifi core internal Program Counter associated 

with the instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit05_LS_LO</a></p>

</td>

<td><p>32'h00000104</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store low threshold (LS_LO) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit05_LS_HI</a></p>

</td>

<td><p>32'h00000108</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store high threshold (LS_HI) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit05_LS_CNT</a></p>

</td>

<td><p>32'h0000010C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>used to count three filtered condition occurrence: filter#1 on 

PDebugInst[7:0] != 0 and PDebugLS&lt; 0/1 >Stat[3:0] is either 

LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is 

specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]]; 

filter#3 on Trace bus PDebugLS&lt; 0/1 >Addr[27:0] is specified by 

range register [LS&lt; 0/1 >_LO[i][27:0], LS&lt; 0/1 >_HI[i][27:0]]. 

Counter[i] increments by 1 when all 3 filters conditions are 

met. Counter[i] will be capped on the value specified by 

register LSCNTSAT.cntsat, if counter[i] hits this value, an 

interrupt will be issued if it is not masked. Counter[i] will 

be cleared when register LSCNTCLR.ls&lt; 0/1 >_cnt&lt; i >_clr is 

asserted or register LSCNTEN.ls&lt; 0/1 >_cnt&lt; i >_en is de-asserted, 

i is 0~7, each LS&lt; 0/1 > has 8 counters.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit06_PC_LO</a></p>

</td>

<td><p>32'h00000110</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter 

the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates 

the Hifi core internal Program Counter value associated with the 

instruction completed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit06_PC_HI</a></p>

</td>

<td><p>32'h00000114</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter 

the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0] 

indicates the Hifi core internal Program Counter associated 

with the instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit06_LS_LO</a></p>

</td>

<td><p>32'h00000118</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store low threshold (LS_LO) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit06_LS_HI</a></p>

</td>

<td><p>32'h0000011C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store high threshold (LS_HI) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit06_LS_CNT</a></p>

</td>

<td><p>32'h00000120</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>used to count three filtered condition occurrence: filter#1 on 

PDebugInst[7:0] != 0 and PDebugLS&lt; 0/1 >Stat[3:0] is either 

LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is 

specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]]; 

filter#3 on Trace bus PDebugLS&lt; 0/1 >Addr[27:0] is specified by 

range register [LS&lt; 0/1 >_LO[i][27:0], LS&lt; 0/1 >_HI[i][27:0]]. 

Counter[i] increments by 1 when all 3 filters conditions are 

met. Counter[i] will be capped on the value specified by 

register LSCNTSAT.cntsat, if counter[i] hits this value, an 

interrupt will be issued if it is not masked. Counter[i] will 

be cleared when register LSCNTCLR.ls&lt; 0/1 >_cnt&lt; i >_clr is 

asserted or register LSCNTEN.ls&lt; 0/1 >_cnt&lt; i >_en is de-asserted, 

i is 0~7, each LS&lt; 0/1 > has 8 counters.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit07_PC_LO</a></p>

</td>

<td><p>32'h00000124</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter 

the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates 

the Hifi core internal Program Counter value associated with the 

instruction completed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit07_PC_HI</a></p>

</td>

<td><p>32'h00000128</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter 

the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0] 

indicates the Hifi core internal Program Counter associated 

with the instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit07_LS_LO</a></p>

</td>

<td><p>32'h0000012C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store low threshold (LS_LO) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit07_LS_HI</a></p>

</td>

<td><p>32'h00000130</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[27:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Load/Store high threshold (LS_HI) is used to filter the value 

on Tracee bus PDebugLS&lt; 0/1 >Addr[27:0], PDebugLS&lt; 0/1 >Addr[27:0] 

indicates the virtual memory address used in a load/store unit 

&lt; 0/1 > instruction processed in the W (Writeback) stage.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit07_LS_CNT</a></p>

</td>

<td><p>32'h00000134</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>used to count three filtered condition occurrence: filter#1 on 

PDebugInst[7:0] != 0 and PDebugLS&lt; 0/1 >Stat[3:0] is either 

LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is 

specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]]; 

filter#3 on Trace bus PDebugLS&lt; 0/1 >Addr[27:0] is specified by 

range register [LS&lt; 0/1 >_LO[i][27:0], LS&lt; 0/1 >_HI[i][27:0]]. 

Counter[i] increments by 1 when all 3 filters conditions are 

met. Counter[i] will be capped on the value specified by 

register LSCNTSAT.cntsat, if counter[i] hits this value, an 

interrupt will be issued if it is not masked. Counter[i] will 

be cleared when register LSCNTCLR.ls&lt; 0/1 >_cnt&lt; i >_clr is 

asserted or register LSCNTEN.ls&lt; 0/1 >_cnt&lt; i >_en is de-asserted, 

i is 0~7, each LS&lt; 0/1 > has 8 counters.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN">hifi1_wrapper_LSCNTEN</a></p>

</td>

<td><p>32'h00000138</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt0_en">ls0_cnt0_en</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Counter#0 enable bit in LS unit#0</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt1_en">ls0_cnt1_en</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Counter#1 enable bit in LS unit#0</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt2_en">ls0_cnt2_en</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Counter#2 enable bit in LS unit#0</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt3_en">ls0_cnt3_en</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Counter#3 enable bit in LS unit#0</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt4_en">ls0_cnt4_en</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Counter#4 enable bit in LS unit#0</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt5_en">ls0_cnt5_en</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Counter#5 enable bit in LS unit#0</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt6_en">ls0_cnt6_en</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Counter#6 enable bit in LS unit#0</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt7_en">ls0_cnt7_en</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Counter#7 enable bit in LS unit#0</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR">hifi1_wrapper_LSCNTCLR</a></p>

</td>

<td><p>32'h0000013C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt0_clr">ls0_cnt0_clr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>LS unit#0 Counter#0 value will be cleared once this bit is 

asserted, bit is de-asserted automatically by HW after SW 

assertion.</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt1_clr">ls0_cnt1_clr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>LS unit#0 Counter#1 value will be cleared once this bit is 

asserted, bit is de-asserted automatically by HW after SW 

assertion.</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt2_clr">ls0_cnt2_clr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>LS unit#0 Counter#2 value will be cleared once this bit is 

asserted, bit is de-asserted automatically by HW after SW 

assertion.</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt3_clr">ls0_cnt3_clr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>LS unit#0 Counter#3 value will be cleared once this bit is 

asserted, bit is de-asserted automatically by HW after SW 

assertion.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt4_clr">ls0_cnt4_clr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>LS unit#0 Counter#4 value will be cleared once this bit is 

asserted, bit is de-asserted automatically by HW after SW 

assertion.</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt5_clr">ls0_cnt5_clr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>LS unit#0 Counter#5 value will be cleared once this bit is 

asserted, bit is de-asserted automatically by HW after SW 

assertion.</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt6_clr">ls0_cnt6_clr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>LS unit#0 Counter#6 value will be cleared once this bit is 

asserted, bit is de-asserted automatically by HW after SW 

assertion.</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt7_clr">ls0_cnt7_clr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>LS unit#0 Counter#7 value will be cleared once this bit is 

asserted, bit is de-asserted automatically by HW after SW 

assertion.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTSAT">hifi1_wrapper_LSCNTSAT</a></p>

</td>

<td><p>32'h00000140</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTSAT_cntsat">cntsat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Each counter in LS0 will be capped to cntsat, when it happens, 

an interrupt will be sent if it is not masked.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_">hifi1_wrapper_mem</a></p>

</td>

<td><p>32'h00000400</p>

</td>

<td><p>Trace buffer (128 x 64b), used to do PDebug* data logging based 

on predefined event occurring, only PDebugInst[7:0] != 0 && 

(PDebugLS0Stat[3:0] == (LD or ST)) is considered as a valid 

event, not all valid events are recorded into trace buffer, 

only one of every (LSWCTRL.sample_cycle_cnt+1) continuous valid 

events will be logged into trace buffer (event decimation), the 

number of total logged event is also limited by LSWCTRL.wlimit, 

once trace buffer accumulated (LSWCTRL.wlimit+1) entries, 

Ctrl.en_xt_trace will be cleared by HW automatically and an 

interrupt will be triggered in the same time. 

Internal memory</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p>Memory</p>

</td>

<td><p> 

</p>

</td>

<td><p>Memory</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSWCTRL">hifi1_wrapper_LSWCTRL</a></p>

</td>

<td><p>32'h00000800</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[6:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSWCTRL_wlimit">wlimit</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Used to limit the number of Trace buffer entries (real number is 

LSWCTRL.wlimit+1) can be used to log PDebug* data, 

LSWCTRL.wlimit is the maximum address can be hit before 

Ctrl.en_xt_trace is turn off by HW.</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSWCTRL_reserved_b7">reserved_b7</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[27:8]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSWCTRL_sample_cycle_cnt">sample_cycle_cnt</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Used to control the skip number of LS valid event before a trace 

buffer event write, in HW it controls the rollover of LS valid 

event occurring sample counter, whenever the sample counter 

reaches the value of sample_cycle_cnt, the sample counter rolls 

back to 0, in the meantime a pulse is generated as trace buffer 

write enable, and same pulse is used to increase trace buffer 

write address pointer WRPTR by 1 if it doesn’t hit the maximum 

address specified by wlimit. The minimum number of 

sample_cycle_cnt is 0, 0 means no LS valid event skipping.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_TBWRPTR">hifi1_wrapper_TBWRPTR</a></p>

</td>

<td><p>32'h00000804</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[6:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_TBWRPTR_wr_pointer">wr_pointer</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Reflect real value of HW trace buffer write pointer, incremental 

by decimated predefined valid event occurring, cleared once 

write pointer reaches LSWCTRL.wlimit</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA">hifi1_wrapper_INTR_STA</a></p>

</td>

<td><p>32'h00000808</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt0_sat">ls0cnt0_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to 1 when LS unit#0 counter#0 is saturated, write “1” to 

clear this bit</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt1_sat">ls0cnt1_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to 1 when LS unit#0 counter#1 is saturated, write “1” to 

clear this bit</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt2_sat">ls0cnt2_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to 1 when LS unit#0 counter#2 is saturated, write “1” to 

clear this bit</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt3_sat">ls0cnt3_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to 1 when LS unit#0 counter#3 is saturated, write “1” to 

clear this bit</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt4_sat">ls0cnt4_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to 1 when LS unit#0 counter#4 is saturated, write “1” to 

clear this bit</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt5_sat">ls0cnt5_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to 1 when LS unit#0 counter#5 is saturated, write “1” to 

clear this bit</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt6_sat">ls0cnt6_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to 1 when LS unit#0 counter#6 is saturated, write “1” to 

clear this bit</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt7_sat">ls0cnt7_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to 1 when LS unit#0 counter#7 is saturated, write “1” to 

clear this bit</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_tb_wrptr_sat">tb_wrptr_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to 1 when Trace Buffer write pointer is saturated, write “1” 

to clear this bit</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK">hifi1_wrapper_INTR_MASK</a></p>

</td>

<td><p>32'h0000080C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt0_sat">ls0cnt0_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Mask bit for INTR_STA.ls0cnt0_sat, when it is set, Hifi1_wrap 

final interrupt will ignore the status of INTR_STA.ls0cnt0_sat</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt1_sat">ls0cnt1_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Mask bit for INTR_STA.ls0cnt1_sat, when it is set, Hifi1_wrap 

final interrupt will ignore the status of INTR_STA.ls0cnt1_sat</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt2_sat">ls0cnt2_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Mask bit for INTR_STA.ls0cnt2_sat, when it is set, Hifi1_wrap 

final interrupt will ignore the status of INTR_STA.ls0cnt2_sat</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt3_sat">ls0cnt3_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Mask bit for INTR_STA.ls0cnt3_sat, when it is set, Hifi1_wrap 

final interrupt will ignore the status of INTR_STA.ls0cnt3_sat</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt4_sat">ls0cnt4_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Mask bit for INTR_STA.ls0cnt4_sat, when it is set, Hifi1_wrap 

final interrupt will ignore the status of INTR_STA.ls0cnt4_sat</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt5_sat">ls0cnt5_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Mask bit for INTR_STA.ls0cnt5_sat, when it is set, Hifi1_wrap 

final interrupt will ignore the status of INTR_STA.ls0cnt5_sat</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt6_sat">ls0cnt6_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Mask bit for INTR_STA.ls0cnt6_sat, when it is set, Hifi1_wrap 

final interrupt will ignore the status of INTR_STA.ls0cnt6_sat</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt7_sat">ls0cnt7_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Mask bit for INTR_STA.ls0cnt7_sat, when it is set, Hifi1_wrap 

final interrupt will ignore the status of INTR_STA.ls0cnt7_sat</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_tb_wrptr_sat">tb_wrptr_sat</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Mask bit for INTR_STA.tb_wrptr_sat, when it is set, Hifi1_wrap 

final interrupt will ignore the status of INTR_STA.tb_wrptr_sat</p>

</td>

</tr>

</table><p> 

</p>

</body></html>