<?xml version="1.0" encoding="utf-8"?><html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd"><head><title>hifi1_wrapper</title></head>
<body>
<h1><a name="hifi1_wrapper">"hifi1_wrapper"</a>
        </h1>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl">hifi1_wrapper_Ctrl</a></p>
</td>
<td><p>32'h00000000</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_OCDHaltOnReset">OCDHaltOnReset</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enters OCDHaltMode if this signal is sampled asserted on reset</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_DoubleExceptionErrorClr">DoubleExceptionErrorClr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>1: clear;</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_PFaultInfoClr">PFaultInfoClr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>1:clear</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_RunStall">RunStall</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>When set, causes the HiFi1 processor1 to stall.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_StatVectorSel">StatVectorSel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Select between one of the two stationary vector bases.<p></p>
0:default, 1: alternative<p></p>
It must be held stable for at least 10 CLK cycles before the<p></p>
falling edge of BReset , and for 10 CLK cycles after the<p></p>
falling edge of BReset.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_en_xt_trace">en_xt_trace</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>External trace buffer enable, when this bit is set to 1,<p></p>
predefined PDebug* data will be logged into hifi1 trace buffer<p></p>
(128x64-bit), ‘Ored” result (with each LS counter enable bit in<p></p>
LSCNTEN) will drive HiFi1 core PDebugEnable input. This bit will<p></p>
be cleared by HW automatically once predefined number<p></p>
(LSWCTRL.wlimit+1) of entries has been logged in trace buffer,<p></p>
an interrupt will be triggered in the same time.<p></p>
The PDebugEnable signal is used to save power in<p></p>
configurations with the Traceport and functional clock gating.<p></p>
When the Traceport output from the Xtensa core is to be<p></p>
consumed, as in an active debug session, PDebugEnable must be<p></p>
set high. At other times, PDebugEnable can be set low. If the<p></p>
configuration has functional clock gating, setting PDebugEnable<p></p>
low gates off clocks to the flip-flops in the Traceport logic.<p></p>
This eliminates toggles in the Traceport logic and in the<p></p>
Xtensa Traceport interface, preventing wasted power.<p></p>
PDebugEnable is registered once inside the Xtensa core and the<p></p>
registered version of the signal is used to gate the clock to<p></p>
the flip-flops in the Traceport logic. Due to the pipelining of<p></p>
trace data within the processor, the Traceport output will be<p></p>
undefined for several cycles after PDebugEnable is asserted. In<p></p>
the cycles where data is undefined, PDebugStatus[5:0] will be<p></p>
"1111_00," to indicate "All other pipeline bubbles."<p></p>
PDebugEnable can be changed dynamically while the processor is<p></p>
running. It is the designer’s responsibility to control this<p></p>
interface using logic external to the processor. The signal can<p></p>
be tied high to always enable trace output, tied low to prevent<p></p>
any trace output, or controlled by external logic that can<p></p>
dynamically change the value.<p></p>
There are internal users of the Traceport — such as TRAX and the<p></p>
Performance Monitor — which also assert the PDebugEnable signal<p></p>
when the functions (i.e. PC tracing or performance monitoring)<p></p>
are enabled. This is achieved via an OR gate inside Xtensa that<p></p>
combines the respective PDebugEnable signals.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Ctrl_tbcg_en">tbcg_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>All trace buffer resources (including flops and TBUFFER) in<p></p>
Hifi1 wrapper is running with clock hifi1_cclk_tbcg, which is<p></p>
CG version of hifi1_clk, CG’s enable is controlled by ORed<p></p>
result of Ctrl.en_xt_trace and LSCNTEN automatically, but there<p></p>
is still a chance to enable this clock by this bit (set to 1),<p></p>
to save power, this bit should be kept in low in normal<p></p>
operation.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Prid">hifi1_wrapper_Prid</a></p>
</td>
<td><p>32'h00000004</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Prid_Prid">Prid</a></p>
</td>
<td><p>0x271</p>
</td>
<td><p>The processor ID (PRID) allows the system logic to provide each<p></p>
Xtensa processor with a unique identity by adding a 16-bit<p></p>
input bus, PRID , as an input to the processor core. When the<p></p>
processor comes out of reset, this input is latched into the<p></p>
low 16- bits of special register 235, which can be read by an<p></p>
RSR.PRID instruction. The PRID port is not a dynamic input. The<p></p>
processor only latches the value of the PRID port at reset time.<p></p>
The PRID input must be stable for 10 cycles following the<p></p>
deassertion of BReset. Changing the PRID input before this<p></p>
point produces unpredictable results. Changing the PRID input<p></p>
after this point has no effect on the PRID register.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_AltResetVec">hifi1_wrapper_AltResetVec</a></p>
</td>
<td><p>32'h00000008</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_AltResetVec_AltResetVec">AltResetVec</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When the Relocatable Vectors option is configured, then the<p></p>
sub-option External Reset Vector can be selected. When<p></p>
selected, these pins provide an alternate reset vector address.<p></p>
The timing of these signals is exactly the same as StatVectorSel</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_PFatalInfoL">hifi1_wrapper_PFatalInfoL</a></p>
</td>
<td><p>32'h0000000C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_PFatalInfoL_PFaultInfoL">PFaultInfoL</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p>Togeter with PFaultInfoH as 64-bit Fault information signal.<p></p>
PFaultInfoL mirrors the processor’s internal FIR, using the<p></p>
same bit encoding to provide the source and severity of the<p></p>
fault. This signal is set to the encoding of the most recent<p></p>
and most severe fault. The PFaultInfo signal is cleared by core<p></p>
reset<p></p>
Uses PFaultInfoValid to capture.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_PFatalInfoH">hifi1_wrapper_PFatalInfoH</a></p>
</td>
<td><p>32'h00000010</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_PFatalInfoH_PFaultInfoH">PFaultInfoH</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p>Togeter with PFaultInfoL as 64-bit Fault information signal.<p></p>
PFaultInfoL mirrors the processor’s internal FIR, using the<p></p>
same bit encoding to provide the source and severity of the<p></p>
fault. This signal is set to the encoding of the most recent<p></p>
and most severe fault. The PFaultInfo signal is cleared by core<p></p>
reset<p></p>
Uses PFaultInfoValid to capture PfaultInfoH[17:0]; uses<p></p>
PfaultInfoNonSpecValid to capture PfaultInfoH[18] and<p></p>
PfaultInfoH[31:21]</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Status">hifi1_wrapper_Status</a></p>
</td>
<td><p>32'h00000014</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Status_PFaultError">PFaultError</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p>Sticky fatal error notification signal that is asserted when a<p></p>
fatal error condition occurs (e.g., parity error on AXI<p></p>
handshake signal, or core trapped in the double exception<p></p>
vector). It is expected that the system will use the<p></p>
information presented on the PFaultInfo register and decide<p></p>
whether to reset the core or the whole system. The PFatalError<p></p>
signal is cleared by core reset.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Status_DebugMode">DebugMode</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p>Same as XOCDMode but not maskable by software</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Status_XOCDMode">XOCDMode</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p>Indicates that the processor is in OCD halt mode</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Status_DoubleExceptionError">DoubleExceptionError</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p>Single cycle assertion every time a double exception fault<p></p>
occurs. Unlike PfatalError, this signal is not sticky. This bit<p></p>
is latched into the register</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_Status_PWaitMode">PWaitMode</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p>Serves as an early warning indicator that the processor is about<p></p>
to begin its shutdown procedure and should no longer be<p></p>
interacted with. Once this signal and PWaitMode are both driven<p></p>
high, the PCM module will begin the shutdown sequence for the<p></p>
Core domain. Once the processor has completed its wakeup<p></p>
sequence, this signal is driven logic<p></p>
low again</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel0_BYTE</a></p>
</td>
<td><p>32'h00000018</p>
</td>
<td><p>used to select one of 256 SoC interrupt sources to each of 24<p></p>
hifi1 BInterrupt input, the Array size is equal to the hifi1<p></p>
BInterrupt bus width</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel1_BYTE</a></p>
</td>
<td><p>32'h0000001C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel2_BYTE</a></p>
</td>
<td><p>32'h00000020</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel3_BYTE</a></p>
</td>
<td><p>32'h00000024</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel4_BYTE</a></p>
</td>
<td><p>32'h00000028</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel5_BYTE</a></p>
</td>
<td><p>32'h0000002C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel6_BYTE</a></p>
</td>
<td><p>32'h00000030</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel7_BYTE</a></p>
</td>
<td><p>32'h00000034</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel8_BYTE</a></p>
</td>
<td><p>32'h00000038</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel9_BYTE</a></p>
</td>
<td><p>32'h0000003C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel10_BYTE</a></p>
</td>
<td><p>32'h00000040</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel11_BYTE</a></p>
</td>
<td><p>32'h00000044</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel12_BYTE</a></p>
</td>
<td><p>32'h00000048</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel13_BYTE</a></p>
</td>
<td><p>32'h0000004C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel14_BYTE</a></p>
</td>
<td><p>32'h00000050</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel15_BYTE</a></p>
</td>
<td><p>32'h00000054</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel16_BYTE</a></p>
</td>
<td><p>32'h00000058</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel17_BYTE</a></p>
</td>
<td><p>32'h0000005C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel18_BYTE</a></p>
</td>
<td><p>32'h00000060</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel19_BYTE</a></p>
</td>
<td><p>32'h00000064</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel20_BYTE</a></p>
</td>
<td><p>32'h00000068</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel21_BYTE</a></p>
</td>
<td><p>32'h0000006C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel22_BYTE</a></p>
</td>
<td><p>32'h00000070</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE">hifi1_wrapper_sysIntrSel23_BYTE</a></p>
</td>
<td><p>32'h00000074</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYBYTE_BYTE_byte">byte</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force0_DWORD</a></p>
</td>
<td><p>32'h00000078</p>
</td>
<td><p>used to assert interrupt by biu register write<p></p>
Array size should equal to ceil(SYSINTRNUM/32), for example,<p></p>
if SYSINTRNUM is 40, array size is 2; if SYSINTRNUM is 256,<p></p>
array size is 8</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force1_DWORD</a></p>
</td>
<td><p>32'h0000007C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force2_DWORD</a></p>
</td>
<td><p>32'h00000080</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force3_DWORD</a></p>
</td>
<td><p>32'h00000084</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force4_DWORD</a></p>
</td>
<td><p>32'h00000088</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force5_DWORD</a></p>
</td>
<td><p>32'h0000008C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force6_DWORD</a></p>
</td>
<td><p>32'h00000090</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD">hifi1_wrapper_sysIntrForce_interrupt_force7_DWORD</a></p>
</td>
<td><p>32'h00000094</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#HIFI1DMYDWORD_DWORD_dword">dword</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit00_PC_LO</a></p>
</td>
<td><p>32'h00000098</p>
</td>
<td><p>Hifi1 Load & Store unit#0 has 8 counters, each counter is used<p></p>
to count the occurring of predefined event specified by<p></p>
corresponding $LSPORT.unit0[i], i = 0 ~ 7</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter<p></p>
the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates<p></p>
the Hifi core internal Program Counter value associated with the<p></p>
instruction completed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit00_PC_HI</a></p>
</td>
<td><p>32'h0000009C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter<p></p>
the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0]<p></p>
indicates the Hifi core internal Program Counter associated<p></p>
with the instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit00_LS_LO</a></p>
</td>
<td><p>32'h000000A0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store low threshold (LS_LO) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit00_LS_HI</a></p>
</td>
<td><p>32'h000000A4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store high threshold (LS_HI) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit00_LS_CNT</a></p>
</td>
<td><p>32'h000000A8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>used to count three filtered condition occurrence: filter#1 on<p></p>
PDebugInst[7:0] != 0 and PDebugLS< 0/1 >Stat[3:0] is either<p></p>
LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is<p></p>
specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]];<p></p>
filter#3 on Trace bus PDebugLS< 0/1 >Addr[27:0] is specified by<p></p>
range register [LS< 0/1 >_LO[i][27:0], LS< 0/1 >_HI[i][27:0]].<p></p>
Counter[i] increments by 1 when all 3 filters conditions are<p></p>
met. Counter[i] will be capped on the value specified by<p></p>
register LSCNTSAT.cntsat, if counter[i] hits this value, an<p></p>
interrupt will be issued if it is not masked. Counter[i] will<p></p>
be cleared when register LSCNTCLR.ls< 0/1 >_cnt< i >_clr is<p></p>
asserted or register LSCNTEN.ls< 0/1 >_cnt< i >_en is de-asserted,<p></p>
i is 0~7, each LS< 0/1 > has 8 counters.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit01_PC_LO</a></p>
</td>
<td><p>32'h000000AC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter<p></p>
the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates<p></p>
the Hifi core internal Program Counter value associated with the<p></p>
instruction completed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit01_PC_HI</a></p>
</td>
<td><p>32'h000000B0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter<p></p>
the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0]<p></p>
indicates the Hifi core internal Program Counter associated<p></p>
with the instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit01_LS_LO</a></p>
</td>
<td><p>32'h000000B4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store low threshold (LS_LO) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit01_LS_HI</a></p>
</td>
<td><p>32'h000000B8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store high threshold (LS_HI) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit01_LS_CNT</a></p>
</td>
<td><p>32'h000000BC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>used to count three filtered condition occurrence: filter#1 on<p></p>
PDebugInst[7:0] != 0 and PDebugLS< 0/1 >Stat[3:0] is either<p></p>
LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is<p></p>
specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]];<p></p>
filter#3 on Trace bus PDebugLS< 0/1 >Addr[27:0] is specified by<p></p>
range register [LS< 0/1 >_LO[i][27:0], LS< 0/1 >_HI[i][27:0]].<p></p>
Counter[i] increments by 1 when all 3 filters conditions are<p></p>
met. Counter[i] will be capped on the value specified by<p></p>
register LSCNTSAT.cntsat, if counter[i] hits this value, an<p></p>
interrupt will be issued if it is not masked. Counter[i] will<p></p>
be cleared when register LSCNTCLR.ls< 0/1 >_cnt< i >_clr is<p></p>
asserted or register LSCNTEN.ls< 0/1 >_cnt< i >_en is de-asserted,<p></p>
i is 0~7, each LS< 0/1 > has 8 counters.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit02_PC_LO</a></p>
</td>
<td><p>32'h000000C0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter<p></p>
the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates<p></p>
the Hifi core internal Program Counter value associated with the<p></p>
instruction completed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit02_PC_HI</a></p>
</td>
<td><p>32'h000000C4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter<p></p>
the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0]<p></p>
indicates the Hifi core internal Program Counter associated<p></p>
with the instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit02_LS_LO</a></p>
</td>
<td><p>32'h000000C8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store low threshold (LS_LO) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit02_LS_HI</a></p>
</td>
<td><p>32'h000000CC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store high threshold (LS_HI) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit02_LS_CNT</a></p>
</td>
<td><p>32'h000000D0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>used to count three filtered condition occurrence: filter#1 on<p></p>
PDebugInst[7:0] != 0 and PDebugLS< 0/1 >Stat[3:0] is either<p></p>
LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is<p></p>
specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]];<p></p>
filter#3 on Trace bus PDebugLS< 0/1 >Addr[27:0] is specified by<p></p>
range register [LS< 0/1 >_LO[i][27:0], LS< 0/1 >_HI[i][27:0]].<p></p>
Counter[i] increments by 1 when all 3 filters conditions are<p></p>
met. Counter[i] will be capped on the value specified by<p></p>
register LSCNTSAT.cntsat, if counter[i] hits this value, an<p></p>
interrupt will be issued if it is not masked. Counter[i] will<p></p>
be cleared when register LSCNTCLR.ls< 0/1 >_cnt< i >_clr is<p></p>
asserted or register LSCNTEN.ls< 0/1 >_cnt< i >_en is de-asserted,<p></p>
i is 0~7, each LS< 0/1 > has 8 counters.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit03_PC_LO</a></p>
</td>
<td><p>32'h000000D4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter<p></p>
the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates<p></p>
the Hifi core internal Program Counter value associated with the<p></p>
instruction completed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit03_PC_HI</a></p>
</td>
<td><p>32'h000000D8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter<p></p>
the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0]<p></p>
indicates the Hifi core internal Program Counter associated<p></p>
with the instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit03_LS_LO</a></p>
</td>
<td><p>32'h000000DC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store low threshold (LS_LO) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit03_LS_HI</a></p>
</td>
<td><p>32'h000000E0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store high threshold (LS_HI) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit03_LS_CNT</a></p>
</td>
<td><p>32'h000000E4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>used to count three filtered condition occurrence: filter#1 on<p></p>
PDebugInst[7:0] != 0 and PDebugLS< 0/1 >Stat[3:0] is either<p></p>
LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is<p></p>
specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]];<p></p>
filter#3 on Trace bus PDebugLS< 0/1 >Addr[27:0] is specified by<p></p>
range register [LS< 0/1 >_LO[i][27:0], LS< 0/1 >_HI[i][27:0]].<p></p>
Counter[i] increments by 1 when all 3 filters conditions are<p></p>
met. Counter[i] will be capped on the value specified by<p></p>
register LSCNTSAT.cntsat, if counter[i] hits this value, an<p></p>
interrupt will be issued if it is not masked. Counter[i] will<p></p>
be cleared when register LSCNTCLR.ls< 0/1 >_cnt< i >_clr is<p></p>
asserted or register LSCNTEN.ls< 0/1 >_cnt< i >_en is de-asserted,<p></p>
i is 0~7, each LS< 0/1 > has 8 counters.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit04_PC_LO</a></p>
</td>
<td><p>32'h000000E8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter<p></p>
the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates<p></p>
the Hifi core internal Program Counter value associated with the<p></p>
instruction completed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit04_PC_HI</a></p>
</td>
<td><p>32'h000000EC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter<p></p>
the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0]<p></p>
indicates the Hifi core internal Program Counter associated<p></p>
with the instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit04_LS_LO</a></p>
</td>
<td><p>32'h000000F0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store low threshold (LS_LO) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit04_LS_HI</a></p>
</td>
<td><p>32'h000000F4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store high threshold (LS_HI) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit04_LS_CNT</a></p>
</td>
<td><p>32'h000000F8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>used to count three filtered condition occurrence: filter#1 on<p></p>
PDebugInst[7:0] != 0 and PDebugLS< 0/1 >Stat[3:0] is either<p></p>
LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is<p></p>
specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]];<p></p>
filter#3 on Trace bus PDebugLS< 0/1 >Addr[27:0] is specified by<p></p>
range register [LS< 0/1 >_LO[i][27:0], LS< 0/1 >_HI[i][27:0]].<p></p>
Counter[i] increments by 1 when all 3 filters conditions are<p></p>
met. Counter[i] will be capped on the value specified by<p></p>
register LSCNTSAT.cntsat, if counter[i] hits this value, an<p></p>
interrupt will be issued if it is not masked. Counter[i] will<p></p>
be cleared when register LSCNTCLR.ls< 0/1 >_cnt< i >_clr is<p></p>
asserted or register LSCNTEN.ls< 0/1 >_cnt< i >_en is de-asserted,<p></p>
i is 0~7, each LS< 0/1 > has 8 counters.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit05_PC_LO</a></p>
</td>
<td><p>32'h000000FC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter<p></p>
the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates<p></p>
the Hifi core internal Program Counter value associated with the<p></p>
instruction completed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit05_PC_HI</a></p>
</td>
<td><p>32'h00000100</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter<p></p>
the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0]<p></p>
indicates the Hifi core internal Program Counter associated<p></p>
with the instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit05_LS_LO</a></p>
</td>
<td><p>32'h00000104</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store low threshold (LS_LO) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit05_LS_HI</a></p>
</td>
<td><p>32'h00000108</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store high threshold (LS_HI) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit05_LS_CNT</a></p>
</td>
<td><p>32'h0000010C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>used to count three filtered condition occurrence: filter#1 on<p></p>
PDebugInst[7:0] != 0 and PDebugLS< 0/1 >Stat[3:0] is either<p></p>
LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is<p></p>
specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]];<p></p>
filter#3 on Trace bus PDebugLS< 0/1 >Addr[27:0] is specified by<p></p>
range register [LS< 0/1 >_LO[i][27:0], LS< 0/1 >_HI[i][27:0]].<p></p>
Counter[i] increments by 1 when all 3 filters conditions are<p></p>
met. Counter[i] will be capped on the value specified by<p></p>
register LSCNTSAT.cntsat, if counter[i] hits this value, an<p></p>
interrupt will be issued if it is not masked. Counter[i] will<p></p>
be cleared when register LSCNTCLR.ls< 0/1 >_cnt< i >_clr is<p></p>
asserted or register LSCNTEN.ls< 0/1 >_cnt< i >_en is de-asserted,<p></p>
i is 0~7, each LS< 0/1 > has 8 counters.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit06_PC_LO</a></p>
</td>
<td><p>32'h00000110</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter<p></p>
the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates<p></p>
the Hifi core internal Program Counter value associated with the<p></p>
instruction completed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit06_PC_HI</a></p>
</td>
<td><p>32'h00000114</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter<p></p>
the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0]<p></p>
indicates the Hifi core internal Program Counter associated<p></p>
with the instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit06_LS_LO</a></p>
</td>
<td><p>32'h00000118</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store low threshold (LS_LO) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit06_LS_HI</a></p>
</td>
<td><p>32'h0000011C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store high threshold (LS_HI) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit06_LS_CNT</a></p>
</td>
<td><p>32'h00000120</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>used to count three filtered condition occurrence: filter#1 on<p></p>
PDebugInst[7:0] != 0 and PDebugLS< 0/1 >Stat[3:0] is either<p></p>
LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is<p></p>
specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]];<p></p>
filter#3 on Trace bus PDebugLS< 0/1 >Addr[27:0] is specified by<p></p>
range register [LS< 0/1 >_LO[i][27:0], LS< 0/1 >_HI[i][27:0]].<p></p>
Counter[i] increments by 1 when all 3 filters conditions are<p></p>
met. Counter[i] will be capped on the value specified by<p></p>
register LSCNTSAT.cntsat, if counter[i] hits this value, an<p></p>
interrupt will be issued if it is not masked. Counter[i] will<p></p>
be cleared when register LSCNTCLR.ls< 0/1 >_cnt< i >_clr is<p></p>
asserted or register LSCNTEN.ls< 0/1 >_cnt< i >_en is de-asserted,<p></p>
i is 0~7, each LS< 0/1 > has 8 counters.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO">hifi1_wrapper_unit07_PC_LO</a></p>
</td>
<td><p>32'h00000124</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_LO_pc_low">pc_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) low threshold (PC_LO) is used to filter<p></p>
the value on Trace bus PDebugPC[27:0], PDebugPC[27:0] indicates<p></p>
the Hifi core internal Program Counter value associated with the<p></p>
instruction completed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI">hifi1_wrapper_unit07_PC_HI</a></p>
</td>
<td><p>32'h00000128</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_PC_HI_pc_high">pc_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Program Counter (PC) high threshold (PC_HI) is used to filter<p></p>
the value on Tracee bus PDebugPC[27:0], PDebugPC[27:0]<p></p>
indicates the Hifi core internal Program Counter associated<p></p>
with the instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO">hifi1_wrapper_unit07_LS_LO</a></p>
</td>
<td><p>32'h0000012C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_LO_ls_low">ls_low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store low threshold (LS_LO) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI">hifi1_wrapper_unit07_LS_HI</a></p>
</td>
<td><p>32'h00000130</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[27:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_HI_ls_high">ls_high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Load/Store high threshold (LS_HI) is used to filter the value<p></p>
on Tracee bus PDebugLS< 0/1 >Addr[27:0], PDebugLS< 0/1 >Addr[27:0]<p></p>
indicates the virtual memory address used in a load/store unit<p></p>
< 0/1 > instruction processed in the W (Writeback) stage.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT">hifi1_wrapper_unit07_LS_CNT</a></p>
</td>
<td><p>32'h00000134</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#LSPORT_LS_CNT_counter">counter</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>used to count three filtered condition occurrence: filter#1 on<p></p>
PDebugInst[7:0] != 0 and PDebugLS< 0/1 >Stat[3:0] is either<p></p>
LD(0x5) or ST(0x6);l filter#2 on Trace bus PDebugPC[27:0] is<p></p>
specified by range register [PC_LO[i][27:0], PC_HI[i][27:0]];<p></p>
filter#3 on Trace bus PDebugLS< 0/1 >Addr[27:0] is specified by<p></p>
range register [LS< 0/1 >_LO[i][27:0], LS< 0/1 >_HI[i][27:0]].<p></p>
Counter[i] increments by 1 when all 3 filters conditions are<p></p>
met. Counter[i] will be capped on the value specified by<p></p>
register LSCNTSAT.cntsat, if counter[i] hits this value, an<p></p>
interrupt will be issued if it is not masked. Counter[i] will<p></p>
be cleared when register LSCNTCLR.ls< 0/1 >_cnt< i >_clr is<p></p>
asserted or register LSCNTEN.ls< 0/1 >_cnt< i >_en is de-asserted,<p></p>
i is 0~7, each LS< 0/1 > has 8 counters.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN">hifi1_wrapper_LSCNTEN</a></p>
</td>
<td><p>32'h00000138</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt0_en">ls0_cnt0_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter#0 enable bit in LS unit#0</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt1_en">ls0_cnt1_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter#1 enable bit in LS unit#0</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt2_en">ls0_cnt2_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter#2 enable bit in LS unit#0</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt3_en">ls0_cnt3_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter#3 enable bit in LS unit#0</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt4_en">ls0_cnt4_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter#4 enable bit in LS unit#0</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt5_en">ls0_cnt5_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter#5 enable bit in LS unit#0</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt6_en">ls0_cnt6_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter#6 enable bit in LS unit#0</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTEN_ls0_cnt7_en">ls0_cnt7_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter#7 enable bit in LS unit#0</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR">hifi1_wrapper_LSCNTCLR</a></p>
</td>
<td><p>32'h0000013C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt0_clr">ls0_cnt0_clr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>LS unit#0 Counter#0 value will be cleared once this bit is<p></p>
asserted, bit is de-asserted automatically by HW after SW<p></p>
assertion.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt1_clr">ls0_cnt1_clr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>LS unit#0 Counter#1 value will be cleared once this bit is<p></p>
asserted, bit is de-asserted automatically by HW after SW<p></p>
assertion.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt2_clr">ls0_cnt2_clr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>LS unit#0 Counter#2 value will be cleared once this bit is<p></p>
asserted, bit is de-asserted automatically by HW after SW<p></p>
assertion.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt3_clr">ls0_cnt3_clr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>LS unit#0 Counter#3 value will be cleared once this bit is<p></p>
asserted, bit is de-asserted automatically by HW after SW<p></p>
assertion.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt4_clr">ls0_cnt4_clr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>LS unit#0 Counter#4 value will be cleared once this bit is<p></p>
asserted, bit is de-asserted automatically by HW after SW<p></p>
assertion.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt5_clr">ls0_cnt5_clr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>LS unit#0 Counter#5 value will be cleared once this bit is<p></p>
asserted, bit is de-asserted automatically by HW after SW<p></p>
assertion.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt6_clr">ls0_cnt6_clr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>LS unit#0 Counter#6 value will be cleared once this bit is<p></p>
asserted, bit is de-asserted automatically by HW after SW<p></p>
assertion.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTCLR_ls0_cnt7_clr">ls0_cnt7_clr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>LS unit#0 Counter#7 value will be cleared once this bit is<p></p>
asserted, bit is de-asserted automatically by HW after SW<p></p>
assertion.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTSAT">hifi1_wrapper_LSCNTSAT</a></p>
</td>
<td><p>32'h00000140</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSCNTSAT_cntsat">cntsat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Each counter in LS0 will be capped to cntsat, when it happens,<p></p>
an interrupt will be sent if it is not masked.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_">hifi1_wrapper_mem</a></p>
</td>
<td><p>32'h00000400</p>
</td>
<td><p>Trace buffer (128 x 64b), used to do PDebug* data logging based<p></p>
on predefined event occurring, only PDebugInst[7:0] != 0 &&<p></p>
(PDebugLS0Stat[3:0] == (LD or ST)) is considered as a valid<p></p>
event, not all valid events are recorded into trace buffer,<p></p>
only one of every (LSWCTRL.sample_cycle_cnt+1) continuous valid<p></p>
events will be logged into trace buffer (event decimation), the<p></p>
number of total logged event is also limited by LSWCTRL.wlimit,<p></p>
once trace buffer accumulated (LSWCTRL.wlimit+1) entries,<p></p>
Ctrl.en_xt_trace will be cleared by HW automatically and an<p></p>
interrupt will be triggered in the same time.<p></p>
Internal memory</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p>Memory</p>
</td>
<td><p><p></p>
</p>
</td>
<td><p>Memory</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSWCTRL">hifi1_wrapper_LSWCTRL</a></p>
</td>
<td><p>32'h00000800</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[6:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSWCTRL_wlimit">wlimit</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Used to limit the number of Trace buffer entries (real number is<p></p>
LSWCTRL.wlimit+1) can be used to log PDebug* data,<p></p>
LSWCTRL.wlimit is the maximum address can be hit before<p></p>
Ctrl.en_xt_trace is turn off by HW.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSWCTRL_reserved_b7">reserved_b7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[27:8]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_LSWCTRL_sample_cycle_cnt">sample_cycle_cnt</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Used to control the skip number of LS valid event before a trace<p></p>
buffer event write, in HW it controls the rollover of LS valid<p></p>
event occurring sample counter, whenever the sample counter<p></p>
reaches the value of sample_cycle_cnt, the sample counter rolls<p></p>
back to 0, in the meantime a pulse is generated as trace buffer<p></p>
write enable, and same pulse is used to increase trace buffer<p></p>
write address pointer WRPTR by 1 if it doesn’t hit the maximum<p></p>
address specified by wlimit. The minimum number of<p></p>
sample_cycle_cnt is 0, 0 means no LS valid event skipping.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_TBWRPTR">hifi1_wrapper_TBWRPTR</a></p>
</td>
<td><p>32'h00000804</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[6:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_TBWRPTR_wr_pointer">wr_pointer</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p>Reflect real value of HW trace buffer write pointer, incremental<p></p>
by decimated predefined valid event occurring, cleared once<p></p>
write pointer reaches LSWCTRL.wlimit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA">hifi1_wrapper_INTR_STA</a></p>
</td>
<td><p>32'h00000808</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt0_sat">ls0cnt0_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when LS unit#0 counter#0 is saturated, write “1” to<p></p>
clear this bit</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt1_sat">ls0cnt1_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when LS unit#0 counter#1 is saturated, write “1” to<p></p>
clear this bit</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt2_sat">ls0cnt2_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when LS unit#0 counter#2 is saturated, write “1” to<p></p>
clear this bit</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt3_sat">ls0cnt3_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when LS unit#0 counter#3 is saturated, write “1” to<p></p>
clear this bit</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt4_sat">ls0cnt4_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when LS unit#0 counter#4 is saturated, write “1” to<p></p>
clear this bit</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt5_sat">ls0cnt5_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when LS unit#0 counter#5 is saturated, write “1” to<p></p>
clear this bit</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt6_sat">ls0cnt6_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when LS unit#0 counter#6 is saturated, write “1” to<p></p>
clear this bit</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_ls0cnt7_sat">ls0cnt7_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when LS unit#0 counter#7 is saturated, write “1” to<p></p>
clear this bit</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_STA_tb_wrptr_sat">tb_wrptr_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when Trace Buffer write pointer is saturated, write “1”<p></p>
to clear this bit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK">hifi1_wrapper_INTR_MASK</a></p>
</td>
<td><p>32'h0000080C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt0_sat">ls0cnt0_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.ls0cnt0_sat, when it is set, Hifi1_wrap<p></p>
final interrupt will ignore the status of INTR_STA.ls0cnt0_sat</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt1_sat">ls0cnt1_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.ls0cnt1_sat, when it is set, Hifi1_wrap<p></p>
final interrupt will ignore the status of INTR_STA.ls0cnt1_sat</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt2_sat">ls0cnt2_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.ls0cnt2_sat, when it is set, Hifi1_wrap<p></p>
final interrupt will ignore the status of INTR_STA.ls0cnt2_sat</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt3_sat">ls0cnt3_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.ls0cnt3_sat, when it is set, Hifi1_wrap<p></p>
final interrupt will ignore the status of INTR_STA.ls0cnt3_sat</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt4_sat">ls0cnt4_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.ls0cnt4_sat, when it is set, Hifi1_wrap<p></p>
final interrupt will ignore the status of INTR_STA.ls0cnt4_sat</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt5_sat">ls0cnt5_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.ls0cnt5_sat, when it is set, Hifi1_wrap<p></p>
final interrupt will ignore the status of INTR_STA.ls0cnt5_sat</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt6_sat">ls0cnt6_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.ls0cnt6_sat, when it is set, Hifi1_wrap<p></p>
final interrupt will ignore the status of INTR_STA.ls0cnt6_sat</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_ls0cnt7_sat">ls0cnt7_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.ls0cnt7_sat, when it is set, Hifi1_wrap<p></p>
final interrupt will ignore the status of INTR_STA.ls0cnt7_sat</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="indus_hifi1_wrap.htm#hifi1_wrapper_INTR_MASK_tb_wrptr_sat">tb_wrptr_sat</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.tb_wrptr_sat, when it is set, Hifi1_wrap<p></p>
final interrupt will ignore the status of INTR_STA.tb_wrptr_sat</p>
</td>
</tr>
</table><p><p></p>
</p>
</body></html>