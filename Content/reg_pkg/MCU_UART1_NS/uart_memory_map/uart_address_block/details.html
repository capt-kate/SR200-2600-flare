<?xml version="1.0" encoding="utf-8"?><html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd"><head><title>Register Details</title></head>
<body>
<h1><a name="idp44644216"></a>Register Details</h1>
<h2><a name="H3-sect1-reg-uart_memory_map_uart_address_block"></a>uart_address_block Register Details</h2>
<p><a name="H4-reg-uart_memory_map_uart_address_block_RBR"></a>RBR</p>
<ul><li>Name:Receive Buffer Register</li><li>Description:Receive Buffer Register.<p class="BLANK"></p>
This register can be accessed only when the DLAB bit (LCR[7]) is cleared.</li><li>Size:32 bits</li><li>Offset:0x0</li></ul><a name="fld-uart_memory_map_uart_address_block_RBR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_RBR_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_RBR_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_RBR</td>
<td>RBR</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_RBR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: RBR</p>
<table summary="Fields for Register: RBR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_RBR_F_31_8"></a>31:8</p>
</td>
<td>RSVD_RBR</td>
<td>R</td>
<td><p>RBR 31to9or8 Reserved bits and read as zero (0).</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_RBR_F_7_0"></a>7:0</p>
</td>
<td>RBR</td>
<td>R</td>
<td><p>Receive Buffer Register.</p>
<p class="BLANK"></p>
<p>This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set.</p>
<p class="BLANK"></p>
<p>If in non-FIFO mode (FIFO_MODE == NONE) or FIFOs are disabled (FCR[0] set to 0), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an over-run error.</p>
<p class="BLANK"></p>
<p>If in FIFO mode (FIFO_MODE != NONE) and FIFOs are enabled (FCR[0] set to 1), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost and an over-run error occurs.</p>
<p class="BLANK"></p>
<p>Note:</p>
<ul><li>When UART_9BIT_DATA_EN="0," this field width is 8.</li><li>When UART_9BIT_DATA_EN="1," this field width is 9.</li></ul><p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_THR"></a>THR</p>
<ul><li>Name:Transmit Holding Register</li><li>Description:Transmit Holding Register.<p class="BLANK"></p>
This register can be accessed only when the DLAB bit (LCR[7]) is cleared.</li><li>Size:32 bits</li><li>Offset:0x0</li></ul><a name="fld-uart_memory_map_uart_address_block_THR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_THR_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_THR_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_THR</td>
<td>THR</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_THR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: THR</p>
<table summary="Fields for Register: THR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_THR_F_31_8"></a>31:8</p>
</td>
<td>RSVD_THR</td>
<td>R</td>
<td><p>THR 31to9or8 Reserved bits and read as zero (0).</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_THR_F_7_0"></a>7:0</p>
</td>
<td>THR</td>
<td>W</td>
<td><p>Transmit Holding Register.</p>
<p class="BLANK"></p>
<p>This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set.</p>
<p class="BLANK"></p>
<p>If in non-FIFO mode or FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten.</p>
<p class="BLANK"></p>
<p>If in FIFO mode and FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that is set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost.</p>
<p class="BLANK"></p>
<p>Note:</p>
<p class="BLANK"></p>
<p>1. When UART_9BIT_DATA_EN="0," this field width is 8.</p>
<p class="BLANK"></p>
<p>2. When UART_9BIT_DATA_EN="1," this field width is 9. The 9th bit is applicable only when LCR_EXT[3]=1.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_DLL"></a>DLL</p>
<ul><li>Name:Divisor Latch (Low)</li><li>Description:Divisor Latch (Low).<p class="BLANK"></p>
If UART_16550_COMPATIBLE = No, then this register can be accessed only when the DLAB bit (LCR[7]) is set and the UART is not busy - that is, USR[0] is 0; otherwise this register can be accessed only when the DLAB bit (LCR[7]) is set.</li><li>Size:32 bits</li><li>Offset:0x0</li></ul><a name="fld-uart_memory_map_uart_address_block_DLL"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DLL_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DLL_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_DLL_31to8</td>
<td>DLL</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_DLL"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: DLL</p>
<table summary="Fields for Register: DLL" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DLL_F_31_8"></a>31:8</p>
</td>
<td>RSVD_DLL_31to8</td>
<td>R</td>
<td><p>DLL 31to8 Reserved bits and read as zero (0).</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DLL_F_7_0"></a>7:0</p>
</td>
<td>DLL</td>
<td>R/W</td>
<td><p>Divisor Latch (Low).</p>
<p class="BLANK"></p>
<p>This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART.</p>
<p class="BLANK"></p>
<p>The output baud rate is equal to the serial clock (pclk if one clock design, sclk if two clock design (CLOCK_MODE == Enabled)) frequency divided by sixteen times the value of the baud rate divisor, as follows: baud rate = (serial clock freq) / (16 * divisor).</p>
<p class="BLANK"></p>
<p>Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the DLL is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_IER"></a>IER</p>
<ul><li>Name:Interrupt Enable Register</li><li>Description:Interrupt Enable Register.<p class="BLANK"></p>
This register can be accessed only when the DLAB bit (LCR[7]) is cleared.</li><li>Size:32 bits</li><li>Offset:0x4</li></ul><a name="fld-uart_memory_map_uart_address_block_IER"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_IER_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_IER_F_7">7</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_IER_F_6_5">6:5</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_IER_F_4">4</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_IER_F_3">3</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_IER_F_2">2</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_IER_F_1">1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_IER_F_0">0</a></td>
</tr>
<tr><td>RSVD_IER_31to8</td>
<td>PTIME</td>
<td>RSVD_IER_6to5</td>
<td>ELCOLR</td>
<td>EDSSI</td>
<td>ELSI</td>
<td>ETBEI</td>
<td>ERBFI</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_IER"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: IER</p>
<table summary="Fields for Register: IER" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_IER_F_31_8"></a>31:8</p>
</td>
<td>RSVD_IER_31to8</td>
<td>R</td>
<td><p>IER 31to8 Reserved bits and read as zero (0).</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_IER_F_7"></a>7</p>
</td>
<td>PTIME</td>
<td>R/W</td>
<td><p>Programmable THRE Interrupt Mode Enable.Writeable only when THRE_MODE_USER == Enabled, always readable. This is used to enable/disable the generation of THRE Interrupt.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Disable Programmable THRE Interrupt Mode</li><li>0x1 (ENABLED): Enable Programmable THRE Interrupt Mode</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_IER_F_6_5"></a>6:5</p>
</td>
<td>RSVD_IER_6to5</td>
<td>R</td>
<td><p>IER 6to5 Reserved bits read as zero (0).</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_IER_F_4"></a>4</p>
</td>
<td>ELCOLR</td>
<td>R</td>
<td><p>Interrupt Enable Register: ELCOLR, this bit controls the method for clearing the status in the LSR register.
This is applicable only for Overrun Error, Parity Error, Framing Error, and Break Interrupt status bits.</p>
<ul><li>0: LSR status bits are cleared either on reading Rx FIFO (RBR Read) or On reading LSR register.</li><li>1: LSR status bits are cleared only on reading LSR register.</li></ul><p>Writeable only when LSR_STATUS_CLEAR = 1, otherwise always readable.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Disable ALC</li><li>0x1 (ENABLED): Enable ALC</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_IER_F_3"></a>3</p>
</td>
<td>EDSSI</td>
<td>R/W</td>
<td><p>Enable Modem Status Interrupt.This is used to enable/disable the generation of Modem Status Interrupt. This is the fourth highest priority interrupt.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Disable Modem Status Interrupt</li><li>0x1 (ENABLED): Enable Modem Status Interrupt</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_IER_F_2"></a>2</p>
</td>
<td>ELSI</td>
<td>R/W</td>
<td><p>Enable Receiver Line Status Interrupt.This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Disable Receiver Line Status Interrupt</li><li>0x1 (ENABLED): Enable Receiver Line Status Interrupt</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_IER_F_1"></a>1</p>
</td>
<td>ETBEI</td>
<td>R/W</td>
<td><p>Enable Transmit Holding Register Empty Interrupt.This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Disable Transmit empty interrupt</li><li>0x1 (ENABLED): Enable Transmit empty interrupt</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_IER_F_0"></a>0</p>
</td>
<td>ERBFI</td>
<td>R/W</td>
<td><p>Enable Received Data Available Interrupt.This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Disable Receive data Interrupt</li><li>0x1 (ENABLED): Enable Receive data Interrupt</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_DLH"></a>DLH</p>
<ul><li>Name:Divisor Latch High</li><li>Description:Divisor Latch High (DLH) Register.<p class="BLANK"></p>
If UART_16550_COMPATIBLE = No, then this register can be accessed only when the DLAB bit (LCR[7]) is set and the UART is not busy, that is, USR[0] is 0; otherwise this register can be accessed only when the DLAB bit (LCR[7]) is set.</li><li>Size:32 bits</li><li>Offset:0x4</li></ul><a name="fld-uart_memory_map_uart_address_block_DLH"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DLH_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DLH_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_DLH</td>
<td>dlh</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_DLH"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: DLH</p>
<table summary="Fields for Register: DLH" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DLH_F_31_8"></a>31:8</p>
</td>
<td>RSVD_DLH</td>
<td>R</td>
<td><p>DLH 31to8 Reserved bits and read as zero (0).</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DLH_F_7_0"></a>7:0</p>
</td>
<td>dlh</td>
<td>R/W</td>
<td><p>Upper 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART.</p>
<p class="BLANK"></p>
<p>The output baud rate is equal to the serial clock (pclk if one clock design, sclk if two clock design (CLOCK_MODE == Enabled)) frequency divided by sixteen times the value of the baud rate divisor, as follows: baud rate = (serial clock freq) / (16 * divisor).</p>
<p class="BLANK"></p>
<p>Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the DLH is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_IIR"></a>IIR</p>
<ul><li>Name:Interrupt Identification Register</li><li>Description:Interrupt Identification Register</li><li>Size:32 bits</li><li>Offset:0x8</li></ul><a name="fld-uart_memory_map_uart_address_block_IIR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_IIR_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_IIR_F_7_6">7:6</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_IIR_F_5_4">5:4</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_IIR_F_3_0">3:0</a></td>
</tr>
<tr><td>RSVD_IIR_31to8</td>
<td>FIFOSE</td>
<td>RSVD_IIR_5to4</td>
<td>IID</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_IIR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: IIR</p>
<table summary="Fields for Register: IIR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_IIR_F_31_8"></a>31:8</p>
</td>
<td>RSVD_IIR_31to8</td>
<td>R</td>
<td><p>IIR 31to8 Reserved bits and read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_IIR_F_7_6"></a>7:6</p>
</td>
<td>FIFOSE</td>
<td>R</td>
<td><p>FIFOs Enabled.This is used to indicate whether the FIFOs are enabled or disabled.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): FIFOs are disabled</li><li>0x3 (ENABLED): FIFOs are enabled</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_IIR_F_5_4"></a>5:4</p>
</td>
<td>RSVD_IIR_5to4</td>
<td>R</td>
<td><p>IIR 5to4 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_IIR_F_3_0"></a>3:0</p>
</td>
<td>IID</td>
<td>R</td>
<td><p>Interrupt ID (or IID).This indicates the highest priority pending interrupt which can be one of the following types specified inValues. For information on several levels into which the interrupt priorities are split into, see the 'Interrupts' section in the DW_apb_uart Databook.</p>
<p class="BLANK"></p>
<p>Note:An interrupt of type 0111 (busy detect) will never get indicated if UART_16550_COMPATIBLE == YES in coreConsultant.</p>
<p class="BLANK"></p>
<p>Bit 3 indicates an interrupt can only occur when the FIFOs are enabled and used to distinguish a Character Timeout condition interrupt.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (MODEM_STATUS): modem status</li><li>0x1 (NO_INTERRUPT_PENDING): no interrupt pending</li><li>0x2 (THR_EMPTY): THR empty</li><li>0x4 (RECEIVED_DATA_AVAILABLE): received data available</li><li>0x6 (RECEIVER_LINE_STATUS): receiver line status</li><li>0x7 (BUSY_DETECT): busy detect</li><li>0xc (CHARACTER_TIMEOUT): character timeout</li></ul><p></p>
<p>Value After Reset:0x1</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_FCR"></a>FCR</p>
<ul><li>Name:FIFO Control Register</li><li>Description:This register is only valid when the DW_apb_uart is configured to have FIFO's implemented (FIFO_MODE != NONE). If FIFO's are not implemented, this register does not exist and writing to this register address will have no effect.</li><li>Size:32 bits</li><li>Offset:0x8</li></ul><a name="fld-uart_memory_map_uart_address_block_FCR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_FCR_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_FCR_F_7_6">7:6</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_FCR_F_5_4">5:4</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_FCR_F_3">3</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_FCR_F_2">2</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_FCR_F_1">1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_FCR_F_0">0</a></td>
</tr>
<tr><td>RSVD_FCR_31to8</td>
<td>RT</td>
<td>TET</td>
<td>DMAM</td>
<td>XFIFOR</td>
<td>RFIFOR</td>
<td>FIFOE</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_FCR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: FCR</p>
<table summary="Fields for Register: FCR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_FCR_F_31_8"></a>31:8</p>
</td>
<td>RSVD_FCR_31to8</td>
<td>R</td>
<td><p>FCR 31to8 Reserved bits and read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_FCR_F_7_6"></a>7:6</p>
</td>
<td>RT</td>
<td>W</td>
<td><p>RCVR Trigger (or RT).This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode, it is used to determine when the rts_n signal will be de-asserted only when RTC_FCT is disabled. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. For details on DMA support, refer to 'DMA Support' section of data book.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (FIFO_CHAR_1): 1 character in FIFO</li><li>0x1 (FIFO_QUARTER_FULL): FIFO 1/4 full</li><li>0x2 (FIFO_HALF_FULL): FIFO 1/2 full</li><li>0x3 (FIFO_FULL_2): FIFO 2 less than full</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_FCR_F_5_4"></a>5:4</p>
</td>
<td>TET</td>
<td>W</td>
<td><p>TX Empty Trigger (or TET).Writes will have no effect when THRE_MODE_USER == Disabled. This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. For details on DMA support, refer to 'DMA Support' section of data book.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (FIFO_EMPTY): FIFO Empty</li><li>0x1 (FIFO_CHAR_2): 2 characters in FIFO</li><li>0x2 (FIFO_QUARTER_FULL): FIFO 1/4 full</li><li>0x3 (FIFO_HALF_FULL): FIFO 1/2 full</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_FCR_F_3"></a>3</p>
</td>
<td>DMAM</td>
<td>W</td>
<td><p>DMA Mode (or DMAM).This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals when additional DMA handshaking signals are not selected (DMA_EXTRA == NO). For details on DMA support, refer to 'DMA Support' section of data book.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (MODE0): Mode 0</li><li>0x1 (MODE1): Mode 1</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_FCR_F_2"></a>2</p>
</td>
<td>XFIFOR</td>
<td>W</td>
<td><p>XMIT FIFO Reset (or XFIFOR).This resets the control portion of the transmit FIFO and treats the FIFO as empty. This will also de-assert the DMA TX request and single signals when additional DMA handshaking signals are selected (DMA_EXTRA == YES). Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x1 (RESET): Transmit FIFO reset</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_FCR_F_1"></a>1</p>
</td>
<td>RFIFOR</td>
<td>W</td>
<td><p>RCVR FIFO Reset (or RFIFOR).This resets the control portion of the receive FIFO and treats the FIFO as empty. This will also de-assert the DMA RX request and single signals when additional DMA handshaking signals are selected (DMA_EXTRA == YES). Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x1 (RESET): Receive FIFO reset</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_FCR_F_0"></a>0</p>
</td>
<td>FIFOE</td>
<td>W</td>
<td><p>FIFO Enable (or FIFOE).This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFOs is reset.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): FIFO disabled</li><li>0x1 (ENABLED): FIFO enabled</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR"></a>LCR</p>
<ul><li>Name:Line Control Register</li><li>Description:Line Control Register</li><li>Size:32 bits</li><li>Offset:0xc</li></ul><a name="fld-uart_memory_map_uart_address_block_LCR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_F_7">7</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_F_6">6</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_F_5">5</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_F_4">4</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_F_3">3</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_F_2">2</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_F_1_0">1:0</a></td>
</tr>
<tr><td>RSVD_LCR_31to8</td>
<td>DLAB</td>
<td>BC</td>
<td>SP</td>
<td>EPS</td>
<td>PEN</td>
<td>STOP</td>
<td>DLS</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_LCR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: LCR</p>
<table summary="Fields for Register: LCR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_F_31_8"></a>31:8</p>
</td>
<td>RSVD_LCR_31to8</td>
<td>R</td>
<td><p>LCR 31to8 Reserved bits and read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_F_7"></a>7</p>
</td>
<td>DLAB</td>
<td>R/W</td>
<td><p>Divisor Latch Access Bit.</p>
<p class="BLANK"></p>
<p>If UART_16550_COMPATIBLE == NO then, writeable only when UART is not busy (USR[0]
is zero), otherwise always writable and always readable. This bit is used to enable
reading and writing of the Divisor Latch register (DLL and DLH/LPDLL and LPDLH) to set the baud
rate of the UART. This bit must be cleared after initial baud rate setup in order
to access other registers.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Divisor Latch register is writable only when UART Not BUSY</li><li>0x1 (ENABLED): Divisor Latch register is always readable and writable</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_F_6"></a>6</p>
</td>
<td>BC</td>
<td>R/W</td>
<td><p>Break Control Bit.</p>
<p class="BLANK"></p>
<p>This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When
not in Loopback Mode, as determined by MCR[4], the sout line is forced low until
the Break bit is cleared. If SIR_MODE == Enabled and active (MCR[6] set to one)
the sir_out_n line is continuously pulsed. When in Loopback Mode, the break
condition is internally looped back to the receiver and the sir_out_n line is
forced low.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Serial output is released for data transmission</li><li>0x1 (ENABLED): Serial output is forced to spacing state</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_F_5"></a>5</p>
</td>
<td>SP</td>
<td>R/W</td>
<td><p>Stick Parity.</p>
<p class="BLANK"></p>
<p>If UART_16550_COMPATIBLE = NO, then writeable only when UART is
not busy (USR[0] is 0); otherwise always writable and always readable. This bit is used
to force parity value. When PEN, EPS and Stick Parity are set to 1, the parity bit is
transmitted and checked as logic 0. If PEN and Stick Parity are set to 1 and EPS is a
logic 0, then parity bit is transmitted and checked as a logic 1. If this bit is set to 0,
Stick Parity is disabled.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Stick parity disabled</li><li>0x1 (ENABLED): Stick parity enabled</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_F_4"></a>4</p>
</td>
<td>EPS</td>
<td>R/W</td>
<td><p>Even Parity Select.</p>
<p class="BLANK"></p>
<p>If UART_16550_COMPATIBLE == NO then, writeable only when UART is not busy (USR[0]
is zero), otherwise always writable and always readable. This is used to select
between even and odd parity, when parity is enabled (PEN set to one). If set to
one, an even number of logic '1's is transmitted or checked. If set to zero, an
odd number of logic '1's is transmitted or checked.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (ODD_PARITY): an odd parity is transmitted or checked</li><li>0x1 (EVEN_PARITY): an even parity is transmitted or checked</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_F_3"></a>3</p>
</td>
<td>PEN</td>
<td>R/W</td>
<td><p>Parity Enable.</p>
<p class="BLANK"></p>
<p>If UART_16550_COMPATIBLE == NO then, writeable only when UART is not busy (USR[0]
is zero), otherwise always writable and always readable. This bit is used to enable
and disable parity generation and detection in transmitted and received serial
character respectively.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): disable parity</li><li>0x1 (ENABLED): enable parity</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_F_2"></a>2</p>
</td>
<td>STOP</td>
<td>R/W</td>
<td><p>Number of stop bits.</p>
<p class="BLANK"></p>
<p>If UART_16550_COMPATIBLE == NO then, writeable only when UART is not busy (USR[0]
is zero), otherwise always writable and always readable. This is used to select the number
of stop bits per character that the peripheral will transmit and receive. If set to
zero, one stop bit is transmitted in the serial data.</p>
<p class="BLANK"></p>
<p>If set to one and the data
bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted.
Otherwise, two stop bits are transmitted.
Note that regardless of the number of stop bits selected the receiver will only
check the first stop bit.</p>
<p class="BLANK"></p>
<p>Note:The STOP bit duration implemented by DW_apb_uart may appear longer
due to idle time inserted between characters for some configurations and baud
clock divisor values in the transmit direction; for details on idle time between
transmitted transfers, refer to 'Back-to-Back Character Stream Transmission' section in data book.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (STOP_1BIT): 1 stop bit</li><li>0x1 (STOP_1_5BIT_OR_2BIT): 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_F_1_0"></a>1:0</p>
</td>
<td>DLS</td>
<td>R/W</td>
<td><p>Data Length Select (or CLS as used in legacy).</p>
<p class="BLANK"></p>
<p>If UART_16550_COMPATIBLE == NO then, writeable only when UART is not busy (USR[0] is zero), otherwise always writable and always readable. When DLS_E in LCR_EXT is set to 0, this register is used to select the number of data bits per character that the peripheral will transmit and receive.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (CHAR_5BITS): 5 data bits per character</li><li>0x1 (CHAR_6BITS): 6 data bits per character</li><li>0x2 (CHAR_7BITS): 7 data bits per character</li><li>0x3 (CHAR_8BITS): 8 data bits per character</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_MCR"></a>MCR</p>
<ul><li>Name:Modem Control Register</li><li>Description:Modem Control Register</li><li>Size:32 bits</li><li>Offset:0x10</li></ul><a name="fld-uart_memory_map_uart_address_block_MCR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MCR_F_31_7">31:7</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MCR_F_6">6</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MCR_F_5">5</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MCR_F_4">4</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MCR_F_3">3</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MCR_F_2">2</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MCR_F_1">1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MCR_F_0">0</a></td>
</tr>
<tr><td>RSVD_MCR_31to7</td>
<td>SIRE</td>
<td>AFCE</td>
<td>LoopBack</td>
<td>OUT2</td>
<td>OUT1</td>
<td>RTS</td>
<td>DTR</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_MCR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: MCR</p>
<table summary="Fields for Register: MCR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MCR_F_31_7"></a>31:7</p>
</td>
<td>RSVD_MCR_31to7</td>
<td>R</td>
<td><p>MCR 31to7 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MCR_F_6"></a>6</p>
</td>
<td>SIRE</td>
<td>R</td>
<td><p>SIR Mode Enable</p>
<p class="BLANK"></p>
<p>Writeable only when SIR_MODE == Enabled, always readable. This is used to enable/
disable the IrDA SIR Mode features as described in section 'IrDA 1.0 SIR Protocol' in the databook.</p>
<p class="BLANK"></p>
<p>Note:To enable SIR mode, write the appropriate value to the MCR register before writing to the LCR register.
For details of the recommended programming sequence, refer to 'Programing Examples' section of data book.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): IrDA SIR Mode disabled</li><li>0x1 (ENABLED): IrDA SIR Mode enabled</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MCR_F_5"></a>5</p>
</td>
<td>AFCE</td>
<td>R/W</td>
<td><p>Auto Flow Control Enable</p>
<p class="BLANK"></p>
<p>Writeable only when AFCE_MODE == Enabled, always readable. When FIFOs are enabled
and the Auto Flow Control Enable (AFCE) bit is set, Auto Flow Control features are
enabled as described in section 'Auto Flow Control' in data book.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Auto Flow Control Mode disabled</li><li>0x1 (ENABLED): Auto Flow Control Mode enabled</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MCR_F_4"></a>4</p>
</td>
<td>LoopBack</td>
<td>R/W</td>
<td><p>LoopBack Bit</p>
<p class="BLANK"></p>
<p>This is used to put the UART into a diagnostic mode for test purposes.
If operating in UART mode (SIR_MODE != Enabled OR NOT active, MCR[6] set to zero),
data on the sout line is held high, while serial data output is looped back to the
sin line, internally. In this mode all the interrupts are fully functional. Also,
in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are
disconnected and the modem control outputs (dtr_n, rts_n, out1_n, out2_n) are looped
back to the inputs, internally.</p>
<p class="BLANK"></p>
<p>If operating in infrared mode (SIR_MODE == Enabled AND active, MCR[6] set to one),
data on the sir_out_n line is held low, while serial data output is inverted and
looped back to the sir_in line.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Loopback mode disabled</li><li>0x1 (ENABLED): Loopback mode enabled</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MCR_F_3"></a>3</p>
</td>
<td>OUT2</td>
<td>R/W</td>
<td><p>OUT2</p>
<p class="BLANK"></p>
<p>This is used to directly control the user-designated Output2 (out2_n) output. The
value written to this location is inverted and driven out on out2_n.
Note that in Loopback mode (MCR[4] set to one), the out2_n output is held inactive
high while the value of this location is internally looped back to an input.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (OUT2_0): out2_n de-asserted (logic 1)</li><li>0x1 (OUT2_1): out2_n asserted (logic 0)</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MCR_F_2"></a>2</p>
</td>
<td>OUT1</td>
<td>R/W</td>
<td><p>OUT1</p>
<p class="BLANK"></p>
<p>This is used to directly control the user-designated Output1 (out1_n) output. The
value written to this location is inverted and driven out on out1_n.
Note that in Loopback mode (MCR[4] set to one), the out1_n output is held inactive high
while the value of this location is internally looped back to an input.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (OUT1_0): out1_n de-asserted (logic 1)</li><li>0x1 (OUT1_1): out1_n asserted (logic 0)</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MCR_F_1"></a>1</p>
</td>
<td>RTS</td>
<td>R/W</td>
<td><p>Request to Send.</p>
<p class="BLANK"></p>
<p>This is used to directly control the Request to Send (rts_n) output. The Request
To Send (rts_n) output is used to inform the modem or data set that the UART is
ready to exchange data.</p>
<p class="BLANK"></p>
<p>When Auto RTS Flow Control is not enabled (MCR[5] set to zero), the rts_n signal
is set low by programming MCR[1] (RTS) to a high.
In Auto Flow Control, AFCE_MODE == Enabled and active (MCR[5] set to one) and
FIFO's enable (FCR[0] set to one), the rts_n output is controlled in the same way,
but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high
when above the threshold).
The rts_n signal will be de-asserted when MCR[1] is set low.
Note that in Loopback mode (MCR[4] set to one), the rts_n output is held inactive
high while the value of this location is internally looped back to an input.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (INACTIVE): Request to Send rts_n de-asserted (logic 1)</li><li>0x1 (ACTIVE): Request to Send rts_n asserted (logic 0)</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MCR_F_0"></a>0</p>
</td>
<td>DTR</td>
<td>R/W</td>
<td><p>Data Terminal Ready.</p>
<p class="BLANK"></p>
<p>This is used to directly control the Data Terminal Ready (dtr_n) output. The value
written to this location is inverted and driven out on dtr_n.</p>
<p class="BLANK"></p>
<p>The Data Terminal Ready output is used to inform the modem or data set that the
UART is ready to establish communications. Note that in Loopback mode (MCR[4]
set to one), the dtr_n output is held inactive high while the value of this
location is internally looped back to an input.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (INACTIVE): dtr_n de-asserted (logic1)</li><li>0x1 (ACTIVE): dtr_n asserted (logic 0)</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_LSR"></a>LSR</p>
<ul><li>Name:Line Status Register</li><li>Description:Line Status Register</li><li>Size:32 bits</li><li>Offset:0x14</li></ul><a name="fld-uart_memory_map_uart_address_block_LSR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LSR_F_31_9">31:9</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LSR_F_8">8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LSR_F_7">7</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LSR_F_6">6</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LSR_F_5">5</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LSR_F_4">4</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LSR_F_3">3</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LSR_F_2">2</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LSR_F_1">1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LSR_F_0">0</a></td>
</tr>
<tr><td>RSVD_LSR_31to9</td>
<td>RSVD_ADDR_RCVD</td>
<td>RFE</td>
<td>TEMT</td>
<td>THRE</td>
<td>BI</td>
<td>FE</td>
<td>PE</td>
<td>OE</td>
<td>DR</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_LSR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: LSR</p>
<table summary="Fields for Register: LSR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LSR_F_31_9"></a>31:9</p>
</td>
<td>RSVD_LSR_31to9</td>
<td>R</td>
<td><p>LSR 31to9 Reserved bits read as zero.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LSR_F_8"></a>8</p>
</td>
<td>RSVD_ADDR_RCVD</td>
<td>R</td>
<td><p>lSR 8 Reserved bit for UART_9BIT_DATA_EN</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LSR_F_7"></a>7</p>
</td>
<td>RFE</td>
<td>R</td>
<td><p>Receiver FIFO Error bit.</p>
<p class="BLANK"></p>
<p>This bit is only relevant when FIFO_MODE != NONE AND FIFO's are enabled (FCR[0]
set to one). This is used to indicate if there is at least one parity error, framing
error, or break indication in the FIFO.</p>
<p class="BLANK"></p>
<p>This bit is cleared when the LSR is read and the character with the error is at the
top of the receiver FIFO and there are no subsequent errors in the FIFO.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NO_RX_FIFO_ERROR): No error in RX FIFO</li><li>0x1 (RX_FIFO_ERROR): Error in RX FIFO</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LSR_F_6"></a>6</p>
</td>
<td>TEMT</td>
<td>R</td>
<td><p>Transmitter Empty bit.</p>
<p class="BLANK"></p>
<p>If in FIFO mode (FIFO_MODE != NONE) and FIFO's enabled (FCR[0] set to one), this
bit is set whenever the Transmitter Shift Register and the FIFO are both empty.
If in the non-FIFO mode or FIFO's are disabled, this bit is set whenever the
Transmitter Holding Register and the Transmitter Shift Register are both empty.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Transmitter not empty</li><li>0x1 (ENABLED): Transmitter empty</li></ul><p></p>
<p>Value After Reset:0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LSR_F_5"></a>5</p>
</td>
<td>THRE</td>
<td>R</td>
<td><p>Transmit Holding Register Empty bit.</p>
<p class="BLANK"></p>
<p>If THRE_MODE_USER = Disabled or THRE mode is disabled (IER[7] set to zero) and
regardless of FIFO's being implemented/enabled or not, this bit indicates that
the THR or TX FIFO is empty.</p>
<p class="BLANK"></p>
<p>This bit is set whenever data is transferred from
the THR or TX FIFO to the transmitter shift register and no new data has been
written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the
THRE Interrupt is enabled.
If THRE_MODE_USER == Enabled AND FIFO_MODE != NONE and both modes are active
(IER[7] set to one and FCR[0] set to one respectively), the functionality is switched
to indicate the transmitter FIFO is full, and no longer controls THRE interrupts,
which are then controlled by the FCR[5:4] threshold setting. Programmable THRE
interrupt mode operation is described in detail in section 'Programmable THRE Interrupt' in data book.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): THRE interrupt control is disabled</li><li>0x1 (ENABLED): THRE interrupt control is enabled</li></ul><p></p>
<p>Value After Reset:0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LSR_F_4"></a>4</p>
</td>
<td>BI</td>
<td>R</td>
<td><p>Break Interrupt bit.</p>
<p class="BLANK"></p>
<p>This is used to indicate the detection of a break sequence on the serial input data.</p>
<p class="BLANK"></p>
<p>If in UART mode it is set whenever the serial input, sin, is held in a logic '0'
state for longer than the sum of start time + data bits + parity + stop bits.</p>
<p class="BLANK"></p>
<p>If in infrared mode it is set whenever the serial input, sir_in, is continuously
pulsed to logic '0' for longer than the sum of start time + data bits + parity + stop
bits.
A break condition on serial input causes one and only one character, consisting of
all zeros, to be received by the UART.</p>
<p class="BLANK"></p>
<p>In the FIFO mode, the character associated
with the break condition is carried through the FIFO and is revealed when the
character is at the top of the FIFO.</p>
<p class="BLANK"></p>
<p>If configuration parameter LSR_STATUS_CLEAR = 0:</p>
<ul><li>Reading the LSR or RBR register clears the BI bit.</li></ul><p>If configuration parameter LSR_STATUS_CLEAR = 1:</p>
<ul><li>If register field IER.ELCOLR = 0: Reading the LSR or RBR register clears the BI bit.</li><li>If register field IER.ELCOLR = 1: Reading the LSR register clears the BI bit.</li></ul><p>In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is
read.</p>
<p class="BLANK"></p>
<p>Note:If a FIFO is full when a break condition is received, a FIFO overrun occurs. The
break condition and all the information associated with it-parity and framing errors-is
discarded; any information that a break character was received is lost.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NO_BREAK): No break sequence detected</li><li>0x1 (BREAK): Break sequence detected</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LSR_F_3"></a>3</p>
</td>
<td>FE</td>
<td>R</td>
<td><p>Framing Error bit.</p>
<p class="BLANK"></p>
<p>This is used to indicate the occurrence of a framing error in the receiver. A framing
error occurs when the receiver does not detect a valid STOP bit in the received data.</p>
<p class="BLANK"></p>
<p>In the FIFO mode, since the framing error is associated with a character received, it
is revealed when the character with the framing error is at the top of the FIFO. When
a framing error occurs the UART will try resynchronize. It does this by assuming that
the error was due to the start bit of the next character and then continues receiving
the other bit i.e. data, and/or parity and stop.</p>
<p class="BLANK"></p>
<p>It should be noted that the Framing Error (FE) bit (LSR[3]) will be set if a break
interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]). This happens because the
break character implicitly generates a framing error by holding the sin input to logic 0 for
longer than the duration of a character.</p>
<p class="BLANK"></p>
<p>If configuration parameter LSR_STATUS_CLEAR = 0:</p>
<ul><li>Reading the LSR or RBR register clears the FE bit.</li></ul><p>If configuration parameter LSR_STATUS_CLEAR = 1:</p>
<ul><li>If register field IER.ELCOLR = 0: Reading the LSR or RBR register clears the FE bit.</li><li>If register field IER.ELCOLR = 1: Reading the LSR register clears the FE bit.</li></ul><p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NO_FRAMING_ERROR): no framing error</li><li>0x1 (FRAMING_ERROR): framing error</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LSR_F_2"></a>2</p>
</td>
<td>PE</td>
<td>R</td>
<td><p>Parity Error bit.</p>
<p class="BLANK"></p>
<p>This is used to indicate the occurrence of a parity error in the receiver if the
Parity Enable (PEN) bit (LCR[3]) is set.</p>
<p class="BLANK"></p>
<p>In the FIFO mode, since the parity error is
associated with a character received, it is revealed when the character with the parity
error arrives at the top of the FIFO.</p>
<p class="BLANK"></p>
<p>It should be noted that the Parity Error (PE) bit (LSR[2]) will be set if a break
interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]). In this situation, the Parity Error
bit is set if parity generation and detection is enabled (LCR[3]=1) and the parity is set to odd (LCR[4]=0).</p>
<p class="BLANK"></p>
<p>If configuration parameter LSR_STATUS_CLEAR = 0:</p>
<ul><li>Reading the LSR or RBR register clears the PE bit.</li></ul><p>If configuration parameter LSR_STATUS_CLEAR = 1:</p>
<ul><li>If register field IER.ELCOLR = 0: Reading the LSR or RBR register clears the PE bit.</li><li>If register field IER.ELCOLR = 1: Reading the LSR register clears the PE bit.</li></ul><p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NO_PARITY_ERROR): no parity error</li><li>0x1 (PARITY_ERROR): parity error</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LSR_F_1"></a>1</p>
</td>
<td>OE</td>
<td>R</td>
<td><p>Overrun error bit.</p>
<p class="BLANK"></p>
<p>This is used to indicate the occurrence of an overrun error. This occurs if a new data
character was received before the previous data was read.</p>
<p class="BLANK"></p>
<p>In the non-FIFO mode, the OE
bit is set when a new character arrives in the receiver before the previous character
was read from the RBR. When this happens, the data in the RBR is overwritten. In the
FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at
the receiver. The data in the FIFO is retained and the data in the receive shift register
is lost.</p>
<p class="BLANK"></p>
<p>If configuration parameter LSR_STATUS_CLEAR = 0:</p>
<ul><li>Reading the LSR register clears the OE bit.</li><li>Note: In this case the OE bit is only cleared on LSR register read to avoid loss of OE interrupt status information by DMA operation (RBR read). However, with respect to PE, FE and BI interrupt status bits, these information are available with the received data in RX FIFO.</li></ul><p>the read of RBR register.
If configuration parameter LSR_STATUS_CLEAR = 1:</p>
<ul><li>If register field IER.ELCOLR = 0: Reading the LSR or RBR register clears the OE bit.</li><li>If register field IER.ELCOLR = 1: Reading the LSR register clears the OE bit.</li></ul><p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NO_OVER_RUN_ERROR): no overrun error</li><li>0x1 (OVER_RUN_ERROR): overrun error</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LSR_F_0"></a>0</p>
</td>
<td>DR</td>
<td>R</td>
<td><p>Data Ready bit.</p>
<p class="BLANK"></p>
<p>This is used to indicate that the receiver contains at least one character in the
RBR or the receiver FIFO.
This bit is cleared when the RBR is read in the non-FIFO mode, or when the receiver
FIFO is empty, in the FIFO mode.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NOT_READY): data not ready</li><li>0x1 (READY): data ready</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_MSR"></a>MSR</p>
<ul><li>Name:Modem Status Register</li><li>Description:Whenever bits 0, 1, 2 or 3 is set to logic one, to indicate
a change on the modem control inputs, a modem status interrupt will be generated
if enabled via the IER regardless of when the change occurred. The bits
(bits 0, 1, 3) can be set after a reset-even though their respective modem signals are
inactive-because the synchronized version of the modem signals have a reset value of 0 and change to value 1 after reset. To
prevent unwanted interrupts due to this change, a read of the MSR register can be performed after reset.</li><li>Size:32 bits</li><li>Offset:0x18</li></ul><a name="fld-uart_memory_map_uart_address_block_MSR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MSR_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MSR_F_7">7</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MSR_F_6">6</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MSR_F_5">5</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MSR_F_4">4</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MSR_F_3">3</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MSR_F_2">2</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MSR_F_1">1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_MSR_F_0">0</a></td>
</tr>
<tr><td>RSVD_MSR_31to8</td>
<td>DCD</td>
<td>RI</td>
<td>DSR</td>
<td>CTS</td>
<td>DDCD</td>
<td>TERI</td>
<td>DDSR</td>
<td>DCTS</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_MSR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: MSR</p>
<table summary="Fields for Register: MSR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MSR_F_31_8"></a>31:8</p>
</td>
<td>RSVD_MSR_31to8</td>
<td>R</td>
<td><p>MSR 31to8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MSR_F_7"></a>7</p>
</td>
<td>DCD</td>
<td>R</td>
<td><p>Data Carrier Detect.</p>
<p class="BLANK"></p>
<p>This is used to indicate the current state of the modem control line dcd_n. That is
this bit is the complement dcd_n. When the Data Carrier Detect input (dcd_n) is
asserted it is an indication that the carrier has been detected by the modem or
data set.</p>
<p class="BLANK"></p>
<p>In Loopback Mode (MCR[4] set to one), DCD is the same as MCR[3] (Out2).</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DEASSERTED): dcd_n input is de-asserted (logic 1)</li><li>0x1 (ASSERTED): dcd_n input is asserted (logic 0)</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MSR_F_6"></a>6</p>
</td>
<td>RI</td>
<td>R</td>
<td><p>Ring Indicator.</p>
<p class="BLANK"></p>
<p>This is used to indicate the current state of the modem control line ri_n. That is
this bit is the complement ri_n. When the Ring Indicator input (ri_n) is asserted
it is an indication that a telephone ringing signal has been received by the modem
or data set.</p>
<p class="BLANK"></p>
<p>In Loopback Mode (MCR[4] set to one), RI is the same as MCR[2] (Out1).</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DEASSERTED): ri_n input is de-asserted (logic 1)</li><li>0x1 (ASSERTED): ri_n input is asserted (logic 0)</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MSR_F_5"></a>5</p>
</td>
<td>DSR</td>
<td>R</td>
<td><p>Data Set Ready.</p>
<p class="BLANK"></p>
<p>This is used to indicate the current state of the modem control line dsr_n. That is
this bit is the complement dsr_n. When the Data Set Ready input (dsr_n) is asserted
it is an indication that the modem or data set is ready to establish communications
with the DW_apb_uart.</p>
<p class="BLANK"></p>
<p>In Loopback Mode (MCR[4] set to one), DSR is the same as MCR[0] (DTR).</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DEASSERTED): dsr_n input is de-asserted (logic 1)</li><li>0x1 (ASSERTED): dsr_n input is asserted (logic 0)</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MSR_F_4"></a>4</p>
</td>
<td>CTS</td>
<td>R</td>
<td><p>Clear to Send.</p>
<p class="BLANK"></p>
<p>This is used to indicate the current state of the modem control line cts_n. That is,
this bit is the complement cts_n. When the Clear to Send input (cts_n) is asserted
it is an indication that the modem or data set is ready to exchange data with the
DW_apb_uart.</p>
<p class="BLANK"></p>
<p>In Loopback Mode (MCR[4] set to one), CTS is the same as MCR[1] (RTS).</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DEASSERTED): cts_n input is de-asserted (logic 1)</li><li>0x1 (ASSERTED): cts_n input is asserted (logic 0)</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MSR_F_3"></a>3</p>
</td>
<td>DDCD</td>
<td>R</td>
<td><p>Delta Data Carrier Detect.</p>
<p class="BLANK"></p>
<p>This is used to indicate that the modem control line dcd_n has changed since the last
time the MSR was read.</p>
<p class="BLANK"></p>
<p>Reading the MSR clears the DDCD bit.
In Loopback Mode (MCR[4] set to one), DDCD reflects changes on MCR[3] (Out2).</p>
<p class="BLANK"></p>
<p>Note, if the DDCD bit is not set and the dcd_n signal is asserted (low) and a reset
occurs (software or otherwise), then the DDCD bit will get set when the reset is
removed if the dcd_n signal remains asserted.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NO_CHANGE): No change on dcd_n since last read of MSR</li><li>0x1 (CHANGE): change on dcd_n since last read of MSR</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MSR_F_2"></a>2</p>
</td>
<td>TERI</td>
<td>R</td>
<td><p>Trailing Edge of Ring Indicator.</p>
<p class="BLANK"></p>
<p>This is used to indicate that a change on the input ri_n (from an active low, to
an inactive high state) has occurred since the last time the MSR was read.</p>
<p class="BLANK"></p>
<p>Reading the MSR clears the TERI bit.
In Loopback Mode (MCR[4] set to one), TERI reflects when MCR[2] (Out1) has changed
state from a high to a low.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NO_CHANGE): no change on ri_n since last read of MSR</li><li>0x1 (CHANGE): change on ri_n since last read of MSR</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MSR_F_1"></a>1</p>
</td>
<td>DDSR</td>
<td>R</td>
<td><p>Delta Data Set Ready.</p>
<p class="BLANK"></p>
<p>This is used to indicate that the modem control line dsr_n has changed since
the last time the MSR was read.</p>
<p class="BLANK"></p>
<p>Reading the MSR clears the DDSR bit.
In Loopback Mode (MCR[4] set to one), DDSR reflects changes on MCR[0] (DTR).</p>
<p class="BLANK"></p>
<p>Note, if the DDSR bit is not set and the dsr_n signal is asserted (low) and a reset
occurs (software or otherwise), then the DDSR bit will get set when the reset is
removed if the dsr_n signal remains asserted.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NO_CHANGE): no change on dsr_n since last read of MSR</li><li>0x1 (CHANGE): change on dsr_n since last read of MSR</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_MSR_F_0"></a>0</p>
</td>
<td>DCTS</td>
<td>R</td>
<td><p>Delta Clear to Send.</p>
<p class="BLANK"></p>
<p>This is used to indicate that the modem control line cts_n has changed since the
last time the MSR was read.</p>
<p class="BLANK"></p>
<p>Reading the MSR clears the DCTS bit.
In Loopback Mode (MCR[4] set to one), DCTS reflects changes on MCR[1] (RTS).</p>
<p class="BLANK"></p>
<p>Note, if the DCTS bit is not set and the cts_n signal is asserted (low) and a reset
occurs (software or otherwise), then the DCTS bit will get set when the reset is
removed if the cts_n signal remains asserted.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NO_CHANGE): no change on cts_n since last read of MSR</li><li>0x1 (CHANGE): change on cts_n since last read of MSR</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SCR"></a>SCR</p>
<ul><li>Name:Scratchpad Register</li><li>Description:Scratchpad Register</li><li>Size:32 bits</li><li>Offset:0x1c</li></ul><a name="fld-uart_memory_map_uart_address_block_SCR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SCR_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SCR_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SCR_31to8</td>
<td>SCR</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SCR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SCR</p>
<table summary="Fields for Register: SCR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SCR_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SCR_31to8</td>
<td>R</td>
<td><p>SCR 31to8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SCR_F_7_0"></a>7:0</p>
</td>
<td>SCR</td>
<td>R/W</td>
<td><p>This register is for programmers to use as a temporary storage space. It has no
defined purpose in the DW_apb_uart.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR0"></a>SRBR0</p>
<ul><li>Name:Shadow Receive Buffer Register</li><li>Description:This register is valid only when the DW_apb_uart is configured to have additional shadow registers
implemented (SHADOW = YES). If shadow registers are not implemented, this register does not exist and
reading from this register address returns 0.<p class="BLANK"></p>
This register can be accessed only when the DLAB bit (LCR[7]) is cleared.</li><li>Size:32 bits</li><li>Offset:0x30</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR0"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR0_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR0_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBRn</td>
<td>SRBRn</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR0"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR0</p>
<table summary="Fields for Register: SRBR0" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR0_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBRn</td>
<td>R</td>
<td><p>SRBR0 31 to SRBRN_REG_SIZE Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR0_F_7_0"></a>7:0</p>
</td>
<td>SRBRn</td>
<td>R</td>
<td><p>Shadow Receive Buffer Register n.
This is a shadow register for the RBR and has been allocated sixteen 32-bit locations
so as to accommodate burst accesses from the requester.
This register contains the data byte received on the serial input port (sin) in UART
mode or the serial infrared input (sir_in) in infrared mode. The data in this register
is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set.</p>
<p class="BLANK"></p>
<p>If in non-FIFO mode (FIFO_MODE == NONE) or FIFOs are disabled (FCR[0] set to zero), the
data in the RBR must be read before the next data arrives, otherwise it will be
overwritten, resulting in an overrun error.</p>
<p class="BLANK"></p>
<p>If in FIFO mode (FIFO_MODE != NONE) and FIFOs are enabled (FCR[0] set to one), this
register accesses the head of the receive FIFO. If the receive FIFO is full and this
register is not read before the next data character arrives, then the data already
in the FIFO will be preserved but any incoming data will be lost. An overrun error
will also occur.</p>
<p class="BLANK"></p>
<p>Note:</p>
<ul><li>When UART_9BIT_DATA_EN="0," this field width is 8.</li><li>When UART_9BIT_DATA_EN="1," this field width is 9.</li></ul><p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR0"></a>STHR0</p>
<ul><li>Name:Shadow Transmit Holding Register</li><li>Description:Shadow Transmit Holding Register. This register is valid only when the DW_apb_uart is configured to have additional shadow registers
implemented (SHADOW = YES). If shadow registers are not implemented, this register does not exist, and
reading from this register address returns 0.<p class="BLANK"></p>
This register can be accessed only when the DLAB bit (LCR[7]) is cleared.</li><li>Size:32 bits</li><li>Offset:0x30</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR0"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR0_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR0_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHRn</td>
<td>STHRn</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR0"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR0</p>
<table summary="Fields for Register: STHR0" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR0_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHRn</td>
<td>R</td>
<td><p>STHRn 31 to STHRN_REG_SIZE Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR0_F_7_0"></a>7:0</p>
</td>
<td>STHRn</td>
<td>W</td>
<td><p>Shadow Transmit Holding Register n.
This is a shadow register for the THR and has been allocated sixteen 32-bit locations
so as to accommodate burst accesses from the requester.
This register contains data to be transmitted on the serial output port (sout) in UART
mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be
written to the THR when the THR Empty (THRE) bit (LSR[5]) is set.</p>
<p class="BLANK"></p>
<p>If in non-FIFO mode or FIFO's are disabled (FCR[0] set to zero) and THRE is set,
writing a single character to the THR clears the THRE. Any additional writes to the
THR before the THRE is set again causes the THR data to be overwritten.</p>
<p class="BLANK"></p>
<p>If in FIFO mode and FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of
characters of data may be written to the THR before the FIFO is full. The number x
(default=16) is determined by the value of FIFO Depth that you set during configuration.
Any attempt to write data when the FIFO is full results in the write data being lost.</p>
<p class="BLANK"></p>
<p>Note:</p>
<p class="BLANK"></p>
<p></p>
<ul><li>When UART_9BIT_DATA_EN="0," this field width is 8.</li><li>When UART_9BIT_DATA_EN="1," this field width is 9. The 9th bit is applicable only when LCR_EXT[3]=1.</li></ul><p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR1"></a>SRBR1</p>
<ul><li>Name:Shadow Receive Buffer Register 1</li><li>Description:Shadow Receive Buffer Register 1</li><li>Size:32 bits</li><li>Offset:0x34</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR1"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR1_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR1_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR1</td>
<td>SRBR1</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR1"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR1</p>
<table summary="Fields for Register: SRBR1" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR1_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR1</td>
<td>R</td>
<td><p>SRBR1 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR1_F_7_0"></a>7:0</p>
</td>
<td>SRBR1</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR1"></a>STHR1</p>
<ul><li>Name:Shadow Transmit Holding Register 1</li><li>Description:Shadow Transmit Holding Register 1</li><li>Size:32 bits</li><li>Offset:0x34</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR1"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR1_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR1_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR1</td>
<td>STHR1</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR1"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR1</p>
<table summary="Fields for Register: STHR1" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR1_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR1</td>
<td>R</td>
<td><p>STHR1 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR1_F_7_0"></a>7:0</p>
</td>
<td>STHR1</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR2"></a>SRBR2</p>
<ul><li>Name:Shadow Receive Buffer Register 2</li><li>Description:Shadow Receive Buffer Register 2</li><li>Size:32 bits</li><li>Offset:0x38</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR2"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR2_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR2_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR2</td>
<td>SRBR2</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR2"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR2</p>
<table summary="Fields for Register: SRBR2" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR2_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR2</td>
<td>R</td>
<td><p>SRBR2 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR2_F_7_0"></a>7:0</p>
</td>
<td>SRBR2</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR2"></a>STHR2</p>
<ul><li>Name:Shadow Transmit Holding Register 2</li><li>Description:Shadow Transmit Holding Register 2</li><li>Size:32 bits</li><li>Offset:0x38</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR2"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR2_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR2_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR2</td>
<td>sthr2</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR2"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR2</p>
<table summary="Fields for Register: STHR2" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR2_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR2</td>
<td>R</td>
<td><p>STHR2 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR2_F_7_0"></a>7:0</p>
</td>
<td>sthr2</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR3"></a>SRBR3</p>
<ul><li>Name:Shadow Receive Buffer Register 3</li><li>Description:Shadow Receive Buffer Register 3</li><li>Size:32 bits</li><li>Offset:0x3c</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR3"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR3_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR3_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR3</td>
<td>SRBR3</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR3"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR3</p>
<table summary="Fields for Register: SRBR3" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR3_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR3</td>
<td>R</td>
<td><p>SRBR3 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR3_F_7_0"></a>7:0</p>
</td>
<td>SRBR3</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR3"></a>STHR3</p>
<ul><li>Name:Shadow Transmit Holding Register 3</li><li>Description:Shadow Transmit Holding Register 3</li><li>Size:32 bits</li><li>Offset:0x3c</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR3"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR3_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR3_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR3</td>
<td>sthr3</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR3"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR3</p>
<table summary="Fields for Register: STHR3" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR3_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR3</td>
<td>R</td>
<td><p>STHR3 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR3_F_7_0"></a>7:0</p>
</td>
<td>sthr3</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR4"></a>SRBR4</p>
<ul><li>Name:Shadow Receive Buffer Register 4</li><li>Description:Shadow Receive Buffer Register 4</li><li>Size:32 bits</li><li>Offset:0x40</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR4"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR4_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR4_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR4</td>
<td>SRBR4</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR4"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR4</p>
<table summary="Fields for Register: SRBR4" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR4_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR4</td>
<td>R</td>
<td><p>SRBR4 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR4_F_7_0"></a>7:0</p>
</td>
<td>SRBR4</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR4"></a>STHR4</p>
<ul><li>Name:Shadow Transmit Holding Register 4</li><li>Description:Shadow Transmit Holding Register 4</li><li>Size:32 bits</li><li>Offset:0x40</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR4"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR4_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR4_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR4</td>
<td>sthr4</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR4"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR4</p>
<table summary="Fields for Register: STHR4" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR4_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR4</td>
<td>R</td>
<td><p>STHR4 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR4_F_7_0"></a>7:0</p>
</td>
<td>sthr4</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR5"></a>SRBR5</p>
<ul><li>Name:Shadow Receive Buffer Register 5</li><li>Description:Shadow Receive Buffer Register 5</li><li>Size:32 bits</li><li>Offset:0x44</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR5"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR5_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR5_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR5</td>
<td>SRBR5</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR5"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR5</p>
<table summary="Fields for Register: SRBR5" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR5_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR5</td>
<td>R</td>
<td><p>SRBR5 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR5_F_7_0"></a>7:0</p>
</td>
<td>SRBR5</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR5"></a>STHR5</p>
<ul><li>Name:Shadow Transmit Holding Register 5</li><li>Description:Shadow Transmit Holding Register 5</li><li>Size:32 bits</li><li>Offset:0x44</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR5"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR5_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR5_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR5</td>
<td>sthr5</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR5"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR5</p>
<table summary="Fields for Register: STHR5" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR5_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR5</td>
<td>R</td>
<td><p>STHR5 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR5_F_7_0"></a>7:0</p>
</td>
<td>sthr5</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR6"></a>SRBR6</p>
<ul><li>Name:Shadow Receive Buffer Register 6</li><li>Description:Shadow Receive Buffer Register 6</li><li>Size:32 bits</li><li>Offset:0x48</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR6"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR6_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR6_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR6</td>
<td>SRBR6</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR6"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR6</p>
<table summary="Fields for Register: SRBR6" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR6_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR6</td>
<td>R</td>
<td><p>SRBR6 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR6_F_7_0"></a>7:0</p>
</td>
<td>SRBR6</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR6"></a>STHR6</p>
<ul><li>Name:Shadow Transmit Holding Register 6</li><li>Description:Shadow Transmit Holding Register 6</li><li>Size:32 bits</li><li>Offset:0x48</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR6"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR6_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR6_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR6</td>
<td>sthr6</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR6"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR6</p>
<table summary="Fields for Register: STHR6" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR6_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR6</td>
<td>R</td>
<td><p>STHR6 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR6_F_7_0"></a>7:0</p>
</td>
<td>sthr6</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR7"></a>SRBR7</p>
<ul><li>Name:Shadow Receive Buffer Register 7</li><li>Description:Shadow Receive Buffer Register 7</li><li>Size:32 bits</li><li>Offset:0x4c</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR7"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR7_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR7_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR7</td>
<td>SRBR7</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR7"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR7</p>
<table summary="Fields for Register: SRBR7" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR7_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR7</td>
<td>R</td>
<td><p>SRBR7 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR7_F_7_0"></a>7:0</p>
</td>
<td>SRBR7</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR7"></a>STHR7</p>
<ul><li>Name:Shadow Transmit Holding Register 7</li><li>Description:Shadow Transmit Holding Register 7</li><li>Size:32 bits</li><li>Offset:0x4c</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR7"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR7_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR7_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR7</td>
<td>sthr7</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR7"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR7</p>
<table summary="Fields for Register: STHR7" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR7_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR7</td>
<td>R</td>
<td><p>STHR7 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR7_F_7_0"></a>7:0</p>
</td>
<td>sthr7</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR8"></a>SRBR8</p>
<ul><li>Name:Shadow Receive Buffer Register 8</li><li>Description:Shadow Receive Buffer Register 8</li><li>Size:32 bits</li><li>Offset:0x50</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR8"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR8_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR8_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR8</td>
<td>SRBR8</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR8"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR8</p>
<table summary="Fields for Register: SRBR8" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR8_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR8</td>
<td>R</td>
<td><p>SRBR8 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR8_F_7_0"></a>7:0</p>
</td>
<td>SRBR8</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR8"></a>STHR8</p>
<ul><li>Name:Shadow Transmit Holding Register 8</li><li>Description:Shadow Transmit Holding Register 8</li><li>Size:32 bits</li><li>Offset:0x50</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR8"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR8_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR8_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR8</td>
<td>sthr8</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR8"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR8</p>
<table summary="Fields for Register: STHR8" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR8_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR8</td>
<td>R</td>
<td><p>STHR8 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR8_F_7_0"></a>7:0</p>
</td>
<td>sthr8</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR9"></a>SRBR9</p>
<ul><li>Name:Shadow Receive Buffer Register 9</li><li>Description:Shadow Receive Buffer Register 9</li><li>Size:32 bits</li><li>Offset:0x54</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR9"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR9_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR9_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR9</td>
<td>SRBR9</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR9"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR9</p>
<table summary="Fields for Register: SRBR9" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR9_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR9</td>
<td>R</td>
<td><p>SRBR9 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR9_F_7_0"></a>7:0</p>
</td>
<td>SRBR9</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR9"></a>STHR9</p>
<ul><li>Name:Shadow Transmit Holding Register 9</li><li>Description:Shadow Transmit Holding Register 9</li><li>Size:32 bits</li><li>Offset:0x54</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR9"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR9_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR9_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR9</td>
<td>sthr9</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR9"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR9</p>
<table summary="Fields for Register: STHR9" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR9_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR9</td>
<td>R</td>
<td><p>STHR9 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR9_F_7_0"></a>7:0</p>
</td>
<td>sthr9</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR10"></a>SRBR10</p>
<ul><li>Name:Shadow Receive Buffer Register 10</li><li>Description:Shadow Receive Buffer Register 10</li><li>Size:32 bits</li><li>Offset:0x58</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR10"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR10_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR10_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR10</td>
<td>SRBR10</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR10"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR10</p>
<table summary="Fields for Register: SRBR10" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR10_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR10</td>
<td>R</td>
<td><p>SRBR10 31to9or8 Reserved bi read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR10_F_7_0"></a>7:0</p>
</td>
<td>SRBR10</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR10"></a>STHR10</p>
<ul><li>Name:Shadow Transmit Holding Register 10</li><li>Description:Shadow Transmit Holding Register 10</li><li>Size:32 bits</li><li>Offset:0x58</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR10"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR10_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR10_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR10</td>
<td>sthr10</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR10"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR10</p>
<table summary="Fields for Register: STHR10" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR10_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR10</td>
<td>R</td>
<td><p>STHR10 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR10_F_7_0"></a>7:0</p>
</td>
<td>sthr10</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR11"></a>SRBR11</p>
<ul><li>Name:Shadow Receive Buffer Register 11</li><li>Description:Shadow Receive Buffer Register 11</li><li>Size:32 bits</li><li>Offset:0x5c</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR11"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR11_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR11_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR11</td>
<td>SRBR11</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR11"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR11</p>
<table summary="Fields for Register: SRBR11" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR11_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR11</td>
<td>R</td>
<td><p>SRBR11 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR11_F_7_0"></a>7:0</p>
</td>
<td>SRBR11</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR11"></a>STHR11</p>
<ul><li>Name:Shadow Transmit Holding Register 11</li><li>Description:Shadow Transmit Holding Register 11</li><li>Size:32 bits</li><li>Offset:0x5c</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR11"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR11_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR11_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR11</td>
<td>sthr11</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR11"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR11</p>
<table summary="Fields for Register: STHR11" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR11_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR11</td>
<td>R</td>
<td><p>STHR11 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR11_F_7_0"></a>7:0</p>
</td>
<td>sthr11</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR12"></a>SRBR12</p>
<ul><li>Name:Shadow Receive Buffer Register 12</li><li>Description:Shadow Receive Buffer Register 12</li><li>Size:32 bits</li><li>Offset:0x60</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR12"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR12_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR12_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR12</td>
<td>SRBR12</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR12"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR12</p>
<table summary="Fields for Register: SRBR12" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR12_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR12</td>
<td>R</td>
<td><p>SRBR12 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR12_F_7_0"></a>7:0</p>
</td>
<td>SRBR12</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR12"></a>STHR12</p>
<ul><li>Name:Shadow Transmit Holding Register 12</li><li>Description:Shadow Transmit Holding Register 12</li><li>Size:32 bits</li><li>Offset:0x60</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR12"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR12_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR12_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR12</td>
<td>sthr12</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR12"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR12</p>
<table summary="Fields for Register: STHR12" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR12_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR12</td>
<td>R</td>
<td><p>STHR12 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR12_F_7_0"></a>7:0</p>
</td>
<td>sthr12</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR13"></a>SRBR13</p>
<ul><li>Name:Shadow Receive Buffer Register 13</li><li>Description:Shadow Receive Buffer Register 13</li><li>Size:32 bits</li><li>Offset:0x64</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR13"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR13_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR13_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR13</td>
<td>SRBR13</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR13"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR13</p>
<table summary="Fields for Register: SRBR13" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR13_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR13</td>
<td>R</td>
<td><p>SRBR13 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR13_F_7_0"></a>7:0</p>
</td>
<td>SRBR13</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR13"></a>STHR13</p>
<ul><li>Name:Shadow Transmit Holding Register 13</li><li>Description:Shadow Transmit Holding Register 13</li><li>Size:32 bits</li><li>Offset:0x64</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR13"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR13_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR13_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR13</td>
<td>sthr13</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR13"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR13</p>
<table summary="Fields for Register: STHR13" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR13_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR13</td>
<td>R</td>
<td><p>STHR13 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR13_F_7_0"></a>7:0</p>
</td>
<td>sthr13</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR14"></a>SRBR14</p>
<ul><li>Name:Shadow Receive Buffer Register 14</li><li>Description:Shadow Receive Buffer Register 14</li><li>Size:32 bits</li><li>Offset:0x68</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR14"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR14_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR14_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR14</td>
<td>SRBR14</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR14"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR14</p>
<table summary="Fields for Register: SRBR14" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR14_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR14</td>
<td>R</td>
<td><p>SRBR14 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR14_F_7_0"></a>7:0</p>
</td>
<td>SRBR14</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR14"></a>STHR14</p>
<ul><li>Name:Shadow Transmit Holding Register 14</li><li>Description:Shadow Transmit Holding Register 14</li><li>Size:32 bits</li><li>Offset:0x68</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR14"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR14_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR14_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR14</td>
<td>sthr14</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR14"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR14</p>
<table summary="Fields for Register: STHR14" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR14_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR14</td>
<td>R</td>
<td><p>STHR14 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR14_F_7_0"></a>7:0</p>
</td>
<td>sthr14</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR15"></a>SRBR15</p>
<ul><li>Name:Shadow Receive Buffer Register 15</li><li>Description:Shadow Receive Buffer Register 15</li><li>Size:32 bits</li><li>Offset:0x6c</li></ul><a name="fld-uart_memory_map_uart_address_block_SRBR15"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR15_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRBR15_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_SRBR15</td>
<td>SRBR15</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRBR15"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRBR15</p>
<table summary="Fields for Register: SRBR15" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR15_F_31_8"></a>31:8</p>
</td>
<td>RSVD_SRBR15</td>
<td>R</td>
<td><p>SRBR15 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRBR15_F_7_0"></a>7:0</p>
</td>
<td>SRBR15</td>
<td>R</td>
<td><p>See SRBR0 description</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR15"></a>STHR15</p>
<ul><li>Name:Shadow Transmit Holding Register 15</li><li>Description:Shadow Transmit Holding Register 15</li><li>Size:32 bits</li><li>Offset:0x6c</li></ul><a name="fld-uart_memory_map_uart_address_block_STHR15"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR15_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STHR15_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_STHR15</td>
<td>STHR15</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STHR15"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STHR15</p>
<table summary="Fields for Register: STHR15" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR15_F_31_8"></a>31:8</p>
</td>
<td>RSVD_STHR15</td>
<td>R</td>
<td><p>STHR15 31to9or8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STHR15_F_7_0"></a>7:0</p>
</td>
<td>STHR15</td>
<td>W</td>
<td><p>See STHR0 description.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_FAR"></a>FAR</p>
<ul><li>Name:FIFO Access Register</li><li>Description:FIFO Access Register</li><li>Size:32 bits</li><li>Offset:0x70</li></ul><a name="fld-uart_memory_map_uart_address_block_FAR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_FAR_F_31_1">31:1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_FAR_F_0">0</a></td>
</tr>
<tr><td>RSVD_FAR_31to1</td>
<td>FAR</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_FAR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: FAR</p>
<table summary="Fields for Register: FAR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_FAR_F_31_1"></a>31:1</p>
</td>
<td>RSVD_FAR_31to1</td>
<td>R</td>
<td><p>FAR 31to1 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_FAR_F_0"></a>0</p>
</td>
<td>FAR</td>
<td>R</td>
<td><p>Writes will have no effect when FIFO_ACCESS == No, always readable. This register
is use to enable a FIFO access mode for testing, so that the receive FIFO can be
written by the requester and the transmit FIFO can be read by the requester when FIFO's
are implemented and enabled. When FIFOs are not implemented or not enabled it
allows the RBR to be written by the requester and the THR to be read by the requester.</p>
<p class="BLANK"></p>
<p>Note, that when the FIFO access mode is enabled/disabled, the control portion of
the receive FIFO and transmit FIFO is reset and the FIFO's are treated as empty.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): FIFO access mode disabled</li><li>0x1 (ENABLED): FIFO access mode enabled</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_USR"></a>USR</p>
<ul><li>Name:UART Status register</li><li>Description:UART Status register.</li><li>Size:32 bits</li><li>Offset:0x7c</li></ul><a name="fld-uart_memory_map_uart_address_block_USR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_USR_F_31_5">31:5</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_USR_F_4">4</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_USR_F_3">3</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_USR_F_2">2</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_USR_F_1">1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_USR_F_0">0</a></td>
</tr>
<tr><td>RSVD_USR_31to5</td>
<td>RFF</td>
<td>RFNE</td>
<td>TFE</td>
<td>TFNF</td>
<td>RSVD_BUSY</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_USR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: USR</p>
<table summary="Fields for Register: USR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_USR_F_31_5"></a>31:5</p>
</td>
<td>RSVD_USR_31to5</td>
<td>R</td>
<td><p>USR 31to5 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
<p>Volatile:true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_USR_F_4"></a>4</p>
</td>
<td>RFF</td>
<td>R</td>
<td><p>Receive FIFO Full.</p>
<p class="BLANK"></p>
<p>This bit is only valid when FIFO_STAT == YES. This is used to indicate that the
receive FIFO is completely full. That is:
This bit is cleared when the RX FIFO is no longer full.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NOT_FULL): Receive FIFO not full</li><li>0x1 (FULL): Receive FIFO full</li></ul><p></p>
<p>Value After Reset:0x0</p>
<p>Volatile:true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_USR_F_3"></a>3</p>
</td>
<td>RFNE</td>
<td>R</td>
<td><p>Receive FIFO Not Empty.</p>
<p class="BLANK"></p>
<p>This bit is only valid when FIFO_STAT == YES. This is used to indicate that the
receive FIFO contains one or more entries.
This bit is cleared when the RX FIFO is empty.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (EMPTY): Receive FIFO is empty</li><li>0x1 (NOT_EMPTY): Receive FIFO is not empty</li></ul><p></p>
<p>Value After Reset:0x0</p>
<p>Volatile:true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_USR_F_2"></a>2</p>
</td>
<td>TFE</td>
<td>R</td>
<td><p>Transmit FIFO Empty.</p>
<p class="BLANK"></p>
<p>This bit is only valid when FIFO_STAT == YES. This is used to indicate that the
transmit FIFO is completely empty.
This bit is cleared when the TX FIFO is no longer empty.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NOT_EMPTY): Transmit FIFO is not empty</li><li>0x1 (EMPTY): Transmit FIFO is empty</li></ul><p></p>
<p>Value After Reset:0x1</p>
<p>Volatile:true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_USR_F_1"></a>1</p>
</td>
<td>TFNF</td>
<td>R</td>
<td><p>Transmit FIFO Not Full.</p>
<p class="BLANK"></p>
<p>This bit is only valid when FIFO_STAT == YES. This is used to indicate that the
transmit FIFO is not full.
This bit is cleared when the TX FIFO is full.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (FULL): Transmit FIFO is full</li><li>0x1 (NOT_FULL): Transmit FIFO is not full</li></ul><p></p>
<p>Value After Reset:0x1</p>
<p>Volatile:true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_USR_F_0"></a>0</p>
</td>
<td>RSVD_BUSY</td>
<td>R</td>
<td><p>UART Busy.</p>
<p class="BLANK"></p>
<p>This bit is only valid when UART_16550_COMPATIBLE == YES. This indicates that a serial
transfer is in progress, when cleared indicates that the DW_apb_uart is idle or inactive.</p>
<p class="BLANK"></p>
<p>This bit will be set to 1 (busy) under any of the following conditions:</p>
<p class="BLANK"></p>
<p>- Transmission in progress on serial interface</p>
<p class="BLANK"></p>
<p>- Transmit data present in THR, when FIFO access mode is not being used (FAR = 0) and the baud divisor is non-zero ({DLH,DLL} does not equal 0) when the divisor latch access bit is 0 (LCR.DLAB = 0)</p>
<p class="BLANK"></p>
<p>- Reception in progress on the interface</p>
<p class="BLANK"></p>
<p>- Receive data present in RBR, when FIFO access mode is not being used (FAR = 0)</p>
<p class="BLANK"></p>
<p>Note:It is possible for the UART Busy bit to be cleared even though a new
character may have been sent from another device. That is, if the DW_apb_uart
has no data in the THR and RBR and there is no transmission in progress and a start
bit of a new character has just reached the DW_apb_uart. This is due to the fact
that a valid start is not seen until the middle of the bit period and this duration
is dependent on the baud divisor that has been programmed. If a second system clock
has been implemented (CLOCK_MODE == Enabled) the assertion of this bit will also be
delayed by several cycles of the slower clock.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (IDLE): DW_apb_uart is idle or inactive</li><li>0x1 (BUSY): DW_apb_uart is busy (actively transferring data)</li></ul><p></p>
<p>Value After Reset:0x0</p>
<p>Volatile:true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_TFL"></a>TFL</p>
<ul><li>Name:Transmit FIFO Level</li><li>Description:TFL register is valid only when the DW_apb_uart is configured to have additional FIFO status registers
implemented (FIFO_STAT = YES). If status registers are not implemented, this register does not exist and
reading from this register address returns 0.</li><li>Size:32 bits</li><li>Offset:0x80</li></ul><a name="fld-uart_memory_map_uart_address_block_TFL"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_TFL_F_31_7">31:7</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_TFL_F_6_0">6:0</a></td>
</tr>
<tr><td>RSVD_TFL_31toADDR_WIDTH</td>
<td>tfl</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_TFL"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: TFL</p>
<table summary="Fields for Register: TFL" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_TFL_F_31_7"></a>31:7</p>
</td>
<td>RSVD_TFL_31toADDR_WIDTH</td>
<td>R</td>
<td><p>TFL 31 to ADDR_WIDTH Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_TFL_F_6_0"></a>6:0</p>
</td>
<td>tfl</td>
<td>R</td>
<td><p>Transmit FIFO Level.</p>
<p class="BLANK"></p>
<p>This indicates the number of data entries in the transmit FIFO.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_RFL"></a>RFL</p>
<ul><li>Name:Receive FIFO Level</li><li>Description:RFL register is valid only when the DW_apb_uart is configured to have additional FIFO status registers
implemented (FIFO_STAT = YES). If status registers are not implemented, this register does not exist and
reading from this register address returns 0.</li><li>Size:32 bits</li><li>Offset:0x84</li></ul><a name="fld-uart_memory_map_uart_address_block_RFL"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_RFL_F_31_7">31:7</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_RFL_F_6_0">6:0</a></td>
</tr>
<tr><td>RSVD_RFL_31toADDR_WIDTH</td>
<td>rfl</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_RFL"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: RFL</p>
<table summary="Fields for Register: RFL" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_RFL_F_31_7"></a>31:7</p>
</td>
<td>RSVD_RFL_31toADDR_WIDTH</td>
<td>R</td>
<td><p>RFL 31 to ADDR_WIDTH Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_RFL_F_6_0"></a>6:0</p>
</td>
<td>rfl</td>
<td>R</td>
<td><p>Receive FIFO Level.</p>
<p class="BLANK"></p>
<p>This indicates the number of data entries in the receive FIFO.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRR"></a>SRR</p>
<ul><li>Name:Software Reset Register</li><li>Description:This register is valid only when the DW_apb_uart is configured to have additional shadow registers
implemented (SHADOW = YES). If shadow registers are not implemented, this register does not exist and
reading from this register address returns 0.<p class="BLANK"></p>
For more information on the amount of time that serial clock modules need in order to see new register
values and reset their respective state machines, refer to the 'Clock Support' subsection in the data book.</li><li>Size:32 bits</li><li>Offset:0x88</li></ul><a name="fld-uart_memory_map_uart_address_block_SRR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRR_F_31_3">31:3</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRR_F_2">2</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRR_F_1">1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRR_F_0">0</a></td>
</tr>
<tr><td>RSVD_SRR_31to3</td>
<td>XFR</td>
<td>RFR</td>
<td>UR</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRR</p>
<table summary="Fields for Register: SRR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRR_F_31_3"></a>31:3</p>
</td>
<td>RSVD_SRR_31to3</td>
<td>R</td>
<td><p>SRR 31to3 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRR_F_2"></a>2</p>
</td>
<td>XFR</td>
<td>W</td>
<td><p>XMIT FIFO Reset.</p>
<p class="BLANK"></p>
<p>Writes will have no effect when FIFO_MODE == NONE. This is a shadow register for
the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software
having to store previously written FCR values (which are pretty static) just to
reset the transmit FIFO.
This resets the control portion of the transmit FIFO and treats the FIFO as empty.
This will also de-assert the DMA TX request and single signals when additional DMA
handshaking signals are selected (DMA_EXTRA = YES). Note that this bit is 'self-clearing'. It is not necessary to clear this
bit.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRR_F_1"></a>1</p>
</td>
<td>RFR</td>
<td>W</td>
<td><p>RCVR FIFO Reset.</p>
<p class="BLANK"></p>
<p>Writes will have no effect when FIFO_MODE == NONE. This is a shadow register for
the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software
having to store previously written FCR values (which are pretty static) just to
reset the receive FIFO.
This resets the control portion of the receive FIFO and treats the FIFO as empty.
This will also de-assert the DMA RX request and single signals when additional DMA
handshaking signals are selected (DMA_EXTRA == YES). Note that this bit is
'self-clearing' and it is not necessary to clear this bit.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRR_F_0"></a>0</p>
</td>
<td>UR</td>
<td>W</td>
<td><p>UART Reset.</p>
<p class="BLANK"></p>
<p>This asynchronously resets the DW_apb_uart and synchronously removes the reset
assertion. For a two clock implementation both pclk and sclk domains will be reset.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NO_RESET): No Uart Reset</li><li>0x1 (RESET): Uart reset</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRTS"></a>SRTS</p>
<ul><li>Name:Shadow Request to Send</li><li>Description:SRTS register is valid only when the DW_apb_uart is configured to have additional shadow registers
implemented (SHADOW = YES). If shadow registers are not implemented, this register does not exist and
reading from this register address returns 0.</li><li>Size:32 bits</li><li>Offset:0x8c</li></ul><a name="fld-uart_memory_map_uart_address_block_SRTS"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRTS_F_31_1">31:1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRTS_F_0">0</a></td>
</tr>
<tr><td>RSVD_SRTS_31to1</td>
<td>SRTS</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRTS"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRTS</p>
<table summary="Fields for Register: SRTS" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRTS_F_31_1"></a>31:1</p>
</td>
<td>RSVD_SRTS_31to1</td>
<td>R</td>
<td><p>SRTS 31to1 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRTS_F_0"></a>0</p>
</td>
<td>SRTS</td>
<td>R/W</td>
<td><p>Shadow Request to Send.</p>
<p class="BLANK"></p>
<p>This is a shadow register for the RTS bit (MCR[1]), this can be used to remove the
burden of having to performing a read modify write on the MCR.
This is used to directly control the Request to Send (rts_n) output. The Request
To Send (rts_n) output is used to inform the modem or data set that the UART is ready
to exchange data.</p>
<p class="BLANK"></p>
<p>When Auto RTS Flow Control is not enabled (MCR[5] set to zero), the rts_n signal is
set low by programming MCR[1] (RTS) to a high.</p>
<p class="BLANK"></p>
<p>In Auto Flow Control, AFCE_MODE == Enabled and active (MCR[5] set to one) and FIFO's
enable (FCR[0] set to one), the rts_n output is controlled in the same way, but is
also gated with the receiver FIFO threshold trigger (rts_n is inactive high when
above the threshold) only when RTC Flow Trigger is disabled; otherwise it is gated by
the receiver FIFO almost-full trigger, where 'almost full' refers to two available
slots in the FIFO (rts_n is inactive high when above the threshold).</p>
<p class="BLANK"></p>
<p>Note that in Loopback mode (MCR[4] set to one), the rts_n output is held inactive
high while the value of this location is internally looped back to an input.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DEASSERTED): Shadow Request to Send uart_rts_n logic1</li><li>0x1 (ASSERTED): Shadow Request to Send uart_rts_n logic0</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SBCR"></a>SBCR</p>
<ul><li>Name:Shadow Break Control Register</li><li>Description:SBCR register is valid only when the DW_apb_uart is configured to have additional shadow registers
implemented (SHADOW = YES). If shadow registers are not implemented, this register does not exist and
reading from this register address returns 0.</li><li>Size:32 bits</li><li>Offset:0x90</li></ul><a name="fld-uart_memory_map_uart_address_block_SBCR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SBCR_F_31_1">31:1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SBCR_F_0">0</a></td>
</tr>
<tr><td>RSVD_SBCR_31to1</td>
<td>SBCB</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SBCR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SBCR</p>
<table summary="Fields for Register: SBCR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SBCR_F_31_1"></a>31:1</p>
</td>
<td>RSVD_SBCR_31to1</td>
<td>R</td>
<td><p>SBCR 31to1 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SBCR_F_0"></a>0</p>
</td>
<td>SBCB</td>
<td>R/W</td>
<td><p>Shadow Break Control Bit.</p>
<p class="BLANK"></p>
<p>This is a shadow register for the Break bit (LCR[6]), this can be used to remove
the burden of having to performing a read modify write on the LCR.
This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not
in Loopback Mode, as determined by MCR[4], the sout line is forced low until the
Break bit is cleared.</p>
<p class="BLANK"></p>
<p>If SIR_MODE == Enabled and active (MCR[6] set to one) the
sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition
is internally looped back to the receiver.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (NO_BREAK): No spacing on serial output</li><li>0x1 (BREAK): Serial output forced to the spacing</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SDMAM"></a>SDMAM</p>
<ul><li>Name:Shadow DMA Mode Register</li><li>Description:This register is valid only when the DW_apb_uart is configured to have additional FIFO registers implemented (FIFO_MODE != None) and additional shadow registers implemented (SHADOW = YES). If these registers are not implemented, this register does not exist and reading from this register address returns 0.</li><li>Size:32 bits</li><li>Offset:0x94</li></ul><a name="fld-uart_memory_map_uart_address_block_SDMAM"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SDMAM_F_31_1">31:1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SDMAM_F_0">0</a></td>
</tr>
<tr><td>RSVD_SDMAM_31to1</td>
<td>SDMAM</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SDMAM"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SDMAM</p>
<table summary="Fields for Register: SDMAM" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SDMAM_F_31_1"></a>31:1</p>
</td>
<td>RSVD_SDMAM_31to1</td>
<td>R</td>
<td><p>SDMAM 31to1 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SDMAM_F_0"></a>0</p>
</td>
<td>SDMAM</td>
<td>R/W</td>
<td><p>Shadow DMA Mode.</p>
<p class="BLANK"></p>
<p>This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove
the burden of having to store the previously written value to the FCR in memory and
having to mask this value so that only the DMA Mode bit gets updated.
This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n
output signals when additional DMA handshaking signals are not selected
(DMA_EXTRA == NO). See section 5.9 on page 54 for details on DMA support.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (MODE_0): Mode 0</li><li>0x1 (MODE_1): Mode 1</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SFE"></a>SFE</p>
<ul><li>Name:Shadow FIFO Enable Register</li><li>Description:SFE register is valid only when the DW_apb_uart is configured to have additional FIFO registers
implemented (FIFO_MODE != None) and additional shadow registers implemented (SHADOW = YES). If these registers are not implemented, this register does not exist and reading from this register address returns 0.</li><li>Size:32 bits</li><li>Offset:0x98</li></ul><a name="fld-uart_memory_map_uart_address_block_SFE"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SFE_F_31_1">31:1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SFE_F_0">0</a></td>
</tr>
<tr><td>RSVD_SFE_31to1</td>
<td>SFE</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SFE"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SFE</p>
<table summary="Fields for Register: SFE" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SFE_F_31_1"></a>31:1</p>
</td>
<td>RSVD_SFE_31to1</td>
<td>R</td>
<td><p>SFE 31to1 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SFE_F_0"></a>0</p>
</td>
<td>SFE</td>
<td>R/W</td>
<td><p>Shadow FIFO Enable.</p>
<p class="BLANK"></p>
<p>This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to
remove the burden of having to store the previously written value to the FCR in
memory and having to mask this value so that only the FIFO enable bit gets updated.
This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. If this
bit is set to zero (disabled) after being enabled then both the XMIT and RCVR
controller portion of FIFO's will be reset.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): FIFOs are disabled</li><li>0x1 (ENABLED): FIFOs are enabled</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_SRT"></a>SRT</p>
<ul><li>Name:Shadow RCVR Trigger Register</li><li>Description:SRT register is valid only when the DW_apb_uart is configured to have additional FIFO registers
implemented (FIFO_MODE != None) and additional shadow registers implemented (SHADOW = YES). If these registers are not implemented, this register does not exist and reading from this register address returns 0.</li><li>Size:32 bits</li><li>Offset:0x9c</li></ul><a name="fld-uart_memory_map_uart_address_block_SRT"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRT_F_31_2">31:2</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_SRT_F_1_0">1:0</a></td>
</tr>
<tr><td>RSVD_SRT_31to2</td>
<td>SRT</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_SRT"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: SRT</p>
<table summary="Fields for Register: SRT" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRT_F_31_2"></a>31:2</p>
</td>
<td>RSVD_SRT_31to2</td>
<td>R</td>
<td><p>SRT 31to2 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_SRT_F_1_0"></a>1:0</p>
</td>
<td>SRT</td>
<td>R/W</td>
<td><p>Shadow RCVR Trigger.</p>
<p class="BLANK"></p>
<p>This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to
remove the burden of having to store the previously written value to the FCR in
memory and having to mask this value so that only the RCVR trigger bit gets updated.</p>
<p class="BLANK"></p>
<p>This is used to select the trigger level in the receiver FIFO at which the Received
Data Available Interrupt will be generated. It also determines when the dma_rx_req_n
signal will be asserted when DMA Mode (FCR[3]) is set to one.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (FIFO_CHAR_1): 1 character in FIFO</li><li>0x1 (FIFO_QUARTER_FULL): FIFO 1/4 full</li><li>0x2 (FIFO_HALF_FULL): FIFO 1/2 full</li><li>0x3 (FIFO_FULL_2): FIFO 2 less than full</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_STET"></a>STET</p>
<ul><li>Name:Shadow TX Empty Trigger Register</li><li>Description:This register is valid only when the DW_apb_uart is configured to have FIFOs implemented
(FIFO_MODE != NONE) and THRE interrupt support implemented (THRE_MODE_USER = Enabled) and
additional shadow registers implemented (SHADOW = YES). If FIFOs are not implemented or THRE interrupt support is not implemented or shadow registers are not implemented, this register does not exist and reading from this register address returns 0.</li><li>Size:32 bits</li><li>Offset:0xa0</li></ul><a name="fld-uart_memory_map_uart_address_block_STET"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STET_F_31_2">31:2</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_STET_F_1_0">1:0</a></td>
</tr>
<tr><td>RSVD_STET_31to2</td>
<td>STET</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_STET"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: STET</p>
<table summary="Fields for Register: STET" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STET_F_31_2"></a>31:2</p>
</td>
<td>RSVD_STET_31to2</td>
<td>R</td>
<td><p>STET 31to2 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_STET_F_1_0"></a>1:0</p>
</td>
<td>STET</td>
<td>R/W</td>
<td><p>Shadow TX Empty Trigger.</p>
<p class="BLANK"></p>
<p>This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used
to remove the burden of having to store the previously written value to the FCR in
memory and having to mask this value so that only the TX empty trigger bit gets updated.
Writes will have no effect when THRE_MODE_USER == Disabled. This is used to select the
empty threshold level at which the THRE Interrupts will be generated when the mode is
active.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (FIFO_EMPTY): FIFO empty</li><li>0x1 (FIFO_CHAR_2): 2 characters in FIFO</li><li>0x2 (FIFO_QUARTER_FULL): FIFO 1/4 full</li><li>0x3 (FIFO_HALF_FULL): FIFO 1/2 full</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_HTX"></a>HTX</p>
<ul><li>Name:Halt TX</li><li>Description:Halt TX</li><li>Size:32 bits</li><li>Offset:0xa4</li></ul><a name="fld-uart_memory_map_uart_address_block_HTX"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_HTX_F_31_1">31:1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_HTX_F_0">0</a></td>
</tr>
<tr><td>RSVD_HTX_31to1</td>
<td>HTX</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_HTX"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: HTX</p>
<table summary="Fields for Register: HTX" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_HTX_F_31_1"></a>31:1</p>
</td>
<td>RSVD_HTX_31to1</td>
<td>R</td>
<td><p>HTX 31to1 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_HTX_F_0"></a>0</p>
</td>
<td>HTX</td>
<td>R/W</td>
<td><p>Halt TX.</p>
<p class="BLANK"></p>
<p>Writes will have no effect when FIFO_MODE == NONE, always readable. This register
is use to halt transmissions for testing, so that the transmit FIFO can be filled
by the requester when FIFO's are implemented and enabled.</p>
<p class="BLANK"></p>
<p>Note, if FIFO's are implemented and not enabled the setting of the halt TX register
will have no effect on operation.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Halt Transmission disabled</li><li>0x1 (ENABLED): Halt Transmission enabled</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_DMASA"></a>DMASA</p>
<ul><li>Name:DMA Software Acknowledge Register</li><li>Description:DMA Software Acknowledge Register</li><li>Size:32 bits</li><li>Offset:0xa8</li></ul><a name="fld-uart_memory_map_uart_address_block_DMASA"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DMASA_F_31_1">31:1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DMASA_F_0">0</a></td>
</tr>
<tr><td>RSVD_DMASA_31to1</td>
<td>DMASA</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_DMASA"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: DMASA</p>
<table summary="Fields for Register: DMASA" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DMASA_F_31_1"></a>31:1</p>
</td>
<td>RSVD_DMASA_31to1</td>
<td>R</td>
<td><p>DMASA 31to1 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DMASA_F_0"></a>0</p>
</td>
<td>DMASA</td>
<td>W</td>
<td><p>DMA Software Acknowledge.</p>
<p class="BLANK"></p>
<p>Writes will have no effect when DMA_EXTRA == No. This register is use to perform
DMA software acknowledge if a transfer needs to be terminated due to an error
condition. For example, if the DMA disables the channel, then the DW_apb_uart should
clear its request. This will cause the TX request, TX single, RX request and RX
single signals to de-assert.
Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x1 (SOFT_ACK): DMA software acknowledge</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_TCR"></a>TCR</p>
<ul><li>Name:Transceiver Control Register</li><li>Description:This register is used to enable or disable RS485 mode and also control the polarity values for Driven enable
(de) and Receiver Enable (re) signals.<p class="BLANK"></p>
This register is only valid when the DW_apb_uart is configured to have RS485 interface implemented
(UART_RS485_INTERFACE_EN = ENABLED). If RS485 interface is not implemented, this register does not
exist and reading from this register address returns zero.</li><li>Size:32 bits</li><li>Offset:0xac</li></ul><a name="fld-uart_memory_map_uart_address_block_TCR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_TCR_F_31_5">31:5</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_TCR_F_4_3">4:3</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_TCR_F_2">2</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_TCR_F_1">1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_TCR_F_0">0</a></td>
</tr>
<tr><td>RSVD_TCR_31to5</td>
<td>XFER_MODE</td>
<td>DE_POL</td>
<td>RE_POL</td>
<td>RS485_EN</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_TCR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: TCR</p>
<table summary="Fields for Register: TCR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_TCR_F_31_5"></a>31:5</p>
</td>
<td>RSVD_TCR_31to5</td>
<td>R</td>
<td><p>TCR 31to5 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_TCR_F_4_3"></a>4:3</p>
</td>
<td>XFER_MODE</td>
<td>R/W</td>
<td><p>Transfer Mode.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (XFER_MODE_0): In this mode, transmit and receive can happen simultaneously. The user can enable DE_EN, RE_EN at any point of time.<p class="BLANK"></p>
Turn around timing as programmed in the TAT register is not applicable in this mode.</li><li>0x1 (XFER_MODE_1): In this mode, DE and RE are mutually exclusive. Either DE or RE only one of them is expected to be enabled through programming.<p class="BLANK"></p>
Hardware will consider the Turn Around timings which are programmed in the TAT register while switching from RE to DE or DE to RE.For transmission Hardware will wait if it is in middle of receiving any transfer, before it starts transmitting.</li><li>0x2 (XFER_MODE_2): In this mode, DE and RE are mutually exclusive. Once DE_EN/RE_EN is programed - by default 're' will be enabled and DW_apb_uart controller will be ready to receive. If the user programs the TX FIFO with the data then DW_apb_uart, after ensuring no receive is in progress, disable 're' and enable 'de' signal.<p class="BLANK"></p>
Once the TX FIFO becomes empty, 're' signal gets enabled and 'de' signal will be disabled.In this mode of operation hardware will consider the Turn Around timings which are programmed in the TAT register while switching from RE to DE or DE to RE. In this mode, 'de' and 're' signals are strictly complementary to each other.</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_TCR_F_2"></a>2</p>
</td>
<td>DE_POL</td>
<td>R/W</td>
<td><p>Driver Enable Polarity.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (LOW): DE signal is active low</li><li>0x1 (HIGH): DE signal is active high</li></ul><p></p>
<p>Value After Reset:0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_TCR_F_1"></a>1</p>
</td>
<td>RE_POL</td>
<td>R/W</td>
<td><p>Receiver Enable Polarity.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (LOW): RE signal is active low</li><li>0x1 (HIGH): RE signal is active high</li></ul><p></p>
<p>Value After Reset:0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_TCR_F_0"></a>0</p>
</td>
<td>RS485_EN</td>
<td>R/W</td>
<td><p>RS485 Transfer Enable.</p>
<p class="BLANK"></p>
<p></p>
<ul><li>0 : In this mode, the transfers are still in the RS232 mode. All other fields in this register are reserved and register
DE_EN/RE_EN/TAT are also reserved.</li><li>1 : In this mode, the transfers will happen in RS485 mode. All other fields of this register are applicable.</li></ul><p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLE): RS232 Mode</li><li>0x1 (ENABLE): RS485 Mode</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_DE_EN"></a>DE_EN</p>
<ul><li>Name:Driver Output Enable Register</li><li>Description:The Driver Output Enable Register (DE_EN) is used to control the assertion and de-assertion of the DE
signal.<p class="BLANK"></p>
This register is only valid when the DW_apb_uart is configured to have RS485 interface implemented
(UART_RS485_INTERFACE_EN = ENABLED). If RS485 interface is not implemented, this register does not
exist and reading from this register address will return zero.</li><li>Size:32 bits</li><li>Offset:0xb0</li></ul><a name="fld-uart_memory_map_uart_address_block_DE_EN"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DE_EN_F_31_1">31:1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DE_EN_F_0">0</a></td>
</tr>
<tr><td>RSVD_DE_EN_31to1</td>
<td>DE_Enable</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_DE_EN"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: DE_EN</p>
<table summary="Fields for Register: DE_EN" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DE_EN_F_31_1"></a>31:1</p>
</td>
<td>RSVD_DE_EN_31to1</td>
<td>R</td>
<td><p>DE_EN 31to1 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DE_EN_F_0"></a>0</p>
</td>
<td>DE_Enable</td>
<td>R/W</td>
<td><p>DE Enable control.</p>
<p class="BLANK"></p>
<p>The 'DE Enable' register bit is used to control assertion and de-assertion of 'de' signal.</p>
<p class="BLANK"></p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DE_ASSERT): De-assert 'de' signal</li><li>0x1 (ASSERT): Assert 'de' signal</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_RE_EN"></a>RE_EN</p>
<ul><li>Name:Receiver Output Enable Register</li><li>Description:The Receiver Output Enable Register (RE_EN) is used to control the assertion and de-assertion of the RE signal.<p class="BLANK"></p>
This register is only valid when the DW_apb_uart is configured to have RS485 interface implemented
(UART_RS485_INTERFACE_EN = ENABLED). If the RS485 interface is not implemented, this register does
not exist and reading from this register address will return zero.</li><li>Size:32 bits</li><li>Offset:0xb4</li></ul><a name="fld-uart_memory_map_uart_address_block_RE_EN"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_RE_EN_F_31_1">31:1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_RE_EN_F_0">0</a></td>
</tr>
<tr><td>RSVD_RE_EN_31to1</td>
<td>RE_Enable</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_RE_EN"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: RE_EN</p>
<table summary="Fields for Register: RE_EN" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_RE_EN_F_31_1"></a>31:1</p>
</td>
<td>RSVD_RE_EN_31to1</td>
<td>R</td>
<td><p>RE_EN 31to1 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_RE_EN_F_0"></a>0</p>
</td>
<td>RE_Enable</td>
<td>R/W</td>
<td><p>RE Enable control.</p>
<p class="BLANK"></p>
<p>The 'RE Enable' register bit is used to control assertion and de-assertion of 're' signal.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DE_ASSERT): De-assert 're' signal</li><li>0x1 (ASSERT): Assert 're' signal</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_DET"></a>DET</p>
<ul><li>Name:Driver Output Enable Timing Register</li><li>Description:The Driver Output Enable Timing Register (DET) is used to control the DE assertion and de-assertion timings of 'de' signal.<p class="BLANK"></p>
This register is only valid when the DW_apb_uart is configured to have RS485 interface implemented (UART_RS485_INTERFACE = ENABLED). If RS485 interface is not implemented, this register does not exist and reading from this register address will return zero.</li><li>Size:32 bits</li><li>Offset:0xb8</li></ul><a name="fld-uart_memory_map_uart_address_block_DET"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DET_F_31_24">31:24</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DET_F_23_16">23:16</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DET_F_15_8">15:8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DET_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_DE_DEAT_31to24</td>
<td>DE_De-assertion_Time</td>
<td>RSVD_DE_AT_15to8</td>
<td>DE_Assertion_Time</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_DET"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: DET</p>
<table summary="Fields for Register: DET" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DET_F_31_24"></a>31:24</p>
</td>
<td>RSVD_DE_DEAT_31to24</td>
<td>R</td>
<td><p>DET 31to24 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DET_F_23_16"></a>23:16</p>
</td>
<td>DE_De-assertion_Time</td>
<td>R/W</td>
<td><p>Driver Enable de-assertion time.</p>
<p class="BLANK"></p>
<p>This field controls the amount of time (in terms of number of serial clock periods)
between the end of stop bit on the sout to the falling edge of Driver output enable signal.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DET_F_15_8"></a>15:8</p>
</td>
<td>RSVD_DE_AT_15to8</td>
<td>R</td>
<td><p>DET 15to8 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DET_F_7_0"></a>7:0</p>
</td>
<td>DE_Assertion_Time</td>
<td>R/W</td>
<td><p>Driver Enable assertion time.</p>
<p class="BLANK"></p>
<p>This field controls the amount of time (in terms of number of serial clock periods)
between the assertion of rising edge of Driver output enable signal to serial transmit enable. Any data in transmit buffer,
will start on serial output (sout) after the transmit enable.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_TAT"></a>TAT</p>
<ul><li>Name:Turn Around Timing Register</li><li>Description:The Turn Around Timing Register (TAT) is used to hold the turnaround time between switching of 're' and
'de' signals.<p class="BLANK"></p>
This register is only valid when the DW_apb_uart is configured to have the RS485 interface implemented
(UART_RS485_INTERFACE_EN = ENABLED). If RS485 interface is not implemented, this register does not
exist and reading from this register address will return zero.</li><li>Size:32 bits</li><li>Offset:0xbc</li></ul><a name="fld-uart_memory_map_uart_address_block_TAT"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_TAT_F_31_16">31:16</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_TAT_F_15_0">15:0</a></td>
</tr>
<tr><td>RE_to_DE</td>
<td>DE_to_RE</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_TAT"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: TAT</p>
<table summary="Fields for Register: TAT" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_TAT_F_31_16"></a>31:16</p>
</td>
<td>RE_to_DE</td>
<td>R/W</td>
<td><p>Receiver Enable to Driver Enable TurnAround time.</p>
<p class="BLANK"></p>
<p>Turnaround time (in terms of serial clock) for RE De-assertion to DE assertion.</p>
<p class="BLANK"></p>
<p>Note:</p>
<p class="BLANK"></p>
<p>- If the DE assertion time in the DET register is 0, then the actual value is the programmed value + 3.
- If the DE assertion time in the DET register is 1, then the actual value is the programmed value + 2.
- If the DE assertion time in the DET register is greater than 1, then the actual value is the programmed value + 1.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_TAT_F_15_0"></a>15:0</p>
</td>
<td>DE_to_RE</td>
<td>R/W</td>
<td><p>Driver Enable to Receiver Enable TurnAround time.</p>
<p class="BLANK"></p>
<p>Turnaround time (in terms of serial clock) for DE De-assertion to RE assertion.</p>
<p class="BLANK"></p>
<p>Note:The actual time is the programmed value + 1.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_DLF"></a>DLF</p>
<ul><li>Name:Divisor Latch Fraction Register</li><li>Description:This register is only valid when the DW_apb_uart is configured to have Fractional Baud rate Divisor implemented (FRACTIONAL_BAUD_DIVISOR_EN = ENABLED). If Fractional Baud rate divisor is not implemented, this register does not exist and reading from this register address will return zero.</li><li>Size:32 bits</li><li>Offset:0xc0</li></ul><a name="fld-uart_memory_map_uart_address_block_DLF"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DLF_F_31_4">31:4</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_DLF_F_3_0">3:0</a></td>
</tr>
<tr><td>RSVD_DLF</td>
<td>DLF</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_DLF"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: DLF</p>
<table summary="Fields for Register: DLF" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DLF_F_31_4"></a>31:4</p>
</td>
<td>RSVD_DLF</td>
<td>R</td>
<td><p>DLF 31 to DLF_SIZE Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_DLF_F_3_0"></a>3:0</p>
</td>
<td>DLF</td>
<td>R/W</td>
<td><p>Fractional part of divisor.</p>
<p class="BLANK"></p>
<p>The fractional value is added to integer value set by DLH, DLL. Fractional value is determined by (Divisor Fraction value)/(2^DLF_SIZE). For information on DLF
values to be programmed for DLF_SIZE="4," see the 'Fractional Baud Rate Support' section in the DW_apb_uart Databook.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_EXT"></a>LCR_EXT</p>
<ul><li>Name:Line Extended Control Register</li><li>Description:Line Extended Control Register</li><li>Size:32 bits</li><li>Offset:0xcc</li></ul><a name="fld-uart_memory_map_uart_address_block_LCR_EXT"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_EXT_F_31_5">31:5</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_EXT_F_4">4</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_EXT_F_3">3</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_EXT_F_2">2</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_EXT_F_1">1</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_LCR_EXT_F_0">0</a></td>
</tr>
<tr><td>RSVD_LCR_EXT</td>
<td>CGEN</td>
<td>RSVD_TRANSMIT_MODE</td>
<td>RSVD_SEND_ADDR</td>
<td>RSVD_ADDR_MATCH</td>
<td>RSVD_DLS_E</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_LCR_EXT"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: LCR_EXT</p>
<table summary="Fields for Register: LCR_EXT" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_EXT_F_31_5"></a>31:5</p>
</td>
<td>RSVD_LCR_EXT</td>
<td>R</td>
<td><p>LCR_EXT 31to5 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
<p>Volatile:true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_EXT_F_4"></a>4</p>
</td>
<td>CGEN</td>
<td>R/W</td>
<td><p>Clock Gate Enable Signal. This bit is used to gate the clock cycles and enable the low power mode when the device is inactive.</p>
<p>Value After Reset:0x1</p>
<p>Volatile:true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_EXT_F_3"></a>3</p>
</td>
<td>RSVD_TRANSMIT_MODE</td>
<td>R</td>
<td><p>TRANSMIT_MODE Reserved bit read as 0.</p>
<p>Value After Reset:0x0</p>
<p>Volatile:true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_EXT_F_2"></a>2</p>
</td>
<td>RSVD_SEND_ADDR</td>
<td>R</td>
<td><p>SEND_ADDR Reserved bit read as 0.</p>
<p>Value After Reset:0x0</p>
<p>Volatile:true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_EXT_F_1"></a>1</p>
</td>
<td>RSVD_ADDR_MATCH</td>
<td>R</td>
<td><p>ADDR_MATCH Reserved bit read as 0.</p>
<p>Value After Reset:0x0</p>
<p>Volatile:true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_LCR_EXT_F_0"></a>0</p>
</td>
<td>RSVD_DLS_E</td>
<td>R</td>
<td><p>DLS_E Reserved bit read as 0.</p>
<p>Value After Reset:0x0</p>
<p>Volatile:true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_UART_PROT_LEVEL"></a>UART_PROT_LEVEL</p>
<ul><li>Name:UART Protection level</li><li>Description:UART Protection level register</li><li>Size:32 bits</li><li>Offset:0xd0</li></ul><a name="fld-uart_memory_map_uart_address_block_UART_PROT_LEVEL"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_UART_PROT_LEVEL_F_31_3">31:3</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_UART_PROT_LEVEL_F_2_0">2:0</a></td>
</tr>
<tr><td>RSVD_UART_PROT_LEVEL</td>
<td>UART_PROT_LEVEL</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_UART_PROT_LEVEL"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: UART_PROT_LEVEL</p>
<table summary="Fields for Register: UART_PROT_LEVEL" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_UART_PROT_LEVEL_F_31_3"></a>31:3</p>
</td>
<td>RSVD_UART_PROT_LEVEL</td>
<td>R</td>
<td><p>UART_PROT_LEVEL[31:29] Reserved field-read-only</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_UART_PROT_LEVEL_F_2_0"></a>2:0</p>
</td>
<td>UART_PROT_LEVEL</td>
<td>R/W</td>
<td><p>Protection level register.</p>
<p class="BLANK"></p>
<p>Enabling protection on any of its three bits would require a greater or equal privilege on the PPROT signal to gain access to protected registers.</p>
<p>Value After Reset:0x2</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_REG_TIMEOUT_RST"></a>REG_TIMEOUT_RST</p>
<ul><li>Name:Register timeout counter reset value</li><li>Description:Name: Register timeout counter reset register
This register keeps the reset value of reg_timer counter register.
The reset value of the register is REG_TIMEOUT_DEFAULT
The default reset value can be further modified if HC_REG_TIMEOUT_VALUE = 0.
The final programmed value (or the default reset value if not programmed)
determines what value the reg_timeout counter register starts counting down
from. A zero on the counter will break the hung transaction with PSLVERR high</li><li>Size:32 bits</li><li>Offset:0xd4</li></ul><a name="fld-uart_memory_map_uart_address_block_REG_TIMEOUT_RST"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_REG_TIMEOUT_RST_F_31_4">31:4</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_REG_TIMEOUT_RST_F_3_0">3:0</a></td>
</tr>
<tr><td>RSVD_REG_TIMEOUT_RST</td>
<td>REG_TIMEOUT_RST</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_REG_TIMEOUT_RST"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: REG_TIMEOUT_RST</p>
<table summary="Fields for Register: REG_TIMEOUT_RST" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_REG_TIMEOUT_RST_F_31_4"></a>31:4</p>
</td>
<td>RSVD_REG_TIMEOUT_RST</td>
<td>R</td>
<td><p>Reserved bits - Read Only</p>
<p>Value After Reset:0x0</p>
<p>Volatile:true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_REG_TIMEOUT_RST_F_3_0"></a>3:0</p>
</td>
<td>REG_TIMEOUT_RST</td>
<td>R/W</td>
<td><p>This field holds reset value of REG_TIMEOUT counter register.</p>
<p>Value After Reset:0x8</p>
<p>Volatile:true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR"></a>CPR</p>
<ul><li>Name:Component Parameter Register</li><li>Description:Component Parameter Register.This register is valid only when UART_ADD_ENCODED_PARAMS = 1. If the UART_ADD_ENCODED_PARAMS parameter is not set, this register does not exist and reading from this register address returns 0.</li><li>Size:32 bits</li><li>Offset:0xf4</li></ul><a name="fld-uart_memory_map_uart_address_block_CPR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_31_24">31:24</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_23_16">23:16</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_15_14">15:14</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_13">13</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_12">12</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_11">11</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_10">10</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_9">9</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_8">8</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_7">7</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_6">6</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_5">5</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_4">4</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_3_2">3:2</a></td>
<td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CPR_F_1_0">1:0</a></td>
</tr>
<tr><td>RSVD_CPR_31to24</td>
<td>FIFO_MODE</td>
<td>RSVD_CPR_15to14</td>
<td>DMA_EXTRA</td>
<td>UART_ADD_ENCODED_PARAMS</td>
<td>SHADOW</td>
<td>FIFO_STAT</td>
<td>FIFO_ACCESS</td>
<td>ADDITIONAL_FEAT</td>
<td>SIR_LP_MODE</td>
<td>SIR_MODE</td>
<td>THRE_MODE</td>
<td>AFCE_MODE</td>
<td>RSVD_CPR_3to2</td>
<td>APB_DATA_WIDTH</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_CPR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: CPR</p>
<table summary="Fields for Register: CPR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_31_24"></a>31:24</p>
</td>
<td>RSVD_CPR_31to24</td>
<td>R</td>
<td><p>CPR 31to24 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_23_16"></a>23:16</p>
</td>
<td>FIFO_MODE</td>
<td>R</td>
<td><p>Encoding of FIFO_MODE configuration parameter value.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (FIFO_MODE_0): FIFO mode is 0</li><li>0x1 (FIFO_MODE_16): FIFO mode is 16</li><li>0x2 (FIFO_MODE_32): FIFO mode is 32</li><li>0x4 (FIFO_MODE_64): FIFO mode is 64</li><li>0x8 (FIFO_MODE_128): FIFO mode is 128</li><li>0x10 (FIFO_MODE_256): FIFO mode is 256</li><li>0x20 (FIFO_MODE_512): FIFO mode is 512</li><li>0x40 (FIFO_MODE_1024): FIFO mode is 1024</li><li>0x80 (FIFO_MODE_2048): FIFO mode is 2048</li></ul><p></p>
<p>Value After Reset:0x4</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_15_14"></a>15:14</p>
</td>
<td>RSVD_CPR_15to14</td>
<td>R</td>
<td><p>CPR 15to14 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_13"></a>13</p>
</td>
<td>DMA_EXTRA</td>
<td>R</td>
<td><p>Encoding of DMA_EXTRA configuration parameter value.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): DMA_EXTRA disabled</li><li>0x1 (ENABLED): DMA_EXTRA enabled</li></ul><p></p>
<p>Value After Reset:0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_12"></a>12</p>
</td>
<td>UART_ADD_ENCODED_PARAMS</td>
<td>R</td>
<td><p>Encoding of UART_ADD_ENCODED_PARAMS configuration parameter value.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): UART_ADD_ENCODED_PARAMS disabled</li><li>0x1 (ENABLED): UART_ADD_ENCODED_PARAMS enabled</li></ul><p></p>
<p>Value After Reset:0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_11"></a>11</p>
</td>
<td>SHADOW</td>
<td>R</td>
<td><p>Encoding of SHADOW configuration parameter value.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): SHADOW disabled</li><li>0x1 (ENABLED): SHADOW enabled</li></ul><p></p>
<p>Value After Reset:0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_10"></a>10</p>
</td>
<td>FIFO_STAT</td>
<td>R</td>
<td><p>Encoding of FIFO_STAT configuration parameter value.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): FIFO_STAT disabled</li><li>0x1 (ENABLED): FIFO_STAT enabled</li></ul><p></p>
<p>Value After Reset:0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_9"></a>9</p>
</td>
<td>FIFO_ACCESS</td>
<td>R</td>
<td><p>Encoding of FIFO_ACCESS configuration parameter value.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): FIFO_ACCESS disabled</li><li>0x1 (ENABLED): FIFO ACCESS enabled</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_8"></a>8</p>
</td>
<td>ADDITIONAL_FEAT</td>
<td>R</td>
<td><p>Encoding of ADDITIONAL_FEATURES configuration parameter value.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): Additional features disabled</li><li>0x1 (ENABLED): Additional features enabled</li></ul><p></p>
<p>Value After Reset:0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_7"></a>7</p>
</td>
<td>SIR_LP_MODE</td>
<td>R</td>
<td><p>Encoding of SIR_LP_MODE configuration parameter value.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): SIR_LP mode disabled</li><li>0x1 (ENABLED): SIR_LP mode enabled</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_6"></a>6</p>
</td>
<td>SIR_MODE</td>
<td>R</td>
<td><p>Encoding of SIR_MODE configuration parameter value.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): SIR mode disabled</li><li>0x1 (ENABLED): SIR mode enabled</li></ul><p></p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_5"></a>5</p>
</td>
<td>THRE_MODE</td>
<td>R</td>
<td><p>Encoding of THRE_MODE configuration parameter value.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): THRE mode disabled</li><li>0x1 (ENABLED): THRE mode enabled</li></ul><p></p>
<p>Value After Reset:0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_4"></a>4</p>
</td>
<td>AFCE_MODE</td>
<td>R</td>
<td><p>Encoding of AFCE_MODE configuration parameter value.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (DISABLED): AFCE mode disabled</li><li>0x1 (ENABLED): AFCE mode enabled</li></ul><p></p>
<p>Value After Reset:0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_3_2"></a>3:2</p>
</td>
<td>RSVD_CPR_3to2</td>
<td>R</td>
<td><p>CPR 3to2 Reserved bits read as 0.</p>
<p>Value After Reset:0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CPR_F_1_0"></a>1:0</p>
</td>
<td>APB_DATA_WIDTH</td>
<td>R</td>
<td><p>Encoding of APB_DATA_WIDTH configuration parameter value.</p>
<p class="BLANK"></p>
<p>Values:</p>
<ul><li>0x0 (APB_8BITS): APB data width is 8 bits</li><li>0x1 (APB_16BITS): APB data width is 16 bits</li><li>0x2 (APB_32BITS): APB data width is 32 bits</li></ul><p></p>
<p>Value After Reset:0x2</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_UCV"></a>UCV</p>
<ul><li>Name:UART Component Version</li><li>Description:UCV register is valid only when the DW_apb_uart is configured to have additional features implemented (ADDITIONAL_FEATURES = YES). If additional features are not implemented, this register does not exist and reading from this register address returns 0.</li><li>Size:32 bits</li><li>Offset:0xf8</li></ul><a name="fld-uart_memory_map_uart_address_block_UCV"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_UCV_F_31_0">31:0</a></td>
</tr>
<tr><td>UART_Component_Version</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_UCV"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: UCV</p>
<table summary="Fields for Register: UCV" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_UCV_F_31_0"></a>31:0</p>
</td>
<td>UART_Component_Version</td>
<td>R</td>
<td><p>ASCII value for each number in the version, followed by *.
For example 32_30_31_2A represents the version 2.01*</p>
<p>Value After Reset:0x3430342a</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-uart_memory_map_uart_address_block_CTR"></a>CTR</p>
<ul><li>Name:Component Type Register</li><li>Description:CTR is register is valid only when the DW_apb_uart is configured to have additional features implemented (ADDITIONAL_FEATURES = YES). If additional features are not implemented, this register does not exist and reading from this register address returns 0.</li><li>Size:32 bits</li><li>Offset:0xfc</li></ul><a name="fld-uart_memory_map_uart_address_block_CTR"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-uart_memory_map_uart_address_block_CTR_F_31_0">31:0</a></td>
</tr>
<tr><td>Peripheral_ID</td>
</tr>
</tbody></table><a name="fieldtable-uart_memory_map_uart_address_block_CTR"></a><p class="tableTitle" MadCap:autonum="Table 1. ">Fields for Register: CTR</p>
<table summary="Fields for Register: CTR" width="100%"><colgroup></colgroup><thead><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr></thead><tbody><tr><td><p><a name="H4-reg-uart_memory_map_uart_address_block_CTR_F_31_0"></a>31:0</p>
</td>
<td>Peripheral_ID</td>
<td>R</td>
<td><p>This register contains the peripherals identification code.</p>
<p>Value After Reset:0x44570110</p>
</td>
</tr>
</tbody></table></body></html>

