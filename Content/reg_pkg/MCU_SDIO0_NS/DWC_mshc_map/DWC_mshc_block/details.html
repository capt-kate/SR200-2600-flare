<?xml version="1.0" encoding="utf-8"?><html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd"><head><meta http-equiv="Content-Type" content="text/html; charset="ISO-8859-1""><title>Register Details</title></head>
<body>
<h2 class="title"><a name="idp51170680"></a>Register Details</h2>
<hr><hr><h2 class="title"><a name="H3-sect1-reg-DWC_mshc_map_DWC_mshc_block"></a>DWC_mshc_block Register Details</h2>
<p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_SDMASA_R"></a><span>SDMASA_R</span></p>
<ul><li><span>Name:</span>SDMA System Address register</li><li><span>Description:</span>This register is used to configure a 32-bit Block Count or an SDMA System Address based on the Host Version 4 Enable bit in the Host Control 2 register. This register is applicable for both SD and eMMC modes.</li><li><span>Size:</span>32 bits</li><li><span>Offset:</span>0x0</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_SDMASA_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_SDMASA_R_F_31_0">31:0</a></td>
</tr>
<tr><td>BLOCKCNT_SDMASA</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_SDMASA_R"></a><p class="title">Table�1.�Fields for Register: SDMASA_R</p>
<table summary="Fields for Register: SDMASA_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_SDMASA_R_F_31_0"></a>31:0</p>
</td>
<td>BLOCKCNT_SDMASA</td>
<td>R/W</td>
<td><p>32-bit Block Count (SDMA System Address)</p>
<ul><li>SDMA System Address (Host Version 4 Enable = 0): This register contains the system memory address for an SDMA transfer in the 32-bit addressing mode. When the Host Controller stops an SDMA
transfer, this register points to the system address of the next contiguous data position. It can be accessed only if no transaction is executing. Reading this register during data transfers may</li></ul><p>return an invalid value.</p>
<ul><li>32-bit Block Count (Host Version 4 Enable = 1): From the Host Controller Version 4.10 specification, this register is redefined as 32-bit Block Count. The Host Controller decrements the block count of this register for every block transfer and the data transfer stops when the count reaches zero. This register must be accessed when no transaction is executing. Reading this register during data transfers may return invalid value.</li></ul><p>Following are the values for BLOCKCNT_SDMASA:</p>
<ul><li>0xFFFF_FFFF: 4G - 1 Block</li><li>...</li><li>0x0000_0002: 2 Blocks</li><li>0x0000_0001: 1 Block</li><li>0x0000_0000: Stop Count</li></ul><p><span>Note</span>:</p>
<ul><li>For Host Version 4 Enable = 0, the Host driver does not program the system address in this register while operating in ADMA mode. The system address must be programmed in the ADMA System Address register.</li><li>For Host Version 4 Enable = 0, the Host driver programs a non-zero 32-bit block count value in this register when Auto CMD23 is enabled for non-DMA and ADMA modes. Auto CMD23 cannot be used with SDMA.</li><li>This register must be programmed with a non-zero value for data transfer if the 32-bit Block count register is used instead of the 16-bit Block count register.</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BLOCKSIZE_R"></a><span>BLOCKSIZE_R</span></p>
<ul><li><span>Name:</span>Block Size register</li><li><span>Description:</span>This register is used to configure an SDMA buffer boundary and the number of bytes in a data block. This register is applicable for both SD and eMMC modes.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x4</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_BLOCKSIZE_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_BLOCKSIZE_R_F_15">15</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_BLOCKSIZE_R_F_14_12">14:12</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_BLOCKSIZE_R_F_11_0">11:0</a></td>
</tr>
<tr><td>RSVD_BLOCKSIZE15</td>
<td>SDMA_BUF_BDARY</td>
<td>XFER_BLOCK_SIZE</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_BLOCKSIZE_R"></a><p class="title">Table�2.�Fields for Register: BLOCKSIZE_R</p>
<table summary="Fields for Register: BLOCKSIZE_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BLOCKSIZE_R_F_15"></a>15</p>
</td>
<td>RSVD_BLOCKSIZE15</td>
<td>R</td>
<td><p>This bit of the BLOCKSIZE_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BLOCKSIZE_R_F_14_12"></a>14:12</p>
</td>
<td>SDMA_BUF_BDARY</td>
<td>R/W</td>
<td><p>SDMA Buffer Boundary</p>
<p class="BLANK"></p>
<p>These bits specify the size of contiguous buffer in system memory. The SDMA transfer waits at every boundary specified by these fields and the Host Controller generates the DMA interrupt to request the Host Driver to update the SDMA System Address register.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (BYTES_4K): 4K bytes SDMA Buffer Boundary</li><li>0x1 (BYTES_8K): 8K bytes SDMA Buffer Boundary</li><li>0x2 (BYTES_16K): 16K bytes SDMA Buffer Boundary</li><li>0x3 (BYTES_32K): 32K bytes SDMA Buffer Boundary</li><li>0x4 (BYTES_64K): 64K bytes SDMA Buffer Boundary</li><li>0x5 (BYTES_128K): 128K bytes SDMA Buffer Boundary</li><li>0x6 (BYTES_256K): 256K bytes SDMA Buffer Boundary</li><li>0x7 (BYTES_512K): 512K bytes SDMA Buffer Boundary</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BLOCKSIZE_R_F_11_0"></a>11:0</p>
</td>
<td>XFER_BLOCK_SIZE</td>
<td>R/W</td>
<td><p>Transfer Block Size</p>
<p class="BLANK"></p>
<p>These bits specify the block size of data transfers. In case of memory, it is set to 512 bytes. It can be accessed only if no transaction is executing. Read operations during transfers may return
an invalid value, and write operations are ignored.
Following are the values for XFER_BLOCK_SIZE:</p>
<ul><li>0x1: 1 byte</li><li>0x2: 2 bytes</li><li>0x3: 3 bytes</li><li>......</li><li>0x1FF: 511 byte</li><li>0x200: 512 bytes</li><li>......</li><li>0x800: 2048 bytes</li></ul><p><span><em><span>Note</span></em></span>: This register must be programmed with a non-zero value for data transfer.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BLOCKCOUNT_R"></a><span>BLOCKCOUNT_R</span></p>
<ul><li><span>Name:</span>16-bit Block Count register</li><li><span>Description:</span>This register is used to configure the number of data blocks. This register is applicable for both SD and eMMC modes.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x6</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_BLOCKCOUNT_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_BLOCKCOUNT_R_F_15_0">15:0</a></td>
</tr>
<tr><td>BLOCK_CNT</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_BLOCKCOUNT_R"></a><p class="title">Table�3.�Fields for Register: BLOCKCOUNT_R</p>
<table summary="Fields for Register: BLOCKCOUNT_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BLOCKCOUNT_R_F_15_0"></a>15:0</p>
</td>
<td>BLOCK_CNT</td>
<td>R/W</td>
<td><p>16-bit Block Count</p>
<ul><li>If the Host Version 4 Enable bit is set 0 or the 16-bit Block Count register is set to non-zero, the 16-bit Block Count register is selected.</li><li>If the Host Version 4 Enable bit is set 1 and the 16-bit Block Count register is set to zero, the 32-bit Block Count register is selected.</li></ul><p>Following are the values for BLOCK_CNT:</p>
<ul><li>0x0: Stop Count</li><li>0x1: 1 Block</li><li>0x2: 2 Blocks</li><li>... - ...</li><li>0xFFFF: 65535 Blocks</li></ul><p><span><em><span>Note</span></em></span>: For Host Version 4 Enable = 0, this register must be set to 0000h before programming the 32-bit block count register when Auto CMD23 is enabled for non-DMA and ADMA modes.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ARGUMENT_R"></a><span>ARGUMENT_R</span></p>
<ul><li><span>Name:</span>Argument register</li><li><span>Description:</span>This register is used to configure the SD/eMMC command argument.</li><li><span>Size:</span>32 bits</li><li><span>Offset:</span>0x8</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_ARGUMENT_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ARGUMENT_R_F_31_0">31:0</a></td>
</tr>
<tr><td>ARGUMENT</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_ARGUMENT_R"></a><p class="title">Table�4.�Fields for Register: ARGUMENT_R</p>
<table summary="Fields for Register: ARGUMENT_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ARGUMENT_R_F_31_0"></a>31:0</p>
</td>
<td>ARGUMENT</td>
<td>R/W</td>
<td><p>Command Argument</p>
<p class="BLANK"></p>
<p>These bits specify the SD/eMMC command argument that is specified in bits 39-8 of the Command format.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R"></a><span>XFER_MODE_R</span></p>
<ul><li><span>Name:</span>Transfer Mode register</li><li><span>Description:</span>This register is used to control the operation of data transfers for an SD/eMMC mode. The Host driver sets this register before issuing a command that transfers data.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0xc</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_15_9">15:9</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_8">8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_3_2">3:2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_0">0</a></td>
</tr>
<tr><td>RSVD</td>
<td>RESP_INT_DISABLE</td>
<td>RESP_ERR_CHK_ENABLE</td>
<td>RESP_TYPE</td>
<td>MULTI_BLK_SEL</td>
<td>DATA_XFER_DIR</td>
<td>AUTO_CMD_ENABLE</td>
<td>BLOCK_COUNT_ENABLE</td>
<td>DMA_ENABLE</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R"></a><p class="title">Table�5.�Fields for Register: XFER_MODE_R</p>
<table summary="Fields for Register: XFER_MODE_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_15_9"></a>15:9</p>
</td>
<td>RSVD</td>
<td>R</td>
<td><p>These bits of the XFER_MODE_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_8"></a>8</p>
</td>
<td>RESP_INT_DISABLE</td>
<td>R/W</td>
<td><p>Response Interrupt Disable</p>
<p class="BLANK"></p>
<p>The Host Controller supports response check function to avoid overhead of response error check by the Host driver. Response types of only R1 and R5 can be checked by the Controller.</p>
<p class="BLANK"></p>
<p>If Host Driver checks the response error, set this bit to 0 and wait for Command Complete Interrupt and then check
the response register.</p>
<p class="BLANK"></p>
<p>If the Host Controller checks the response error, set this bit to 1 and set the Response Error Check Enable bit to 1. The Command Complete Interrupt is disabled by this bit
regardless of the Command Complete Signal Enable.</p>
<p class="BLANK"></p>
<p><span><em><span>Note</span></em></span>: During tuning (when the Execute Tuning bit in the Host Control2 register is set), the Command Complete Interrupt is not generated irrespective of the Response Interrupt Disable setting.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (ENABLED): Response Interrupt is enabled</li><li>0x1 (DISABLED): Response Interrupt is disabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_7"></a>7</p>
</td>
<td>RESP_ERR_CHK_ENABLE</td>
<td>R/W</td>
<td><p>Response Error Check Enable</p>
<p class="BLANK"></p>
<p>The Host Controller supports response check function to avoid overhead of response error check by Host driver. Response types of only R1 and R5 can be checked by the Controller.
If the Host Controller checks the response error, set this bit to 1 and set Response Interrupt Disable to 1. If an error is detected, the Response Error interrupt is generated in the Error Interrupt Status register.</p>
<p class="BLANK"></p>
<p><span><em><span>Note</span></em></span>:</p>
<ul><li>Response error check must not be enabled for any response type other than R1 and R5.</li><li>Response check must not be enabled for the tuning command.</li></ul><p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (DISABLED): Response Error Check is disabled</li><li>0x1 (ENABLED): Response Error Check is enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_6"></a>6</p>
</td>
<td>RESP_TYPE</td>
<td>R/W</td>
<td><p>Response Type R1/R5</p>
<p class="BLANK"></p>
<p>This bit selects either R1 or R5 as a response type when the Response Error Check is selected.</p>
<p class="BLANK"></p>
<p>Error statuses checked in R1:</p>
<ul><li>OUT_OF_RANGE</li><li>ADDRESS_ERROR</li><li>BLOCK_LEN_ERROR</li><li>WP_VIOLATION</li><li>CARD_IS_LOCKED</li><li>COM_CRC_ERROR</li><li>CARD_ECC_FAILED</li><li>CC_ERROR</li><li>ERROR</li></ul><p>Response Flags checked in R5:</p>
<ul><li>COM_CRC_ERROR</li><li>ERROR</li><li>FUNCTION_NUMBER</li><li>OUT_OF_RANGE</li></ul><p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (RESP_R1): R1 (Memory)</li><li>0x1 (RESP_R5): R5 (SDIO)</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_5"></a>5</p>
</td>
<td>MULTI_BLK_SEL</td>
<td>R/W</td>
<td><p>Multi/Single Block Select</p>
<p class="BLANK"></p>
<p>This bit is set when issuing multiple-block transfer commands using the DAT line. If this bit is set to 0, it is not necessary to set the Block Count register.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (SINGLE): Single Block</li><li>0x1 (MULTI): Multiple Block</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_4"></a>4</p>
</td>
<td>DATA_XFER_DIR</td>
<td>R/W</td>
<td><p>Data Transfer Direction Select</p>
<p class="BLANK"></p>
<p>This bit defines the direction of DAT line data transfers. This bit is set to 1 by the Host Driver to transfer data
from the SD/eMMC card to the Host Controller and it is set to 0 for all other commands.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (READ): Read (Card to Host)</li><li>0x0 (WRITE): Write (Host to Card)</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_3_2"></a>3:2</p>
</td>
<td>AUTO_CMD_ENABLE</td>
<td>R/W</td>
<td><p>Auto Command Enable</p>
<p class="BLANK"></p>
<p>This field determines use of Auto Command functions.</p>
<p class="BLANK"></p>
<p><span><em><span>Note</span></em></span>: In SDIO, this field must be set as 00b (Auto Command Disabled).</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (AUTO_CMD_DISABLED): Auto Command Disabled</li><li>0x1 (AUTO_CMD12_ENABLED): Auto CMD12 Enable</li><li>0x2 (AUTO_CMD23_ENABLED): Auto CMD23 Enable</li><li>0x3 (AUTO_CMD_AUTO_SEL): Auto CMD Auto Select</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_1"></a>1</p>
</td>
<td>BLOCK_COUNT_ENABLE</td>
<td>R/W</td>
<td><p>Block Count Enable</p>
<p class="BLANK"></p>
<p>This bit is used to enable the Block Count register, which is relevant for multiple block transfers.
If this bit is set to 0, the Block Count register is disabled, which is useful in executing an infinite transfer.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (ENABLED): Enable</li><li>0x0 (DISABLED): Disable</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_XFER_MODE_R_F_0"></a>0</p>
</td>
<td>DMA_ENABLE</td>
<td>R/W</td>
<td><p>DMA Enable</p>
<p class="BLANK"></p>
<p>This bit enables the DMA functionality. If this bit is set to 1, a DMA operation begins when the Host Driver writes to the Command register. You can select one of the DMA modes by using DMA Select in the Host Control 1 register.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (ENABLED): DMA Data transfer</li><li>0x0 (DISABLED): No data transfer or Non-DMA data transfer</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R"></a><span>CMD_R</span></p>
<ul><li><span>Name:</span>Command register</li><li><span>Description:</span>This register is used to provide the information related to a command and a response packet. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0xe</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_CMD_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_15_14">15:14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_13_8">13:8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_7_6">7:6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_1_0">1:0</a></td>
</tr>
<tr><td>RSVD</td>
<td>CMD_INDEX</td>
<td>CMD_TYPE</td>
<td>DATA_PRESENT_SEL</td>
<td>CMD_IDX_CHK_ENABLE</td>
<td>CMD_CRC_CHK_ENABLE</td>
<td>SUB_CMD_FLAG</td>
<td>RESP_TYPE_SELECT</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_CMD_R"></a><p class="title">Table�6.�Fields for Register: CMD_R</p>
<table summary="Fields for Register: CMD_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_15_14"></a>15:14</p>
</td>
<td>RSVD</td>
<td>R</td>
<td><p>These bits of the CMD_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_13_8"></a>13:8</p>
</td>
<td>CMD_INDEX</td>
<td>R/W</td>
<td><p>Command Index</p>
<p class="BLANK"></p>
<p>These bits are set to the command number that is specified in bits 45-40 of the Command Format.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_7_6"></a>7:6</p>
</td>
<td>CMD_TYPE</td>
<td>R/W</td>
<td><p>Command Type</p>
<p class="BLANK"></p>
<p>These bits indicate the command type.</p>
<p class="BLANK"></p>
<p><span>Note:</span>While issuing Abort CMD using CMD12/CMD52 or reset CMD using CMD0/CMD52, CMD_TYPE field shall be set to 0x3. In case CMD0 is used for initialization set as 0x0</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x3 (ABORT_CMD): Abort</li><li>0x2 (RESUME_CMD): Resume</li><li>0x1 (SUSPEND_CMD): Suspend</li><li>0x0 (NORMAL_CMD): Normal</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_5"></a>5</p>
</td>
<td>DATA_PRESENT_SEL</td>
<td>R/W</td>
<td><p>Data Present Select</p>
<p class="BLANK"></p>
<p>This bit is set to 1 to indicate that data is present and that the data is transferred using the DAT line.
This bit is set to 0 in the following instances:</p>
<ul><li>Command using the CMD line</li><li>Command with no data transfer but using busy signal on the DAT[0] line</li><li>Resume Command</li></ul><p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (NO_DATA): No Data Present</li><li>0x1 (DATA): Data Present</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_4"></a>4</p>
</td>
<td>CMD_IDX_CHK_ENABLE</td>
<td>R/W</td>
<td><p>Command Index Check Enable</p>
<p class="BLANK"></p>
<p>This bit enables the Host Controller to check the index field in the response to verify if it has the same value as the command index. If the value is not the same, it is reported as a Command Index error.</p>
<p class="BLANK"></p>
<p><span><em><span>Note</span></em></span>:</p>
<ul><li>Index Check enable must be set to 0 for the command with no response, R2 response, R3 response and R4 response.</li><li>For the tuning command, this bit must always be set to enable the index check.</li></ul><p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (DISABLED): Disable</li><li>0x1 (ENABLED): Enable</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_3"></a>3</p>
</td>
<td>CMD_CRC_CHK_ENABLE</td>
<td>R/W</td>
<td><p>Command CRC Check Enable</p>
<p class="BLANK"></p>
<p>This bit enables the Host Controller to check the CRC field in the response. If an error is detected, it is reported as a Command CRC error.</p>
<p class="BLANK"></p>
<p><span><em><span>Note</span></em></span>:</p>
<ul><li>CRC Check enable must be set to 0 for the command with no response, R3 response, and R4 response.</li><li>For the tuning command, this bit must always be set to 1 to enable the CRC check.</li></ul><p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (DISABLED): Disable</li><li>0x1 (ENABLED): Enable</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_2"></a>2</p>
</td>
<td>SUB_CMD_FLAG</td>
<td>R/W</td>
<td><p>Sub Command Flag</p>
<p class="BLANK"></p>
<p>This bit distinguishes between a main command and a sub command.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (MAIN): Main Command</li><li>0x1 (SUB): Sub Command</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CMD_R_F_1_0"></a>1:0</p>
</td>
<td>RESP_TYPE_SELECT</td>
<td>R/W</td>
<td><p>Response Type Select</p>
<p class="BLANK"></p>
<p>This bit indicates the type of response expected from the card.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (NO_RESP): No Response</li><li>0x1 (RESP_LEN_136): Response Length 136</li><li>0x2 (RESP_LEN_48): Response Length 48</li><li>0x3 (RESP_LEN_48B): Response Length 48; Check Busy after response</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_RESP01_R"></a><span>RESP01_R</span></p>
<ul><li><span>Name:</span>Response Register 0/1</li><li><span>Description:</span>This register stores 39-08 bits of the Response Field for an SD/eMMC mode. The response for an SD/eMMC command can be a maximum of 128 bits. These 128 bits are segregated into four 32-bit registers: RESP01_R, RESP23_R, RESP45_R and RESP67_R.</li><li><span>Size:</span>32 bits</li><li><span>Offset:</span>0x10</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_RESP01_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_RESP01_R_F_31_0">31:0</a></td>
</tr>
<tr><td>RESP01</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_RESP01_R"></a><p class="title">Table�7.�Fields for Register: RESP01_R</p>
<table summary="Fields for Register: RESP01_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_RESP01_R_F_31_0"></a>31:0</p>
</td>
<td>RESP01</td>
<td>R</td>
<td><p>Command Response</p>
<p class="BLANK"></p>
<p>These bits reflect 39-8 bits of SD/eMMC Response Field.</p>
<p class="BLANK"></p>
<p><span><em><span>Note</span></em></span>: For Auto CMD, the 32-bit response (bits 39-8 of the Response Field) is updated in the RESP67_R register.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_RESP23_R"></a><span>RESP23_R</span></p>
<ul><li><span>Name:</span>Response Register 2/3</li><li><span>Description:</span>This register stores 71-40 bits of the Response Field for an SD/eMMC mode. This register is used to store the response from the cards. The response can be a maximum of 128 bits. These 128 bits are segregated into four 32-bit
registers: RESP01_R, RESP23_R, RESP45_R and RESP67_R.</li><li><span>Size:</span>32 bits</li><li><span>Offset:</span>0x14</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_RESP23_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_RESP23_R_F_31_0">31:0</a></td>
</tr>
<tr><td>RESP23</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_RESP23_R"></a><p class="title">Table�8.�Fields for Register: RESP23_R</p>
<table summary="Fields for Register: RESP23_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_RESP23_R_F_31_0"></a>31:0</p>
</td>
<td>RESP23</td>
<td>R</td>
<td><p>Command Response</p>
<p class="BLANK"></p>
<p>These bits reflect 71-40 bits of the SD/eMMC Response Field.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_RESP45_R"></a><span>RESP45_R</span></p>
<ul><li><span>Name:</span>Response Register 4/5</li><li><span>Description:</span>This register stores 103-72 bits of the Response Field for an SD/eMMC mode. The response for SD/eMMC command can be a maximum of 128 bits. These 128 bits are segregated into four 32-bit registers: RESP01_R, RESP23_R, RESP45_R and RESP67_R.</li><li><span>Size:</span>32 bits</li><li><span>Offset:</span>0x18</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_RESP45_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_RESP45_R_F_31_0">31:0</a></td>
</tr>
<tr><td>RESP45</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_RESP45_R"></a><p class="title">Table�9.�Fields for Register: RESP45_R</p>
<table summary="Fields for Register: RESP45_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_RESP45_R_F_31_0"></a>31:0</p>
</td>
<td>RESP45</td>
<td>R</td>
<td><p>Command Response</p>
<p class="BLANK"></p>
<p>These bits reflect 103-72 bits of the Response Field.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_RESP67_R"></a><span>RESP67_R</span></p>
<ul><li><span>Name:</span>Response Register 6/7</li><li><span>Description:</span>This register stores 135-104 bits of the Response Field for an SD/eMMC mode. The SD/eMMC response can be a maximum of 128 bits. These 128 bits are segregated into four 32-bit registers: RESP01_R, RESP23_R, RESP45_R and RESP67_R.</li><li><span>Size:</span>32 bits</li><li><span>Offset:</span>0x1c</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_RESP67_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_RESP67_R_F_31_0">31:0</a></td>
</tr>
<tr><td>RESP67</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_RESP67_R"></a><p class="title">Table�10.�Fields for Register: RESP67_R</p>
<table summary="Fields for Register: RESP67_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_RESP67_R_F_31_0"></a>31:0</p>
</td>
<td>RESP67</td>
<td>R</td>
<td><p>Command Response</p>
<p class="BLANK"></p>
<p>These bits reflect bits 135-104 of SD/EMMC Response Field.</p>
<p class="BLANK"></p>
<p><span><em><span>Note</span></em></span>: For Auto CMD, this register also reflects the 32-bit response (bits 39-8 of the Response Field).</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BUF_DATA_R"></a><span>BUF_DATA_R</span></p>
<ul><li><span>Name:</span>Buffer Data Port Register</li><li><span>Description:</span>This register is used to access the packet buffer. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>32 bits</li><li><span>Offset:</span>0x20</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_BUF_DATA_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_BUF_DATA_R_F_31_0">31:0</a></td>
</tr>
<tr><td>BUF_DATA</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_BUF_DATA_R"></a><p class="title">Table�11.�Fields for Register: BUF_DATA_R</p>
<table summary="Fields for Register: BUF_DATA_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BUF_DATA_R_F_31_0"></a>31:0</p>
</td>
<td>BUF_DATA</td>
<td>R/W</td>
<td><p>Buffer Data</p>
<p class="BLANK"></p>
<p>These bits enable access to the Host Controller packet buffer.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG"></a><span>PSTATE_REG</span></p>
<ul><li><span>Name:</span>Present State Register</li><li><span>Description:</span>This register indicates the present status of the Host Controller. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>32 bits</li><li><span>Offset:</span>0x24</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_PSTATE_REG"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_31">31</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_30">30</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_29">29</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_28">28</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_27">27</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_26">26</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_25">25</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_24">24</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_23_20">23:20</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_19">19</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_18">18</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_17">17</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_16">16</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_15_12">15:12</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_11">11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_9">9</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_8">8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_7_4">7:4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_0">0</a></td>
</tr>
<tr><td>UHS2_IF_DETECT</td>
<td>LANE_SYNC</td>
<td>IN_DORMANT_ST</td>
<td>SUB_CMD_STAT</td>
<td>CMD_ISSUE_ERR</td>
<td>RSVD_26</td>
<td>HOST_REG_VOL</td>
<td>CMD_LINE_LVL</td>
<td>DAT_3_0</td>
<td>WR_PROTECT_SW_LVL</td>
<td>CARD_DETECT_PIN_LEVEL</td>
<td>CARD_STABLE</td>
<td>CARD_INSERTED</td>
<td>RSVD_15_12</td>
<td>BUF_RD_ENABLE</td>
<td>BUF_WR_ENABLE</td>
<td>RD_XFER_ACTIVE</td>
<td>WR_XFER_ACTIVE</td>
<td>DAT_7_4</td>
<td>RE_TUNE_REQ</td>
<td>DAT_LINE_ACTIVE</td>
<td>CMD_INHIBIT_DAT</td>
<td>CMD_INHIBIT</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_PSTATE_REG"></a><p class="title">Table�12.�Fields for Register: PSTATE_REG</p>
<table summary="Fields for Register: PSTATE_REG" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_31"></a>31</p>
</td>
<td>UHS2_IF_DETECT</td>
<td>R</td>
<td><p>UHS-II Interface Detection</p>
<p class="BLANK"></p>
<p>This bit will always be 0 as UHS-II is not supported.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): UHS-II interface is not detected</li><li>0x1 (TRUE): UHS-II interface is detected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_30"></a>30</p>
</td>
<td>LANE_SYNC</td>
<td>R</td>
<td><p>Lane Synchronization</p>
<p class="BLANK"></p>
<p>This bit will always be 0 as UHS-II is not supported.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): UHS-II PHY is not initialized</li><li>0x1 (TRUE): UHS-II PHY is initialized</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_29"></a>29</p>
</td>
<td>IN_DORMANT_ST</td>
<td>R</td>
<td><p>In Dormant Status</p>
<p class="BLANK"></p>
<p>This bit will always be 0 as UHS-II is not supported.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not in DORMANT state</li><li>0x1 (TRUE): In DORMANT state</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_28"></a>28</p>
</td>
<td>SUB_CMD_STAT</td>
<td>R</td>
<td><p>Sub Command Status</p>
<p class="BLANK"></p>
<p>This bit is used to distinguish between a main command and a sub command status.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Main Command Status</li><li>0x1 (TRUE): Sub Command Status</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_27"></a>27</p>
</td>
<td>CMD_ISSUE_ERR</td>
<td>R</td>
<td><p>Command Not Issued by Error</p>
<p class="BLANK"></p>
<p>This bit is set if a command cannot be issued after setting the command register due to an error except the Auto CMD12 error.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error for issuing a command</li><li>0x1 (TRUE): Command cannot be issued</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_26"></a>26</p>
</td>
<td>RSVD_26</td>
<td>R</td>
<td><p>This bit of the PRESENT_ST_R register is reserved bits. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_25"></a>25</p>
</td>
<td>HOST_REG_VOL</td>
<td>R</td>
<td><p>Host Regulator Voltage Stable</p>
<p class="BLANK"></p>
<p>This bit is used to check whether the host regulator voltage is stable for switching the voltage of UHS-I mode. This bit reflects the synchronized value of the<span><em>host_reg_vol_stable</em></span>signal.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Host Regulator Voltage is not stable</li><li>0x1 (TRUE): Host Regulator Voltage is stable</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_24"></a>24</p>
</td>
<td>CMD_LINE_LVL</td>
<td>R</td>
<td><p>Command-Line Signal Level</p>
<p class="BLANK"></p>
<p>This bit is used to check the CMD line level to recover from errors and for debugging. These bits reflect the value of the<span><em>sd_cmd_in</em></span>signal.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_23_20"></a>23:20</p>
</td>
<td>DAT_3_0</td>
<td>R</td>
<td><p>DAT[3:0] Line Signal Level</p>
<p class="BLANK"></p>
<p>This bit is used to check the DAT line level to recover from errors and for debugging. These bits reflect the value of the<span><em>sd_dat_in</em></span>(lower nibble) signal.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_19"></a>19</p>
</td>
<td>WR_PROTECT_SW_LVL</td>
<td>R</td>
<td><p>Write Protect Switch Pin Level</p>
<p class="BLANK"></p>
<p>This bit is supported only for memory and combo cards. This bit reflects the synchronized value of the<span><em>card_write_prot</em></span>signal.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Write protected</li><li>0x1 (TRUE): Write enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_18"></a>18</p>
</td>
<td>CARD_DETECT_PIN_LEVEL</td>
<td>R</td>
<td><p>Card Detect Pin Level</p>
<p class="BLANK"></p>
<p>This bit reflects the inverse synchronized value of the<span><em>card_detect_n</em></span>signal.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No card present</li><li>0x1 (TRUE): Card Present</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_17"></a>17</p>
</td>
<td>CARD_STABLE</td>
<td>R</td>
<td><p>Card Stable</p>
<p class="BLANK"></p>
<p>This bit indicates the stability of the Card Detect Pin Level. A card is not detected if this bit is set to 1 and the value of the CARD_INSERTED bit is 0.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Reset or Debouncing</li><li>0x1 (TRUE): No Card or Inserted</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_16"></a>16</p>
</td>
<td>CARD_INSERTED</td>
<td>R</td>
<td><p>Card Inserted</p>
<p class="BLANK"></p>
<p>This bit indicates whether a card has been inserted. The Host Controller debounces this signal so that Host Driver need not wait for it to stabilize.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Reset, Debouncing, or No card</li><li>0x1 (TRUE): Card Inserted</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_15_12"></a>15:12</p>
</td>
<td>RSVD_15_12</td>
<td>R</td>
<td><p>These bits of the PRESENT_STAT_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_11"></a>11</p>
</td>
<td>BUF_RD_ENABLE</td>
<td>R</td>
<td><p>Buffer Read Enable</p>
<p class="BLANK"></p>
<p>This bit is used for non-DMA transfers. This bit is set if valid data exists in the Host buffer.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (DISABLED): Read disable</li><li>0x1 (ENABLED): Read enable</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_10"></a>10</p>
</td>
<td>BUF_WR_ENABLE</td>
<td>R</td>
<td><p>Buffer Write Enable</p>
<p class="BLANK"></p>
<p>This bit is used for non-DMA transfers. This bit is set if space is available for writing data.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (DISABLED): Write disable</li><li>0x1 (ENABLED): Write enable</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_9"></a>9</p>
</td>
<td>RD_XFER_ACTIVE</td>
<td>R</td>
<td><p>Read Transfer Active</p>
<p class="BLANK"></p>
<p>This bit indicates whether a read transfer is active for SD/eMMC mode.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (INACTIVE): No valid data</li><li>0x1 (ACTIVE): Transferring data</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_8"></a>8</p>
</td>
<td>WR_XFER_ACTIVE</td>
<td>R</td>
<td><p>Write Transfer Active</p>
<p class="BLANK"></p>
<p>This status indicates whether a write transfer is active for SD/eMMC mode.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (INACTIVE): No valid data</li><li>0x1 (ACTIVE): Transferring data</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_7_4"></a>7:4</p>
</td>
<td>DAT_7_4</td>
<td>R</td>
<td><p>DAT[7:4] Line Signal Level</p>
<p class="BLANK"></p>
<p>This bit is used to check the DAT line level to recover from errors and for debugging. These bits reflect the value of the<span><em>sd_dat_in</em></span>(upper nibble) signal.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_3"></a>3</p>
</td>
<td>RE_TUNE_REQ</td>
<td>R</td>
<td><p>Re-Tuning Request</p>
<p class="BLANK"></p>
<p>DWC_mshc does not generate retuning request. The software must maintain the Retuning timer.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_2"></a>2</p>
</td>
<td>DAT_LINE_ACTIVE</td>
<td>R</td>
<td><p>DAT Line Active (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p>This bit indicates whether one of the DAT lines on the SD/eMMC bus is in use.</p>
<p class="BLANK"></p>
<p class="BLANK"></p>
<p>In the case of read transactions, this bit indicates whether a read transfer is executing on the SD/eMMC bus.</p>
<p class="BLANK"></p>
<p>In the case of write transactions, this bit indicates whether a write transfer is executing on the SD/eMMC bus.</p>
<p class="BLANK"></p>
<p>For a command with busy, this status indicates whether the command executing busy is executing on an SD or eMMC bus.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (INACTIVE): DAT Line Inactive</li><li>0x1 (ACTIVE): DAT Line Active</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_1"></a>1</p>
</td>
<td>CMD_INHIBIT_DAT</td>
<td>R</td>
<td><p>Command Inhibit (DAT)</p>
<p class="BLANK"></p>
<p class="BLANK"></p>
<p>This bit is applicable for SD/eMMC mode and is generated if either DAT line active or Read transfer active is set to 1.
If this bit is set to 0, it indicates that the Host Controller can issue subsequent SD/eMMC commands.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (READY): Can issue command which used DAT line</li><li>0x1 (NOT_READY): Cannot issue command which used DAT line</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PSTATE_REG_F_0"></a>0</p>
</td>
<td>CMD_INHIBIT</td>
<td>R</td>
<td><p>Command Inhibit (CMD)</p>
<p class="BLANK"></p>
<p>This bit indicates the following :</p>
<p class="BLANK"></p>
<ul><li>SD/eMMC mode: If this bit is set to 0, it indicates that the CMD line is not in use and the Host controller can issue an SD/eMMC command using the CMD line. This bit is set when the command register is written. This bit is cleared when the command response is received. This bit is not cleared by the response of auto CMD12/23 but cleared by the response of read/write command.</li></ul><p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (READY): Host Controller is ready to issue a command</li><li>0x1 (NOT_READY): Host Controller is not ready to issue a command</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R"></a><span>HOST_CTRL1_R</span></p>
<ul><li><span>Name:</span>Host Control 1 Register</li><li><span>Description:</span>This register is used to control the operation of the Host Controller. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>8 bits</li><li><span>Offset:</span>0x28</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_4_3">4:3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_0">0</a></td>
</tr>
<tr><td>CARD_DETECT_SIG_SEL</td>
<td>CARD_DETECT_TEST_LVL</td>
<td>EXT_DAT_XFER</td>
<td>DMA_SEL</td>
<td>HIGH_SPEED_EN</td>
<td>DAT_XFER_WIDTH</td>
<td>LED_CTRL</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R"></a><p class="title">Table�13.�Fields for Register: HOST_CTRL1_R</p>
<table summary="Fields for Register: HOST_CTRL1_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_7"></a>7</p>
</td>
<td>CARD_DETECT_SIG_SEL</td>
<td>R/W</td>
<td><p>Card Detect Signal Selection</p>
<p class="BLANK"></p>
<p>This bit selects a source for card detection. When the source for the card detection is switched, the interrupt must be disabled during the switching period.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (CARD_DT_TEST_LEVEL): Card Detect Test Level is selected (for test purpose)</li><li>0x0 (SDCD_PIN): SDCD# (card_detect_n signal) is selected (for normal use)</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_6"></a>6</p>
</td>
<td>CARD_DETECT_TEST_LVL</td>
<td>R/W</td>
<td><p>Card Detect Test Level</p>
<p class="BLANK"></p>
<p>This bit is enabled while the Card Detect Signal Selection is set to 1 and it indicates whether a card inserted or not.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (CARD_INSERTED): Card Inserted</li><li>0x0 (No_CARD): No Card</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_5"></a>5</p>
</td>
<td>EXT_DAT_XFER</td>
<td>R/W</td>
<td><p>Extended Data Transfer Width</p>
<p class="BLANK"></p>
<p>This bit controls 8-bit bus width mode of embedded device.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (EIGHT_BIT): 8-bit Bus Width</li><li>0x0 (DEFAULT): Bus Width is selected by the Data Transfer Width</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_4_3"></a>4:3</p>
</td>
<td>DMA_SEL</td>
<td>R/W</td>
<td><p>DMA Select</p>
<p class="BLANK"></p>
<p>This field is used to select the DMA type.</p>
<p class="BLANK"></p>
<p>When Host Version 4 Enable is 1 in Host Control 2 register:</p>
<ul><li>0x0 : SDMA is selected</li><li>0x1 : Reserved</li><li>0x2 : ADMA2 is selected</li><li>0x3 : ADMA2 or ADMA3 is selected</li></ul><p></p>
<p class="BLANK"></p>
<p>When Host Version 4 Enable is 0 in Host Control 2 register:</p>
<ul><li>0x0 : SDMA is selected</li><li>0x1 : Reserved</li><li>0x2 : 32-bit Address ADMA2 is selected</li><li>0x3 : 64-bit Address ADMA2 is selected</li></ul><p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (SDMA): SDMA is selected</li><li>0x1 (RSVD_BIT): Reserved</li><li>0x2 (ADMA2): ADMA2 is selected</li><li>0x3 (ADMA2_3): ADMA2 or ADMA3 is selected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_2"></a>2</p>
</td>
<td>HIGH_SPEED_EN</td>
<td>R/W</td>
<td><p>High Speed Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p class="BLANK"></p>
<p>In SD/eMMC mode, this bit is used to determine the selection of preset value for High Speed mode.
Before setting this bit, the Host Driver checks the High Speed Support in the Capabilities register.</p>
<p class="BLANK"></p>
<p><span><em><span>Note</span></em></span>: DWC_MSHC always outputs the<span><em>sd_cmd_out</em></span>and<span><em>sd_dat_out</em></span>lines at the rising edge of<span><em>cclk_tx</em></span>clock irrespective of this bit. Please refer the section<span><em>Connecting the Clock IO interface</em></span>in the Mobile Storage Host Controller user guide on clocking requirement for an SD/eMMC card.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (HIGH_SPEED): High Speed mode</li><li>0x0 (NORMAL_SPEED): Normal Speed mode</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_1"></a>1</p>
</td>
<td>DAT_XFER_WIDTH</td>
<td>R/W</td>
<td><p>Data Transfer Width</p>
<p class="BLANK"></p>
<p>For SD/eMMC mode, this bit selects the data transfer width of the Host Controller. The Host Driver sets it to match the data width of the SD/eMMC card.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (FOUR_BIT): 4-bit mode</li><li>0x0 (ONE_BIT): 1-bit mode</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL1_R_F_0"></a>0</p>
</td>
<td>LED_CTRL</td>
<td>R/W</td>
<td><p>LED Control</p>
<p class="BLANK"></p>
<p>This bit is used to caution the user not to remove the card while the SD card is being accessed. The value is reflected on the<span><em>led_control</em></span>signal.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (OFF): LED off</li><li>0x1 (ON): LED on</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PWR_CTRL_R"></a><span>PWR_CTRL_R</span></p>
<ul><li><span>Name:</span>Power Control Register</li><li><span>Description:</span>This register is used to control the bus power for the Card. This register is applicable for an SD, eMMC modes.</li><li><span>Size:</span>8 bits</li><li><span>Offset:</span>0x29</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_PWR_CTRL_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PWR_CTRL_R_F_7_5">7:5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PWR_CTRL_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PWR_CTRL_R_F_3_1">3:1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PWR_CTRL_R_F_0">0</a></td>
</tr>
<tr><td>SD_BUS_VOL_VDD2</td>
<td>SD_BUS_PWR_VDD2</td>
<td>SD_BUS_VOL_VDD1</td>
<td>SD_BUS_PWR_VDD1</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_PWR_CTRL_R"></a><p class="title">Table�14.�Fields for Register: PWR_CTRL_R</p>
<table summary="Fields for Register: PWR_CTRL_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PWR_CTRL_R_F_7_5"></a>7:5</p>
</td>
<td>SD_BUS_VOL_VDD2</td>
<td>R/W</td>
<td><p>SD Bus Voltage Select for VDD2.
This bit is irrelevant for SD/eMMC card.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x7 (NOT_USED7): Not used</li><li>0x6 (NOT_USED6): Not used</li><li>0x5 (V_1_8): 1.8V</li><li>0x4 (V_1_2): Reserved for 1.2V</li><li>0x3 (RSVD3): Reserved</li><li>0x2 (RSVD2): Reserved</li><li>0x1 (RSVD1): Reserved</li><li>0x0 (NO_VDD2): VDD2 Not Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PWR_CTRL_R_F_4"></a>4</p>
</td>
<td>SD_BUS_PWR_VDD2</td>
<td>R/W</td>
<td><p>SD Bus Power for VDD2.
This bit is irrelevant for SD/eMMC card.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (OFF): Power off</li><li>0x1 (ON): Power on</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PWR_CTRL_R_F_3_1"></a>3:1</p>
</td>
<td>SD_BUS_VOL_VDD1</td>
<td>R/W</td>
<td><p>SD Bus Voltage Select for VDD1/eMMC Bus Voltage Select for VDD</p>
<p class="BLANK"></p>
<p>These bits enable the Host Driver to select the voltage level for an SD/eMMC card. Before setting this register, the Host Driver checks the Voltage Support bits in the Capabilities register.
If an unsupported voltage is selected, the Host System does not supply the SD Bus voltage. The value set in this field is available on the DWC_mshc output signal (sd_vdd1_sel), which is used by the voltage switching circuitry.</p>
<p class="BLANK"></p>
<p>SD Bus Voltage Select options:</p>
<ul><li>0x7 : 3.3V(Typical)</li><li>0x6 : 3.0V(Typical)</li><li>0x5 : 1.8V(Typical) for Embedded</li><li>0x4 : 0x0 - Reserved</li></ul><p></p>
<p class="BLANK"></p>
<p>eMMC Bus Voltage Select options:</p>
<ul><li>0x7 : 3.3V(Typical)</li><li>0x6 : 1.8V(Typical)</li><li>0x5 : 1.2V(Typical)</li><li>0x4 : 0x0 - Reserved</li></ul><p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x7 (V_3_3): 3.3V (Typ.)</li><li>0x6 (V_3_0): 3.0V (Typ.)</li><li>0x5 (V_1_8): 1.8V (Typ.) for Embedded</li><li>0x4 (RSVD4): Reserved</li><li>0x3 (RSVD3): Reserved</li><li>0x2 (RSVD2): Reserved</li><li>0x1 (RSVD1): Reserved</li><li>0x0 (RSVD0): Reserved</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PWR_CTRL_R_F_0"></a>0</p>
</td>
<td>SD_BUS_PWR_VDD1</td>
<td>R/W</td>
<td><p>SD Bus Power for VDD1</p>
<p class="BLANK"></p>
<p>This bit enables VDD1 power of the card. This setting is available on the sd_vdd1_on output of DWC_mshc so that it can be used to control the VDD1 power supply of the card. Before setting this bit, the SD Host Driver sets the SD Bus Voltage Select bit. If the Host Controller detects a No Card state, this bit is cleared.</p>
<p class="BLANK"></p>
<p>In SD mode, if this bit is cleared, the Host Controller stops the SD Clock by clearing the SD_CLK_IN bit in the CLK_CTRL_R register.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (OFF): Power off</li><li>0x1 (ON): Power on</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BGAP_CTRL_R"></a><span>BGAP_CTRL_R</span></p>
<ul><li><span>Name:</span>Block Gap Control Register</li><li><span>Description:</span>This register is used by the host driver to control any operation related to Block Gap. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>8 bits</li><li><span>Offset:</span>0x2a</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_BGAP_CTRL_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_BGAP_CTRL_R_F_7_4">7:4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_BGAP_CTRL_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_BGAP_CTRL_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_BGAP_CTRL_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_BGAP_CTRL_R_F_0">0</a></td>
</tr>
<tr><td>RSVD_7_4</td>
<td>INT_AT_BGAP</td>
<td>RD_WAIT_CTRL</td>
<td>CONTINUE_REQ</td>
<td>STOP_BG_REQ</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_BGAP_CTRL_R"></a><p class="title">Table�15.�Fields for Register: BGAP_CTRL_R</p>
<table summary="Fields for Register: BGAP_CTRL_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BGAP_CTRL_R_F_7_4"></a>7:4</p>
</td>
<td>RSVD_7_4</td>
<td>R</td>
<td><p>These bits of the Block Gap Control register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BGAP_CTRL_R_F_3"></a>3</p>
</td>
<td>INT_AT_BGAP</td>
<td>R/W</td>
<td><p>Interrupt At Block Gap</p>
<p class="BLANK"></p>
<p>This bit is valid only in the 4-bit mode of an SDIO card and is used to select a sample point in the interrupt cycle. Setting to 1 enables interrupt detection at the block gap for a multiple block transfer.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (DISABLE): Disabled</li><li>0x1 (ENABLE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BGAP_CTRL_R_F_2"></a>2</p>
</td>
<td>RD_WAIT_CTRL</td>
<td>R/W</td>
<td><p>Read Wait Control</p>
<p class="BLANK"></p>
<p>This bit is used to enable the read wait protocol to stop read data using DAT[2] line if the card supports read wait. Otherwise, the Host Controller has to stop the card clock to hold the read data.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (DISABLE): Disable Read Wait Control</li><li>0x1 (ENABLE): Enable Read Wait Control</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BGAP_CTRL_R_F_1"></a>1</p>
</td>
<td>CONTINUE_REQ</td>
<td>R/W</td>
<td><p>Continue Request</p>
<p class="BLANK"></p>
<p>This bit is used to restart the transaction, which was stopped using the Stop At Block Gap Request. The Host Controller automatically clears this bit when the transaction restarts. If stop at block gap request is set to 1, any write to this bit is ignored.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (NO_AFFECT): No Affect</li><li>0x1 (RESTART): Restart</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_BGAP_CTRL_R_F_0"></a>0</p>
</td>
<td>STOP_BG_REQ</td>
<td>R/W</td>
<td><p>Stop At Block Gap Request</p>
<p class="BLANK"></p>
<p>This bit is used to stop executing read and write transactions at the next block gap for non-DMA, SDMA, and ADMA transfers.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (XFER): Transfer</li><li>0x1 (STOP): Stop</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_WUP_CTRL_R"></a><span>WUP_CTRL_R</span></p>
<ul><li><span>Name:</span>Wakeup Control Register</li><li><span>Description:</span>This register is mandatory for the Host Controller, but the wakeup functionality depends on the Host Controller system hardware and software. The Host Driver maintains voltage on the SD Bus by
setting the SD Bus Power to 1 in the Power Control Register, while a wakeup event through the Card Interrupt is desired.</li><li><span>Size:</span>8 bits</li><li><span>Offset:</span>0x2b</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_WUP_CTRL_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_WUP_CTRL_R_F_7_3">7:3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_WUP_CTRL_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_WUP_CTRL_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_WUP_CTRL_R_F_0">0</a></td>
</tr>
<tr><td>RSVD_7_3</td>
<td>CARD_REMOVAL</td>
<td>CARD_INSERT</td>
<td>CARD_INT</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_WUP_CTRL_R"></a><p class="title">Table�16.�Fields for Register: WUP_CTRL_R</p>
<table summary="Fields for Register: WUP_CTRL_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_WUP_CTRL_R_F_7_3"></a>7:3</p>
</td>
<td>RSVD_7_3</td>
<td>R</td>
<td><p>These bits of Wakeup Control register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_WUP_CTRL_R_F_2"></a>2</p>
</td>
<td>CARD_REMOVAL</td>
<td>R/W</td>
<td><p>Wakeup Event Enable on SD Card Removal</p>
<p class="BLANK"></p>
<p>This bit enables wakeup event through Card Removal assertion in the Normal Interrupt Status register. For the SDIO card, Wake Up Support (FN_WUS) in the Card Information Structure (CIS) register does not affect this bit.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (DISABLED): Disable</li><li>0x1 (ENABLED): Enable</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_WUP_CTRL_R_F_1"></a>1</p>
</td>
<td>CARD_INSERT</td>
<td>R/W</td>
<td><p>Wakeup Event Enable on SD Card Insertion</p>
<p class="BLANK"></p>
<p>This bit enables wakeup event through Card Insertion assertion in the Normal Interrupt Status register. FN_WUS (Wake Up Support) in CIS does not affect this bit.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (DISABLED): Disable</li><li>0x1 (ENABLED): Enable</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_WUP_CTRL_R_F_0"></a>0</p>
</td>
<td>CARD_INT</td>
<td>R/W</td>
<td><p>Wakeup Event Enable on Card Interrupt</p>
<p class="BLANK"></p>
<p>This bit enables wakeup event through a Card Interrupt assertion in the Normal Interrupt Status register. This bit can be set to 1 if FN_WUS (Wake Up Support) in CIS is set to 1.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (DISABLED): Disable</li><li>0x1 (ENABLED): Enable</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R"></a><span>CLK_CTRL_R</span></p>
<ul><li><span>Name:</span>Clock Control Register</li><li><span>Description:</span>This register controls SDCLK (card clock) in an SD/eMMC mode. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x2c</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_15_8">15:8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_7_6">7:6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_0">0</a></td>
</tr>
<tr><td>FREQ_SEL</td>
<td>UPPER_FREQ_SEL</td>
<td>CLK_GEN_SELECT</td>
<td>RSVD_4</td>
<td>PLL_ENABLE</td>
<td>SD_CLK_EN</td>
<td>INTERNAL_CLK_STABLE</td>
<td>INTERNAL_CLK_EN</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R"></a><p class="title">Table�17.�Fields for Register: CLK_CTRL_R</p>
<table summary="Fields for Register: CLK_CTRL_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_15_8"></a>15:8</p>
</td>
<td>FREQ_SEL</td>
<td>R/W</td>
<td><p>SDCLK/RCLK Frequency Select</p>
<p class="BLANK"></p>
<p>These bits are used to select the frequency of the SDCLK signal. These bits depend on setting of Preset Value Enable in the Host Control 2 register. If Preset Value Enable = 0, these bits are set by
the Host
Driver. If Preset Value Enable = 1, these bits are automatically set to a value specified in one of the Preset Value register. The value is reflected on the lower 8-bit of the<span><em>card_clk_freq_sel</em></span>signal.</p>
<p class="BLANK"></p>
<p class="BLANK"></p>
<p><span>10-bit Divided Clock Mode:</span></p>
<ul><li>0x3FF : 1/2046 Divided clock</li><li>..........</li><li>N : 1/2N Divided Clock</li><li>..........</li><li>0x002 : 1/4 Divided Clock</li><li>0x001 : 1/2 Divided Clock</li><li>0x000 : Base clock (10MHz - 255 MHz)</li></ul><p></p>
<p class="BLANK"></p>
<p class="BLANK"></p>
<p><span>Programmable Clock Mode</span>: Enables the Host System to select a fine grain SD clock frequency:</p>
<ul><li>0x3FF : Base clock * M /1024</li><li>..........</li><li>N-1 : Base clock * M /N</li><li>..........</li><li>0x002 : Base clock * M /3</li><li>0x001 : Base clock * M /2</li><li>0x000 : Base clock * M</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_7_6"></a>7:6</p>
</td>
<td>UPPER_FREQ_SEL</td>
<td>R/W</td>
<td><p>These bits specify the upper 2 bits of 10-bit SDCLK/RCLK Frequency Select control. The value is reflected on the upper 2 bits of the<span><em>card_clk_freq_sel</em></span>signal.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_5"></a>5</p>
</td>
<td>CLK_GEN_SELECT</td>
<td>R/W</td>
<td><p>Clock Generator Select</p>
<p class="BLANK"></p>
<p>This bit is used to select the clock generator mode in SDCLK/RCLK Frequency Select. If Preset Value Enable = 0, this bit is set by the Host Driver. If Preset Value Enable = 1, this bit is
automatically set to a value specified in one of the Preset Value registers. The value is reflected on the<span><em>card_clk_gen_sel</em></span>signal.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Divided Clock Mode</li><li>0x1 (TRUE): Programmable Clock Mode</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_4"></a>4</p>
</td>
<td>RSVD_4</td>
<td>R</td>
<td><p>This bit of the CLK_CTRL_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_3"></a>3</p>
</td>
<td>PLL_ENABLE</td>
<td>R/W</td>
<td><p>PLL Enable</p>
<p class="BLANK"></p>
<p>This bit is used to activate the PLL (applicable when Host Version 4 Enable = 1). When Host Version 4 Enable = 0, INTERNAL_CLK_EN bit may be used to activate PLL. The value is reflected on the<span><em>card_clk_en</em></span>signal.</p>
<p class="BLANK"></p>
<p><span>Note:</span>If this bit is not used to active the PLL when Host Version 4 Enable = 1, it is recommended to set this bit to '1' .</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): PLL is in low power mode</li><li>0x1 (TRUE): PLL is enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_2"></a>2</p>
</td>
<td>SD_CLK_EN</td>
<td>R/W</td>
<td><p>SD/eMMC Clock Enable</p>
<p class="BLANK"></p>
<p>This bit stops the SDCLK or RCLK when set to 0. The SDCLK/RCLK Frequency Select bit can be changed when this bit is set to 0.
The value is reflected on the<span><em>clk2card_on</em></span>pin.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Disable providing SDCLK/RCLK</li><li>0x1 (TRUE): Enable providing SDCLK/RCLK</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_1"></a>1</p>
</td>
<td>INTERNAL_CLK_STABLE</td>
<td>R</td>
<td><p>Internal Clock Stable</p>
<p class="BLANK"></p>
<p>This bit enables the Host Driver to check the clock stability twice after the Internal Clock Enable bit is set and after the PLL Enable bit is set.
This bit reflects the synchronized value of the<span><em>intclk_stable</em></span>signal after the Internal Clock Enable bit is set to 1 and also reflects
the synchronized value of the<span><em>card_clk_stable</em></span>signal after the PLL Enable bit is set to 1.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Ready</li><li>0x1 (TRUE): Ready</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CLK_CTRL_R_F_0"></a>0</p>
</td>
<td>INTERNAL_CLK_EN</td>
<td>R/W</td>
<td><p>Internal Clock Enable</p>
<p class="BLANK"></p>
<p>This bit is set to 0 when the Host Driver is not using the Host Controller or the Host Controller awaits a wakeup interrupt. The Host Controller
must stop its internal clock to enter a very low power state. However, registers can still be read and written to. The value is reflected on the<span><em>intclk_en</em></span>signal.</p>
<p class="BLANK"></p>
<p><span>Note:</span>If this bit is not used to control the internal clock (base clock and manager clock), it is recommended to set this bit to '1' .</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Stop</li><li>0x1 (TRUE): Oscillate</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_TOUT_CTRL_R"></a><span>TOUT_CTRL_R</span></p>
<ul><li><span>Name:</span>Timeout Control Register</li><li><span>Description:</span>This register is used to set the Data Timeout Counter value for an SD/eMMC mode according to the timer clock defined by the Capabilities register, while
initializing the Host Controller.</li><li><span>Size:</span>8 bits</li><li><span>Offset:</span>0x2e</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_TOUT_CTRL_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_TOUT_CTRL_R_F_7_4">7:4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_TOUT_CTRL_R_F_3_0">3:0</a></td>
</tr>
<tr><td>RSVD_7_4</td>
<td>TOUT_CNT</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_TOUT_CTRL_R"></a><p class="title">Table�18.�Fields for Register: TOUT_CTRL_R</p>
<table summary="Fields for Register: TOUT_CTRL_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_TOUT_CTRL_R_F_7_4"></a>7:4</p>
</td>
<td>RSVD_7_4</td>
<td>R</td>
<td><p>These bits of the Timeout Control register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_TOUT_CTRL_R_F_3_0"></a>3:0</p>
</td>
<td>TOUT_CNT</td>
<td>R/W</td>
<td><p>Data Timeout Counter Value.</p>
<p class="BLANK"></p>
<p>This value determines the interval by which DAT line timeouts are detected. The Timeout clock frequency is generated by dividing the base clock TMCLK value by this value. When setting this
register, prevent inadvertent timeout events by clearing the Data Timeout Error Status Enable (in the Error Interrupt Status Enable register).
The values for these bits are:</p>
<ul><li>0xF : Reserved</li><li>0xE : TMCLK x 2^27</li><li>.........</li><li>0x1 : TMCLK x 2^14</li><li>0x0 : TMCLK x 2^13</li></ul><p></p>
<p class="BLANK"></p>
<p><span>Note:</span>During a boot operating in an eMMC mode, an application must configure the boot data timeout value (approximately 1 sec) in this bit.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_SW_RST_R"></a><span>SW_RST_R</span></p>
<ul><li><span>Name:</span>Software Reset Register</li><li><span>Description:</span>This register is used to generate a reset pulse by writing 1 to each bit of this register. After completing the reset, the Host Controller clears each bit. As it takes some time to complete a software reset, the Host Driver confirms that these bits are 0. This register is applicable for an SD/eMMC mode.<p class="BLANK"></p>
<span><em><span>Note</span></em></span>: Refer Software Reset section in the DWC_mshc Databook for additional details.</li><li><span>Size:</span>8 bits</li><li><span>Offset:</span>0x2f</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_SW_RST_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_SW_RST_R_F_7_3">7:3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_SW_RST_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_SW_RST_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_SW_RST_R_F_0">0</a></td>
</tr>
<tr><td>RSVD_7_3</td>
<td>SW_RST_DAT</td>
<td>SW_RST_CMD</td>
<td>SW_RST_ALL</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_SW_RST_R"></a><p class="title">Table�19.�Fields for Register: SW_RST_R</p>
<table summary="Fields for Register: SW_RST_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_SW_RST_R_F_7_3"></a>7:3</p>
</td>
<td>RSVD_7_3</td>
<td>R</td>
<td><p>These bits of the SW_RST_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_SW_RST_R_F_2"></a>2</p>
</td>
<td>SW_RST_DAT</td>
<td>R/W</td>
<td><p>Software Reset For DAT line</p>
<p class="BLANK"></p>
<p>This bit is used in SD/eMMC mode and it resets only a part of the data circuit and the DMA circuit is also reset.</p>
<p class="BLANK"></p>
<p>The following registers and bits are cleared by this bit:</p>
<ul><li>Buffer Data Port register<ul><li>Buffer is cleared and initialized.</li></ul></li><li>Present state register<ul><li>Buffer Read Enable</li><li>Buffer Write Enable</li><li>Read Transfer Active</li><li>Write Transfer Active</li><li>DAT Line Active</li><li>Command Inhibit (DAT)</li></ul></li><li>Block Gap Control register<ul><li>Continue Request</li><li>Stop At Block Gap Request</li></ul></li><li>Normal Interrupt status register<ul><li>Buffer Read Ready</li><li>Buffer Write Ready</li><li>DMA Interrupt</li><li>Block Gap Event</li><li>Transfer Complete</li></ul></li></ul><p></p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Work</li><li>0x1 (TRUE): Reset</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_SW_RST_R_F_1"></a>1</p>
</td>
<td>SW_RST_CMD</td>
<td>R/W</td>
<td><p>Software Reset For CMD line</p>
<p class="BLANK"></p>
<p>This bit resets only a part of the command circuit to be able to issue a command. This reset is effective only for a command issuing circuit (including response error statuses related to Command Inhibit (CMD) control) and does not affect the data transfer circuit. Host Controller can continue data transfer even after this reset is executed while handling subcommand-response errors.</p>
<p class="BLANK"></p>
<p>The following registers and bits are cleared by this bit:</p>
<ul><li>Present State register : Command Inhibit (CMD) bit</li><li>Normal Interrupt Status register : Command Complete bit</li><li>Error Interrupt Status : Response error statuses related to Command Inhibit (CMD) bit</li></ul><p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Work</li><li>0x1 (TRUE): Reset</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_SW_RST_R_F_0"></a>0</p>
</td>
<td>SW_RST_ALL</td>
<td>R/W</td>
<td><p>Software Reset For All</p>
<p class="BLANK"></p>
<p>This reset affects the entire Host Controller except for the card detection circuit. During its initialization, the Host Driver sets this bit to 1 to reset the Host Controller. All registers are reset except the capabilities register. If this bit is set to 1, the Host Driver must issue reset command and reinitialize the card.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Work</li><li>0x1 (TRUE): Reset</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R"></a><span>NORMAL_INT_STAT_R</span></p>
<ul><li><span>Name:</span>Normal Interrupt Status Register</li><li><span>Description:</span>This register reflects the status of the Normal Interrupt. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x30</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_15">15</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_14">14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_13">13</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_12">12</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_11">11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_9">9</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_8">8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_0">0</a></td>
</tr>
<tr><td>ERR_INTERRUPT</td>
<td>CQE_EVENT</td>
<td>FX_EVENT</td>
<td>RE_TUNE_EVENT</td>
<td>INT_C</td>
<td>INT_B</td>
<td>INT_A</td>
<td>CARD_INTERRUPT</td>
<td>CARD_REMOVAL</td>
<td>CARD_INSERTION</td>
<td>BUF_RD_READY</td>
<td>BUF_WR_READY</td>
<td>DMA_INTERRUPT</td>
<td>BGAP_EVENT</td>
<td>XFER_COMPLETE</td>
<td>CMD_COMPLETE</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R"></a><p class="title">Table�20.�Fields for Register: NORMAL_INT_STAT_R</p>
<table summary="Fields for Register: NORMAL_INT_STAT_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_15"></a>15</p>
</td>
<td>ERR_INTERRUPT</td>
<td>R</td>
<td><p>Error Interrupt</p>
<p class="BLANK"></p>
<p>If any of the bits in the Error Interrupt Status register are set, then this bit is set.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No Error</li><li>0x1 (TRUE): Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_14"></a>14</p>
</td>
<td>CQE_EVENT</td>
<td>R/W1C</td>
<td><p>Command Queuing Event</p>
<p class="BLANK"></p>
<p>This status is set if Command Queuing/Crypto related event has occurred in eMMC/SD mode. Read CQHCI's CQIS/CRNQIS register for more details.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No Event</li><li>0x1 (TRUE): Command Queuing Event is detected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_13"></a>13</p>
</td>
<td>FX_EVENT</td>
<td>R</td>
<td><p>FX Event</p>
<p class="BLANK"></p>
<p>This status is set when R[14] of response register is set to 1 and Response Type R1/R5 is set to 0 in Transfer Mode register. This interrupt is used with response check function.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No Event</li><li>0x1 (TRUE): FX Event is detected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_12"></a>12</p>
</td>
<td>RE_TUNE_EVENT</td>
<td>R</td>
<td><p>Re-tuning Event</p>
<p class="BLANK"></p>
<p>This bit is set if the Re-Tuning Request changes from 0 to 1. Re-Tuning request is not supported.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_11"></a>11</p>
</td>
<td>INT_C</td>
<td>R</td>
<td><p>INT_C (Embedded)</p>
<p class="BLANK"></p>
<p>This bit is set if INT_C is enabled and if INT_C# pin is in low level. The INT_C# pin is not supported.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_10"></a>10</p>
</td>
<td>INT_B</td>
<td>R</td>
<td><p>INT_B (Embedded)</p>
<p class="BLANK"></p>
<p>This bit is set if INT_B is enabled and if INT_B# pin is in low level. The INT_B# pin is not supported.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_9"></a>9</p>
</td>
<td>INT_A</td>
<td>R</td>
<td><p>INT_A (Embedded)</p>
<p class="BLANK"></p>
<p>This bit is set if INT_A is enabled and if INT_A# pin is in low level. The INT_A# pin is not supported.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_8"></a>8</p>
</td>
<td>CARD_INTERRUPT</td>
<td>R</td>
<td><p>Card Interrupt</p>
<p class="BLANK"></p>
<p>This bit reflects the synchronized value of:</p>
<ul><li>DAT[1] Interrupt Input for SD Mode</li></ul><p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No Card Interrupt</li><li>0x1 (TRUE): Generate Card Interrupt</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_7"></a>7</p>
</td>
<td>CARD_REMOVAL</td>
<td>R/W1C</td>
<td><p>Card Removal</p>
<p class="BLANK"></p>
<p>This bit is set if the Card Inserted in the Present State register changes from 1 to 0.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Card state stable or Debouncing</li><li>0x1 (TRUE): Card Removed</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_6"></a>6</p>
</td>
<td>CARD_INSERTION</td>
<td>R/W1C</td>
<td><p>Card Insertion</p>
<p class="BLANK"></p>
<p>This bit is set if the Card Inserted in the Present State register changes from 0 to 1.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Card state stable or Debouncing</li><li>0x1 (TRUE): Card Inserted</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_5"></a>5</p>
</td>
<td>BUF_RD_READY</td>
<td>R/W1C</td>
<td><p>Buffer Read Ready</p>
<p class="BLANK"></p>
<p>This bit is set if the Buffer Read Enable changes from 0 to 1.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not ready to read buffer</li><li>0x1 (TRUE): Ready to read buffer</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_4"></a>4</p>
</td>
<td>BUF_WR_READY</td>
<td>R/W1C</td>
<td><p>Buffer Write Ready</p>
<p class="BLANK"></p>
<p>This bit is set if the Buffer Write Enable changes from 0 to 1.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not ready to write buffer</li><li>0x1 (TRUE): Ready to write buffer</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_3"></a>3</p>
</td>
<td>DMA_INTERRUPT</td>
<td>R/W1C</td>
<td><p>DMA Interrupt</p>
<p class="BLANK"></p>
<p>This bit is set if the Host Controller detects the SDMA Buffer Boundary during transfer. In case of ADMA, by setting the Int field in the descriptor
table, the Host controller generates this interrupt. This interrupt is not generated after a Transfer Complete.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No DMA Interrupt</li><li>0x1 (TRUE): DMA Interrupt is generated</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_2"></a>2</p>
</td>
<td>BGAP_EVENT</td>
<td>R/W1C</td>
<td><p>Block Gap Event</p>
<p class="BLANK"></p>
<p>This bit is set when both read/write transaction is stopped at block gap due to a Stop at Block Gap Request.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No Block Gap Event</li><li>0x1 (TRUE): Transaction stopped at block gap</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_1"></a>1</p>
</td>
<td>XFER_COMPLETE</td>
<td>R/W1C</td>
<td><p>Transfer Complete</p>
<p class="BLANK"></p>
<p>This bit is set when a read/write transfer and a command with status busy is completed.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not complete</li><li>0x1 (TRUE): Command execution is completed</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_R_F_0"></a>0</p>
</td>
<td>CMD_COMPLETE</td>
<td>R/W1C</td>
<td><p>Command Complete</p>
<p class="BLANK"></p>
<p>In an SD/eMMC Mode, this bit is set when the end bit of a response except for Auto CMD12 and Auto CMD23.</p>
<p class="BLANK"></p>
<p>This interrupt is not generated when the Response Interrupt Disable in Transfer Mode Register is set to 1.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No command complete</li><li>0x1 (TRUE): Command Complete</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R"></a><span>ERROR_INT_STAT_R</span></p>
<ul><li><span>Name:</span>Error Interrupt Status Register</li><li><span>Description:</span>This register enables an interrupt when the Error Interrupt Status Enable is enabled and at least one of the statuses is set to 1. Writing to 1 clears the bit
and writing to 0 retains the bit unchanged. Signals defined in this register can be enabled by the Error Interrupt Status Enable register, but not by the Error Interrupt Signal Enable register. More than one status can be cleared with a single register write. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x32</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_15">15</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_14">14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_13">13</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_12">12</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_11">11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_9">9</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_8">8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_0">0</a></td>
</tr>
<tr><td>VENDOR_ERR3</td>
<td>VENDOR_ERR2</td>
<td>VENDOR_ERR1</td>
<td>BOOT_ACK_ERR</td>
<td>RESP_ERR</td>
<td>TUNING_ERR</td>
<td>ADMA_ERR</td>
<td>AUTO_CMD_ERR</td>
<td>CUR_LMT_ERR</td>
<td>DATA_END_BIT_ERR</td>
<td>DATA_CRC_ERR</td>
<td>DATA_TOUT_ERR</td>
<td>CMD_IDX_ERR</td>
<td>CMD_END_BIT_ERR</td>
<td>CMD_CRC_ERR</td>
<td>CMD_TOUT_ERR</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R"></a><p class="title">Table�21.�Fields for Register: ERROR_INT_STAT_R</p>
<table summary="Fields for Register: ERROR_INT_STAT_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_15"></a>15</p>
</td>
<td>VENDOR_ERR3</td>
<td>R/W1C</td>
<td><p>This bit (VENDOR_ERR3) of the ERROR_INT_STAT_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_14"></a>14</p>
</td>
<td>VENDOR_ERR2</td>
<td>R/W1C</td>
<td><p>This bit (VENDOR_ERR2) of the ERROR_INT_STAT_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_13"></a>13</p>
</td>
<td>VENDOR_ERR1</td>
<td>R/W1C</td>
<td><p>This bit (VENDOR_ERR1) of the ERROR_INT_STAT_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_12"></a>12</p>
</td>
<td>BOOT_ACK_ERR</td>
<td>R/W1C</td>
<td><p>Boot Acknowledgement Error</p>
<p class="BLANK"></p>
<p></p>
<p class="BLANK"></p>
<p>In SD mode, this bit is irrelevant.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_11"></a>11</p>
</td>
<td>RESP_ERR</td>
<td>R/W1C</td>
<td><p>Response Error</p>
<p class="BLANK"></p>
<p>Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver during DMA execution. If Response Error Check Enable is set to 1 in the Transfer Mode register, Host Controller Checks R1 or R5 response. If an error is detected in a response, this bit is set to 1. This is applicable in SD/eMMC mode.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_10"></a>10</p>
</td>
<td>TUNING_ERR</td>
<td>R/W1C</td>
<td><p>Tuning Error</p>
<p class="BLANK"></p>
<p>This bit is set when an unrecoverable error is detected in a tuning circuit except during the tuning procedure (occurrence of an error during tuning procedure is indicated by Sampling Clock Select in the Host Control 2 register). By detecting Tuning Error, Host Driver needs to terminate a command executing and perform tuning. To reset tuning circuit, Sampling Clock Select is set to 0 before executing tuning procedure. The Tuning Error is higher priority than the other error interrupts generated during data transfer. By detecting Tuning Error, the Host Driver must discard data transferred by a current read/write command and retry data transfer after the Host Controller retrieved from the tuning circuit error. This is applicable in SD/eMMC mode.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_9"></a>9</p>
</td>
<td>ADMA_ERR</td>
<td>R/W1C</td>
<td><p>ADMA Error</p>
<p class="BLANK"></p>
<p>This bit is set when the Host Controller detects error during ADMA-based data transfer. The error could be due to following reasons:</p>
<ul><li>Error response received from System bus (Manager I/F)</li><li>ADMA3,ADMA2 Descriptors invalid</li><li>CQE Task or Transfer descriptors invalid</li></ul><p>When the error occurs, the state of the ADMA is saved in the ADMA Error Status register.</p>
<p class="BLANK"></p>
<p>In eMMC CQE mode:</p>
<p class="BLANK"></p>
<p>The Host Controller generates this Interrupt when it detects an invalid descriptor data (Valid=0) at the ST_FDS state. ADMA Error State in the ADMA Error Status indicates that an error has occurred in ST_FDS state. The Host Driver may find that Valid bit is not set at the error descriptor.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_8"></a>8</p>
</td>
<td>AUTO_CMD_ERR</td>
<td>R/W1C</td>
<td><p>Auto CMD Error</p>
<p class="BLANK"></p>
<p>This error status is used by Auto CMD12 and Auto CMD23 in SD/eMMC mode. This bit is set when detecting that any of the bits D00 to D05 in Auto CMD Error Status register has changed from 0 to 1. D07 is effective in case of Auto CMD12. Auto CMD Error Status register is valid while this bit is set to 1 and may be cleared by clearing of this bit.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_7"></a>7</p>
</td>
<td>CUR_LMT_ERR</td>
<td>R/W1C</td>
<td><p>Current Limit Error</p>
<p class="BLANK"></p>
<p>By setting the SD Bus Power bit in the Power Control register, the Host Controller is requested to supply power for the SD Bus. If the Host Controller supports the Current Limit function, it can
be protected from an illegal card by stopping power supply to the card in which case this bit indicates a failure status. A reading of 1 for this bit means that the Host Controller is not supplying
power to the SD card due to some failure. A reading of 0 for this bit means that the Host Controller is supplying power and no error has occurred. The Host Controller may require some sampling time to
detect the current limit. DWC_mshc Host Controller does not support this function, this bit is always set to 0.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): Power Fail</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_6"></a>6</p>
</td>
<td>DATA_END_BIT_ERR</td>
<td>R/W1C</td>
<td><p>Data End Bit Error</p>
<p class="BLANK"></p>
<p>This error occurs in SD/eMMC mode either when detecting 0 at the end bit position of read data that uses the DAT line or at the end bit position of the CRC status.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_5"></a>5</p>
</td>
<td>DATA_CRC_ERR</td>
<td>R/W1C</td>
<td><p>Data CRC Error</p>
<p class="BLANK"></p>
<p>This error occurs in SD/eMMC mode when detecting CRC error when transferring read data which uses the DAT line, when detecting the Write CRC status having a value of other than 010 or when write CRC status timeout.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_4"></a>4</p>
</td>
<td>DATA_TOUT_ERR</td>
<td>R/W1C</td>
<td><p>Data Timeout Error</p>
<p class="BLANK"></p>
<p>This bit is set in SD/eMMC mode when detecting one of the following timeout conditions:</p>
<ul><li>Busy timeout for R1b, R5b type</li><li>Busy timeout after Write CRC status</li><li>Write CRC Status timeout</li><li>Read Data timeout</li></ul><p></p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): Time out</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_3"></a>3</p>
</td>
<td>CMD_IDX_ERR</td>
<td>R/W1C</td>
<td><p>Command Index Error</p>
<p class="BLANK"></p>
<p>This bit is set if a Command Index error occurs in the command response in SD/eMMC mode.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_2"></a>2</p>
</td>
<td>CMD_END_BIT_ERR</td>
<td>R/W1C</td>
<td><p>Command End Bit Error</p>
<p class="BLANK"></p>
<p>This bit is set when detecting that the end bit of a command response is 0 in SD/eMMC mode.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): End Bit error generated</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_1"></a>1</p>
</td>
<td>CMD_CRC_ERR</td>
<td>R/W1C</td>
<td><p>Command CRC Error</p>
<p class="BLANK"></p>
<p>Command CRC Error is generated in SD/eMMC mode for following two cases.</p>
<ul><li>If a response is returned and the Command Timeout Error is set to 0 (indicating no timeout), this bit is set to 1 when detecting a CRC error in the command response.</li><li>The Host Controller detects a CMD line conflict by monitoring the CMD line when a command is issued. If the Host Controller drives the CMD line to 1 level, but detects 0 level on the CMD line at the next SD clock edge, then the Host Controller terminates the command (stop driving CMD line) and set this bit to 1. The Command Timeout Error is also set to 1 to distinguish a CMD line conflict.</li></ul><p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): CRC error generated</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_R_F_0"></a>0</p>
</td>
<td>CMD_TOUT_ERR</td>
<td>R/W1C</td>
<td><p>Command Timeout Error</p>
<p class="BLANK"></p>
<p>In SD/eMMC Mode, this bit is set only if no response is returned within 64 SD clock cycles from the end bit of the command. If the Host Controller detects a CMD line conflict, along with Command CRC Error bit, this bit is set to 1, without waiting for 64 SD/eMMC card clock cycles.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): Time out</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R"></a><span>NORMAL_INT_STAT_EN_R</span></p>
<ul><li><span>Name:</span>Normal Interrupt Status Enable Register</li><li><span>Description:</span>This register enables the Interrupt Status for Normal Interrupt Status register (NORMAL_INT_STAT_R) when NORMAL_INT_STAT_R is set to 1. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x34</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_15">15</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_14">14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_13">13</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_12">12</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_11">11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_9">9</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_8">8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_0">0</a></td>
</tr>
<tr><td>RSVD_15</td>
<td>CQE_EVENT_STAT_EN</td>
<td>FX_EVENT_STAT_EN</td>
<td>RE_TUNE_EVENT_STAT_EN</td>
<td>INT_C_STAT_EN</td>
<td>INT_B_STAT_EN</td>
<td>INT_A_STAT_EN</td>
<td>CARD_INTERRUPT_STAT_EN</td>
<td>CARD_REMOVAL_STAT_EN</td>
<td>CARD_INSERTION_STAT_EN</td>
<td>BUF_RD_READY_STAT_EN</td>
<td>BUF_WR_READY_STAT_EN</td>
<td>DMA_INTERRUPT_STAT_EN</td>
<td>BGAP_EVENT_STAT_EN</td>
<td>XFER_COMPLETE_STAT_EN</td>
<td>CMD_COMPLETE_STAT_EN</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R"></a><p class="title">Table�22.�Fields for Register: NORMAL_INT_STAT_EN_R</p>
<table summary="Fields for Register: NORMAL_INT_STAT_EN_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_15"></a>15</p>
</td>
<td>RSVD_15</td>
<td>R</td>
<td><p>This bit of the NORMAL_INT_STAT_EN_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_14"></a>14</p>
</td>
<td>CQE_EVENT_STAT_EN</td>
<td>R/W</td>
<td><p>CQE Event Status Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_13"></a>13</p>
</td>
<td>FX_EVENT_STAT_EN</td>
<td>R/W</td>
<td><p>FX Event Status Enable</p>
<p class="BLANK"></p>
<p>This bit is added from Version 4.10.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_12"></a>12</p>
</td>
<td>RE_TUNE_EVENT_STAT_EN</td>
<td>R/W</td>
<td><p>Re-Tuning Event (UHS-I only) Status Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_11"></a>11</p>
</td>
<td>INT_C_STAT_EN</td>
<td>R/W</td>
<td><p>INT_C (Embedded) Status Enable</p>
<p class="BLANK"></p>
<p>If this bit is set to 0, the Host Controller clears the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_C and may set this bit again after all interrupt requests to INT_C pin are cleared to prevent inadvertent interrupts.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_10"></a>10</p>
</td>
<td>INT_B_STAT_EN</td>
<td>R/W</td>
<td><p>INT_B (Embedded) Status Enable</p>
<p class="BLANK"></p>
<p>If this bit is set to 0, the Host Controller clears the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_B and may set this bit again after all interrupt requests to INT_B pin are cleared to prevent inadvertent interrupts.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_9"></a>9</p>
</td>
<td>INT_A_STAT_EN</td>
<td>R/W</td>
<td><p>INT_A (Embedded) Status Enable</p>
<p class="BLANK"></p>
<p>If this bit is set to 0, the Host Controller clears the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_A and may set this bit again after all interrupt requests to INT_A pin are cleared to prevent inadvertent interrupts.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_8"></a>8</p>
</td>
<td>CARD_INTERRUPT_STAT_EN</td>
<td>R/W</td>
<td><p>Card Interrupt Status Enable</p>
<p class="BLANK"></p>
<p>If this bit is set to 0, the Host Controller clears the interrupt request to the System. The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 1. The Host Driver may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all interrupt requests from the card are cleared to prevent inadvertent interrupts.</p>
<p class="BLANK"></p>
<p>By setting this bit to 0, interrupt input must be masked by implementation so that the interrupt input is not affected by external signal in any state (for example, floating).</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_7"></a>7</p>
</td>
<td>CARD_REMOVAL_STAT_EN</td>
<td>R/W</td>
<td><p>Card Removal Status Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_6"></a>6</p>
</td>
<td>CARD_INSERTION_STAT_EN</td>
<td>R/W</td>
<td><p>Card Insertion Status Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_5"></a>5</p>
</td>
<td>BUF_RD_READY_STAT_EN</td>
<td>R/W</td>
<td><p>Buffer Read Ready Status Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_4"></a>4</p>
</td>
<td>BUF_WR_READY_STAT_EN</td>
<td>R/W</td>
<td><p>Buffer Write Ready Status Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_3"></a>3</p>
</td>
<td>DMA_INTERRUPT_STAT_EN</td>
<td>R/W</td>
<td><p>DMA Interrupt Status Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_2"></a>2</p>
</td>
<td>BGAP_EVENT_STAT_EN</td>
<td>R/W</td>
<td><p>Block Gap Event Status Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_1"></a>1</p>
</td>
<td>XFER_COMPLETE_STAT_EN</td>
<td>R/W</td>
<td><p>Transfer Complete Status Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_STAT_EN_R_F_0"></a>0</p>
</td>
<td>CMD_COMPLETE_STAT_EN</td>
<td>R/W</td>
<td><p>Command Complete Status Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R"></a><span>ERROR_INT_STAT_EN_R</span></p>
<ul><li><span>Name:</span>Error Interrupt Status Enable Register</li><li><span>Description:</span>This register sets the Interrupt Status for Error Interrupt Status register (ERROR_INT_STAT_R), when ERROR_INT_STAT_EN_R is set to 1. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x36</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_15">15</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_14">14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_13">13</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_12">12</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_11">11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_9">9</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_8">8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_0">0</a></td>
</tr>
<tr><td>VENDOR_ERR_STAT_EN3</td>
<td>VENDOR_ERR_STAT_EN2</td>
<td>VENDOR_ERR_STAT_EN1</td>
<td>BOOT_ACK_ERR_STAT_EN</td>
<td>RESP_ERR_STAT_EN</td>
<td>TUNING_ERR_STAT_EN</td>
<td>ADMA_ERR_STAT_EN</td>
<td>AUTO_CMD_ERR_STAT_EN</td>
<td>CUR_LMT_ERR_STAT_EN</td>
<td>DATA_END_BIT_ERR_STAT_EN</td>
<td>DATA_CRC_ERR_STAT_EN</td>
<td>DATA_TOUT_ERR_STAT_EN</td>
<td>CMD_IDX_ERR_STAT_EN</td>
<td>CMD_END_BIT_ERR_STAT_EN</td>
<td>CMD_CRC_ERR_STAT_EN</td>
<td>CMD_TOUT_ERR_STAT_EN</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R"></a><p class="title">Table�23.�Fields for Register: ERROR_INT_STAT_EN_R</p>
<table summary="Fields for Register: ERROR_INT_STAT_EN_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_15"></a>15</p>
</td>
<td>VENDOR_ERR_STAT_EN3</td>
<td>R/W</td>
<td><p>The 15th bit of Error Interrupt Status Enable register is reserved.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_14"></a>14</p>
</td>
<td>VENDOR_ERR_STAT_EN2</td>
<td>R/W</td>
<td><p>The 14th bit of Error Interrupt Status Enable register is reserved.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_13"></a>13</p>
</td>
<td>VENDOR_ERR_STAT_EN1</td>
<td>R/W</td>
<td><p>The 13th bit of Error Interrupt Status Enable register is reserved.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_12"></a>12</p>
</td>
<td>BOOT_ACK_ERR_STAT_EN</td>
<td>R/W</td>
<td><p>Boot Acknowledgement Error (eMMC Mode only)</p>
<p class="BLANK"></p>
<p>Setting this bit to 1 enables setting of Boot Acknowledgement Error in Error Interrupt Status register (ERROR_INT_STAT_R).</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_11"></a>11</p>
</td>
<td>RESP_ERR_STAT_EN</td>
<td>R/W</td>
<td><p>Response Error Status Enable (SD Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_10"></a>10</p>
</td>
<td>TUNING_ERR_STAT_EN</td>
<td>R/W</td>
<td><p>Tuning Error Status Enable (UHS-I Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_9"></a>9</p>
</td>
<td>ADMA_ERR_STAT_EN</td>
<td>R/W</td>
<td><p>ADMA Error Status Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_8"></a>8</p>
</td>
<td>AUTO_CMD_ERR_STAT_EN</td>
<td>R/W</td>
<td><p>Auto CMD Error Status Enable (SD/eMMC Mode only).</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_7"></a>7</p>
</td>
<td>CUR_LMT_ERR_STAT_EN</td>
<td>R/W</td>
<td><p>Current Limit Error Status Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_6"></a>6</p>
</td>
<td>DATA_END_BIT_ERR_STAT_EN</td>
<td>R/W</td>
<td><p>Data End Bit Error Status Enable (SD/eMMC Mode only).</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_5"></a>5</p>
</td>
<td>DATA_CRC_ERR_STAT_EN</td>
<td>R/W</td>
<td><p>Data CRC Error Status Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_4"></a>4</p>
</td>
<td>DATA_TOUT_ERR_STAT_EN</td>
<td>R/W</td>
<td><p>Data Timeout Error Status Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_3"></a>3</p>
</td>
<td>CMD_IDX_ERR_STAT_EN</td>
<td>R/W</td>
<td><p>Command Index Error Status Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_2"></a>2</p>
</td>
<td>CMD_END_BIT_ERR_STAT_EN</td>
<td>R/W</td>
<td><p>Command End Bit Error Status Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_1"></a>1</p>
</td>
<td>CMD_CRC_ERR_STAT_EN</td>
<td>R/W</td>
<td><p>Command CRC Error Status Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_STAT_EN_R_F_0"></a>0</p>
</td>
<td>CMD_TOUT_ERR_STAT_EN</td>
<td>R/W</td>
<td><p>Command Timeout Error Status Enable (SD/eMMC Mode only).</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R"></a><span>NORMAL_INT_SIGNAL_EN_R</span></p>
<ul><li><span>Name:</span>Normal Interrupt Signal Enable Register</li><li><span>Description:</span>This register is used to select the interrupt status that is indicated to the Host System as the interrupt. All these status bits share the same 1-bit interrupt line. Setting any of these bits to 1, enables interrupt generation. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x38</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_15">15</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_14">14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_13">13</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_12">12</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_11">11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_9">9</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_8">8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_0">0</a></td>
</tr>
<tr><td>RSVD_15</td>
<td>CQE_EVENT_SIGNAL_EN</td>
<td>FX_EVENT_SIGNAL_EN</td>
<td>RE_TUNE_EVENT_SIGNAL_EN</td>
<td>INT_C_SIGNAL_EN</td>
<td>INT_B_SIGNAL_EN</td>
<td>INT_A_SIGNAL_EN</td>
<td>CARD_INTERRUPT_SIGNAL_EN</td>
<td>CARD_REMOVAL_SIGNAL_EN</td>
<td>CARD_INSERTION_SIGNAL_EN</td>
<td>BUF_RD_READY_SIGNAL_EN</td>
<td>BUF_WR_READY_SIGNAL_EN</td>
<td>DMA_INTERRUPT_SIGNAL_EN</td>
<td>BGAP_EVENT_SIGNAL_EN</td>
<td>XFER_COMPLETE_SIGNAL_EN</td>
<td>CMD_COMPLETE_SIGNAL_EN</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R"></a><p class="title">Table�24.�Fields for Register: NORMAL_INT_SIGNAL_EN_R</p>
<table summary="Fields for Register: NORMAL_INT_SIGNAL_EN_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_15"></a>15</p>
</td>
<td>RSVD_15</td>
<td>R</td>
<td><p>This bit of the NORMAL_INT_STAT_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_14"></a>14</p>
</td>
<td>CQE_EVENT_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Command Queuing Engine Event Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_13"></a>13</p>
</td>
<td>FX_EVENT_SIGNAL_EN</td>
<td>R/W</td>
<td><p>FX Event Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_12"></a>12</p>
</td>
<td>RE_TUNE_EVENT_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Re-Tuning Event (UHS-I only) Signal Enable.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_11"></a>11</p>
</td>
<td>INT_C_SIGNAL_EN</td>
<td>R/W</td>
<td><p>INT_C (Embedded) Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_10"></a>10</p>
</td>
<td>INT_B_SIGNAL_EN</td>
<td>R/W</td>
<td><p>INT_B (Embedded) Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_9"></a>9</p>
</td>
<td>INT_A_SIGNAL_EN</td>
<td>R/W</td>
<td><p>INT_A (Embedded) Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_8"></a>8</p>
</td>
<td>CARD_INTERRUPT_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Card Interrupt Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_7"></a>7</p>
</td>
<td>CARD_REMOVAL_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Card Removal Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_6"></a>6</p>
</td>
<td>CARD_INSERTION_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Card Insertion Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_5"></a>5</p>
</td>
<td>BUF_RD_READY_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Buffer Read Ready Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_4"></a>4</p>
</td>
<td>BUF_WR_READY_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Buffer Write Ready Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_3"></a>3</p>
</td>
<td>DMA_INTERRUPT_SIGNAL_EN</td>
<td>R/W</td>
<td><p>DMA Interrupt Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_2"></a>2</p>
</td>
<td>BGAP_EVENT_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Block Gap Event Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_1"></a>1</p>
</td>
<td>XFER_COMPLETE_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Transfer Complete Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_NORMAL_INT_SIGNAL_EN_R_F_0"></a>0</p>
</td>
<td>CMD_COMPLETE_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Command Complete Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R"></a><span>ERROR_INT_SIGNAL_EN_R</span></p>
<ul><li><span>Name:</span>Error Interrupt Signal Enable Register</li><li><span>Description:</span>This register is used to select the interrupt status that is notified to the Host System as an interrupt. All these status bits share the same 1-bit interrupt line. Setting any of these bits to 1 enables interrupt generation. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x3a</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_15">15</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_14">14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_13">13</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_12">12</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_11">11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_9">9</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_8">8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_0">0</a></td>
</tr>
<tr><td>VENDOR_ERR_SIGNAL_EN3</td>
<td>VENDOR_ERR_SIGNAL_EN2</td>
<td>VENDOR_ERR_SIGNAL_EN1</td>
<td>BOOT_ACK_ERR_SIGNAL_EN</td>
<td>RESP_ERR_SIGNAL_EN</td>
<td>TUNING_ERR_SIGNAL_EN</td>
<td>ADMA_ERR_SIGNAL_EN</td>
<td>AUTO_CMD_ERR_SIGNAL_EN</td>
<td>CUR_LMT_ERR_SIGNAL_EN</td>
<td>DATA_END_BIT_ERR_SIGNAL_EN</td>
<td>DATA_CRC_ERR_SIGNAL_EN</td>
<td>DATA_TOUT_ERR_SIGNAL_EN</td>
<td>CMD_IDX_ERR_SIGNAL_EN</td>
<td>CMD_END_BIT_ERR_SIGNAL_EN</td>
<td>CMD_CRC_ERR_SIGNAL_EN</td>
<td>CMD_TOUT_ERR_SIGNAL_EN</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R"></a><p class="title">Table�25.�Fields for Register: ERROR_INT_SIGNAL_EN_R</p>
<table summary="Fields for Register: ERROR_INT_SIGNAL_EN_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_15"></a>15</p>
</td>
<td>VENDOR_ERR_SIGNAL_EN3</td>
<td>R/W</td>
<td><p>The 16th bit of Error Interrupt Signal Enable is reserved.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_14"></a>14</p>
</td>
<td>VENDOR_ERR_SIGNAL_EN2</td>
<td>R/W</td>
<td><p>The 15th bit of Error Interrupt Signal Enable is reserved.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_13"></a>13</p>
</td>
<td>VENDOR_ERR_SIGNAL_EN1</td>
<td>R/W</td>
<td><p>The 14th bit of Error Interrupt Signal Enable is reserved.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_12"></a>12</p>
</td>
<td>BOOT_ACK_ERR_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Boot Acknowledgement Error (eMMC Mode only).</p>
<p class="BLANK"></p>
<p>Setting this bit to 1 enables generating interrupt signal when Boot Acknowledgement Error in Error Interrupt Status register is set.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_11"></a>11</p>
</td>
<td>RESP_ERR_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Response Error Signal Enable (SD Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_10"></a>10</p>
</td>
<td>TUNING_ERR_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Tuning Error Signal Enable (UHS-I Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_9"></a>9</p>
</td>
<td>ADMA_ERR_SIGNAL_EN</td>
<td>R/W</td>
<td><p>ADMA Error Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_8"></a>8</p>
</td>
<td>AUTO_CMD_ERR_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Auto CMD Error Signal Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_7"></a>7</p>
</td>
<td>CUR_LMT_ERR_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Current Limit Error Signal Enable</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_6"></a>6</p>
</td>
<td>DATA_END_BIT_ERR_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Data End Bit Error Signal Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_5"></a>5</p>
</td>
<td>DATA_CRC_ERR_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Data CRC Error Signal Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_4"></a>4</p>
</td>
<td>DATA_TOUT_ERR_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Data Timeout Error Signal Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_3"></a>3</p>
</td>
<td>CMD_IDX_ERR_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Command Index Error Signal Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): No error</li><li>0x1 (TRUE): Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_2"></a>2</p>
</td>
<td>CMD_END_BIT_ERR_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Command End Bit Error Signal Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_1"></a>1</p>
</td>
<td>CMD_CRC_ERR_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Command CRC Error Signal Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ERROR_INT_SIGNAL_EN_R_F_0"></a>0</p>
</td>
<td>CMD_TOUT_ERR_SIGNAL_EN</td>
<td>R/W</td>
<td><p>Command Timeout Error Signal Enable (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Masked</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R"></a><span>AUTO_CMD_STAT_R</span></p>
<ul><li><span>Name:</span>Auto CMD Status Register</li><li><span>Description:</span>This register is used to indicate the CMD12 response error of Auto CMD12, and the CMD23 response error of Auto CMD23. The Host driver can determine the kind of Auto CMD12/CMD23 errors that can occur in this register. Auto CMD23 errors are indicated in bit 04-01. This register is valid only when Auto CMD Error is set. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x3c</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_15_8">15:8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_0">0</a></td>
</tr>
<tr><td>RSVD_15_8</td>
<td>CMD_NOT_ISSUED_AUTO_CMD12</td>
<td>RSVD_6</td>
<td>AUTO_CMD_RESP_ERR</td>
<td>AUTO_CMD_IDX_ERR</td>
<td>AUTO_CMD_EBIT_ERR</td>
<td>AUTO_CMD_CRC_ERR</td>
<td>AUTO_CMD_TOUT_ERR</td>
<td>AUTO_CMD12_NOT_EXEC</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R"></a><p class="title">Table�26.�Fields for Register: AUTO_CMD_STAT_R</p>
<table summary="Fields for Register: AUTO_CMD_STAT_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_15_8"></a>15:8</p>
</td>
<td>RSVD_15_8</td>
<td>R</td>
<td><p>These bits of the AUTO_CMD_STAT_R register are reserved bits. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_7"></a>7</p>
</td>
<td>CMD_NOT_ISSUED_AUTO_CMD12</td>
<td>R</td>
<td><p>Command Not Issued By Auto CMD12 Error</p>
<p class="BLANK"></p>
<p>If this bit is set to 1, CMD_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this register.</p>
<p class="BLANK"></p>
<p>This bit is set to 0 when Auto CMD Error is generated by Auto CMD23.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): Not Issued</li><li>0x0 (FALSE): No Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_6"></a>6</p>
</td>
<td>RSVD_6</td>
<td>R</td>
<td><p>This bit of the AUTO_CMD_STAR_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_5"></a>5</p>
</td>
<td>AUTO_CMD_RESP_ERR</td>
<td>R</td>
<td><p>Auto CMD Response Error</p>
<p class="BLANK"></p>
<p>This bit is set when Response Error Check Enable in the Transfer Mode register is set to 1 and an error is detected in R1 response of either Auto CMD12 or CMD13. This status is ignored if any bit between D00 to D04 is set to 1.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): Error</li><li>0x0 (FALSE): No Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_4"></a>4</p>
</td>
<td>AUTO_CMD_IDX_ERR</td>
<td>R</td>
<td><p>Auto CMD Index Error</p>
<p class="BLANK"></p>
<p>This bit is set if the command index error occurs in response to a command.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): Error</li><li>0x0 (FALSE): No Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_3"></a>3</p>
</td>
<td>AUTO_CMD_EBIT_ERR</td>
<td>R</td>
<td><p>Auto CMD End Bit Error</p>
<p class="BLANK"></p>
<p>This bit is set when detecting that the end bit of command response is 0.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): End Bit Error Generated</li><li>0x0 (FALSE): No Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_2"></a>2</p>
</td>
<td>AUTO_CMD_CRC_ERR</td>
<td>R</td>
<td><p>Auto CMD CRC Error</p>
<p class="BLANK"></p>
<p>This bit is set when detecting a CRC error in the command response.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): CRC Error Generated</li><li>0x0 (FALSE): No Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_1"></a>1</p>
</td>
<td>AUTO_CMD_TOUT_ERR</td>
<td>R</td>
<td><p>Auto CMD Timeout Error</p>
<p class="BLANK"></p>
<p>This bit is set if no response is returned with 64 SDCLK cycles from the end bit of the command.</p>
<p class="BLANK"></p>
<p>If this bit is set to 1, error status bits (D04-D01) are meaningless.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): Time out</li><li>0x0 (FALSE): No Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_AUTO_CMD_STAT_R_F_0"></a>0</p>
</td>
<td>AUTO_CMD12_NOT_EXEC</td>
<td>R</td>
<td><p>Auto CMD12 Not Executed</p>
<p class="BLANK"></p>
<p>If multiple memory block data transfer is not started due to a command error, this bit is not set because it is not necessary to issue an Auto CMD12. Setting this bit to 1 means that the Host Controller cannot issue Auto CMD12 to stop multiple memory block data transfer, due to some error. If this bit is set to 1, error status bits (D04-D01) is meaningless.</p>
<p class="BLANK"></p>
<p>This bit is set to 0 when Auto CMD Error is generated by Auto CMD23.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): Not Executed</li><li>0x0 (FALSE): Executed</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R"></a><span>HOST_CTRL2_R</span></p>
<ul><li><span>Name:</span>Host Control 2 Register</li><li><span>Description:</span>This register is used to control how the Host Controller operates. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x3e</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_15">15</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_14">14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_13">13</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_12">12</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_11">11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_9">9</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_8">8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_5_4">5:4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_2_0">2:0</a></td>
</tr>
<tr><td>PRESET_VAL_ENABLE</td>
<td>ASYNC_INT_ENABLE</td>
<td>ADDRESSING</td>
<td>HOST_VER4_ENABLE</td>
<td>CMD23_ENABLE</td>
<td>ADMA2_LEN_MODE</td>
<td>RSVD_9</td>
<td>UHS2_IF_ENABLE</td>
<td>SAMPLE_CLK_SEL</td>
<td>EXEC_TUNING</td>
<td>DRV_STRENGTH_SEL</td>
<td>SIGNALING_EN</td>
<td>UHS_MODE_SEL</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R"></a><p class="title">Table�27.�Fields for Register: HOST_CTRL2_R</p>
<table summary="Fields for Register: HOST_CTRL2_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_15"></a>15</p>
</td>
<td>PRESET_VAL_ENABLE</td>
<td>R/W</td>
<td><p>Preset Value Enable</p>
<p class="BLANK"></p>
<p>This bit enables automatic selection of SDCLK frequency and Driver strength Preset Value registers. When Preset Value Enable is set, SDCLK frequency generation (Frequency Select and Clock Generator
Select) and the driver strength selection are performed by the controller. These values are selected from set of Preset Value registers based on selected speed mode.</p>
<p class="BLANK"></p>
<p><span>Note:</span>For more information, see the FAQ on Preset Register in the DWC_mshc Databook.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): SDCLK and Driver Strength are controlled by Host Driver</li><li>0x1 (TRUE): Automatic Selection by Preset Value are Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_14"></a>14</p>
</td>
<td>ASYNC_INT_ENABLE</td>
<td>R/W</td>
<td><p>Asynchronous Interrupt Enable</p>
<p class="BLANK"></p>
<p>This bit can be set if a card supports asynchronous interrupts and Asynchronous Interrupt Support is set to 1 in the Capabilities register.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Disabled</li><li>0x1 (TRUE): Enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_13"></a>13</p>
</td>
<td>ADDRESSING</td>
<td>R/W</td>
<td><p>64-bit Addressing</p>
<p class="BLANK"></p>
<p>This bit is effective when Host Version 4 Enable is set to 1.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): 32 bits addressing</li><li>0x1 (TRUE): 64 bits addressing</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_12"></a>12</p>
</td>
<td>HOST_VER4_ENABLE</td>
<td>R/W</td>
<td><p>Host Version 4 Enable</p>
<p class="BLANK"></p>
<p>This bit selects either Version 3.00 compatible mode or Version 4 mode.</p>
<p class="BLANK"></p>
<p>Functions of following fields are modified for Host Version 4 mode:</p>
<ul><li>SDMA Address: SDMA uses ADMA System Address (05Fh-058h) instead of SDMA System Address register (003h-000h)</li><li>ADMA2/ADMA3 selection: ADMA3 is selected by DMA select in Host Control 1 register</li><li>64-bit ADMA Descriptor Size: 128-bit descriptor is used instead of 96-bit descriptor when 64-bit Addressing is set to 1</li><li>Selection of 32-bit/64-bit System Addressing: Either 32-bit or 64-bit system addressing is selected by 64-bit Addressing bit in this register</li><li>32-bit Block Count: SDMA System Address register (003h-000h) is modified to 32-bit Block Count register</li></ul><p></p>
<p class="BLANK"></p>
<p><span>Note:</span>It is recommended not to program ADMA3 Integrated Descriptor Address registers, and Command Queuing registers (if applicable) while operating in Host version less than 4 mode (Host Version 4 Enable = 0).</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Version 3.00 compatible mode</li><li>0x1 (TRUE): Version 4 mode</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_11"></a>11</p>
</td>
<td>CMD23_ENABLE</td>
<td>R/W</td>
<td><p>CMD23 Enable</p>
<p class="BLANK"></p>
<p>If the card supports CMD23, this bit is set to 1. This bit is used to select Auto CMD23 or Auto CMD12 for ADMA3 data transfer.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Auto CMD23 is disabled</li><li>0x1 (TRUE): Auto CMD23 is enabled</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_10"></a>10</p>
</td>
<td>ADMA2_LEN_MODE</td>
<td>R/W</td>
<td><p>ADMA2 Length Mode</p>
<p class="BLANK"></p>
<p>This bit selects ADMA2 Length mode to be either 16-bit or 26-bit.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): 16-bit Data Length Mode</li><li>0x1 (TRUE): 26-bit Data Length Mode</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_9"></a>9</p>
</td>
<td>RSVD_9</td>
<td>R</td>
<td><p>This bit of the HOST_CTRL2_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_8"></a>8</p>
</td>
<td>UHS2_IF_ENABLE</td>
<td>R/W</td>
<td><p>UHS-II Interface Enable</p>
<p class="BLANK"></p>
<p>This bit is used to enable the UHS-II Interface (Not supported). MSHC supports only SD/eMMC interface (value 0).</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): SD/eMMC Interface Enabled</li><li>0x1 (TRUE): UHS-II Interface Enabled - Not supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_7"></a>7</p>
</td>
<td>SAMPLE_CLK_SEL</td>
<td>R/W</td>
<td><p>Sampling Clock Select</p>
<p class="BLANK"></p>
<p>This bit is used by the Host Controller to select the sampling clock in SD/eMMC mode to receive CMD and DAT. This bit is set by the tuning procedure and is valid after the completion of tuning (when Execute Tuning is cleared). Setting this bit to 1 means that tuning is completed successfully and setting this bit to 0 means that tuning has failed. The value is reflected on the sample_cclk_sel pin.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Fixed clock is used to sample data</li><li>0x1 (TRUE): Tuned clock is used to sample data</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_6"></a>6</p>
</td>
<td>EXEC_TUNING</td>
<td>R/W</td>
<td><p>Execute Tuning</p>
<p class="BLANK"></p>
<p>This bit is set to 1 to start the tuning procedure in UHS-I/eMMC speed modes and this bit is automatically cleared when tuning procedure is completed.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Tuned or Tuning completed</li><li>0x1 (TRUE): Execute Tuning</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_5_4"></a>5:4</p>
</td>
<td>DRV_STRENGTH_SEL</td>
<td>R/W</td>
<td><p>Driver Strength Select</p>
<p class="BLANK"></p>
<p>This bit is used to select the Host Controller output driver in 1.8V signaling UHS-I/eMMC speed modes. The bit depends on setting of Preset Value Enable. The value is reflected on the uhs1_drv_sth pin.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (TYPEB): Driver TYPEB is selected</li><li>0x1 (TYPEA): Driver TYPEA is selected</li><li>0x2 (TYPEC): Driver TYPEC is selected</li><li>0x3 (TYPED): Driver TYPED is selected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_3"></a>3</p>
</td>
<td>SIGNALING_EN</td>
<td>R/W</td>
<td><p>1.8V Signaling Enable</p>
<p class="BLANK"></p>
<p>This bit controls voltage regulator for I/O cell in UHS-I/eMMC speed modes. Setting this bit from 0 to 1 starts changing the signal voltage from 3.3V to 1.8V. Host Controller clears this bit if switching to 1.8 signaling
fails. The value is reflected on the uhs1_swvolt_en pin.</p>
<p class="BLANK"></p>
<p><span>Note:</span>This bit must be set for all UHS-I speed modes (SDR12/SDR25/SDR50/SDR104/DDR50).</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (V_3_3): 3.3V Signalling</li><li>0x1 (V_1_8): 1.8V Signalling</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CTRL2_R_F_2_0"></a>2:0</p>
</td>
<td>UHS_MODE_SEL</td>
<td>R/W</td>
<td><p>UHS Mode/eMMC Speed Mode Select</p>
<p class="BLANK"></p>
<p>These bits are used to select UHS mode in the SD mode of operation.</p>
<p class="BLANK"></p>
<p class="BLANK"></p>
<p>UHS Mode (SD mode only):</p>
<ul><li>0x0: SDR12</li><li>0x1: SDR25</li><li>0x2: SDR50</li><li>0x3: SDR104</li><li>0x4: DDR50</li><li>0x5: Reserved</li><li>0x6: Reserved</li><li>0x7: Reserved</li></ul><p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (SDR12): SDR12/Legacy</li><li>0x1 (SDR25): SDR25/High Speed SDR</li><li>0x2 (SDR50): SDR50</li><li>0x3 (SDR104): SDR104/HS200</li><li>0x4 (DDR50): DDR50/High Speed DDR</li><li>0x5 (RSVD5): Reserved</li><li>0x6 (RSVD6): Reserved</li><li>0x7 (UHS2): HS400</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R"></a><span>CAPABILITIES1_R</span></p>
<ul><li><span>Name:</span>Capabilities 1 Register - 0 to 31</li><li><span>Description:</span>This register provides the Host Driver with information specific to the Host Controller implementation. The host controller may implement these values as fixed or loaded from the flash memory during power on initialization. Capabilities register is segregated into two 32-bit registers: CAPABILITIES1_R and CAPABILITIES2_R. The CAPABILITIES1_R register is the lower part of Capabilities register.</li><li><span>Size:</span>32 bits</li><li><span>Offset:</span>0x40</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_31_30">31:30</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_29">29</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_28">28</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_27">27</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_26">26</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_25">25</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_24">24</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_23">23</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_22">22</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_21">21</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_20">20</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_19">19</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_18">18</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_17_16">17:16</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_15_8">15:8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_5_0">5:0</a></td>
</tr>
<tr><td>SLOT_TYPE_R</td>
<td>ASYNC_INT_SUPPORT</td>
<td>SYS_ADDR_64_V3</td>
<td>SYS_ADDR_64_V4</td>
<td>VOLT_18</td>
<td>VOLT_30</td>
<td>VOLT_33</td>
<td>SUS_RES_SUPPORT</td>
<td>SDMA_SUPPORT</td>
<td>HIGH_SPEED_SUPPORT</td>
<td>RSVD_20</td>
<td>ADMA2_SUPPORT</td>
<td>Embedded_8_BIT</td>
<td>MAX_BLK_LEN</td>
<td>BASE_CLK_FREQ</td>
<td>TOUT_CLK_UNIT</td>
<td>RSVD_6</td>
<td>TOUT_CLK_FREQ</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R"></a><p class="title">Table�28.�Fields for Register: CAPABILITIES1_R</p>
<table summary="Fields for Register: CAPABILITIES1_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_31_30"></a>31:30</p>
</td>
<td>SLOT_TYPE_R</td>
<td>R</td>
<td><p>Slot Type</p>
<p class="BLANK"></p>
<p>These bits indicate usage of a slot by a specific Host System.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (REMOVABLE_SLOT): Removable Card Slot</li><li>0x1 (EMBEDDED_SLOT): Embedded Slot for one Device</li><li>0x2 (SHARED_SLOT): Shared Bus Slot (SD mode)</li><li>0x3 (UHS2_EMBEDDED_SLOT): Reserved</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_29"></a>29</p>
</td>
<td>ASYNC_INT_SUPPORT</td>
<td>R</td>
<td><p>Asynchronous Interrupt Support (SD Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Asynchronous Interrupt Not Supported</li><li>0x1 (TRUE): Asynchronous Interrupt Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_28"></a>28</p>
</td>
<td>SYS_ADDR_64_V3</td>
<td>R</td>
<td><p>64-bit System Address Support for V3</p>
<p class="BLANK"></p>
<p>This bit sets the Host controller to support 64-bit System Addressing of V3 mode.</p>
<p class="BLANK"></p>
<p>SDMA cannot be used in 64-bit Addressing in Version 3 Mode.</p>
<p class="BLANK"></p>
<p>If this bit is set to 1, 64-bit ADMA2 with using 96-bit Descriptor can be enabled by setting Host Version 4 Enable (<span><em>HOST_VER4_ENABLE</em></span>= 0) and DMA select (<span><em>DMA_SEL</em></span>= 11b).</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): 64-bit System Address for V3 is Not Supported</li><li>0x1 (TRUE): 64-bit System Address for V3 is Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_27"></a>27</p>
</td>
<td>SYS_ADDR_64_V4</td>
<td>R</td>
<td><p>64-bit System Address Support for V4</p>
<p class="BLANK"></p>
<p>This bit sets the Host Controller to support 64-bit System Addressing of V4 mode. When this bit is set to 1, full or part of 64-bit address must be used to decode the Host Controller Registers so that Host Controller Registers can be placed above system memory area. 64-bit address decode of Host Controller registers is effective regardless of setting to 64-bit Addressing in Host Control 2.</p>
<p class="BLANK"></p>
<p>If this bit is set to 1, 64-bit DMA Addressing for version 4 is enabled by setting Host Version 4 Enable
(<span><em>HOST_VER4_ENABLE</em></span>= 1) and by setting 64-bit Addressing (<span><em>ADDRESSING</em></span>=1) in the Host Control 2 register. SDMA can be used and ADMA2 uses 128-bit Descriptor.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): 64-bit System Address for V4 is Not Supported</li><li>0x1 (TRUE): 64-bit System Address for V4 is Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_26"></a>26</p>
</td>
<td>VOLT_18</td>
<td>R</td>
<td><p>Voltage Support for 1.8V</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): 1.8V Not Supported</li><li>0x1 (TRUE): 1.8V Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_25"></a>25</p>
</td>
<td>VOLT_30</td>
<td>R</td>
<td><p>Voltage Support for SD 3.0V or Embedded 1.2V</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): SD 3.0V or Embedded 1.2V Not Supported</li><li>0x1 (TRUE): SD 3.0V or Embedded Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_24"></a>24</p>
</td>
<td>VOLT_33</td>
<td>R</td>
<td><p>Voltage Support for 3.3V</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): 3.3V Not Supported</li><li>0x1 (TRUE): 3.3V Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_23"></a>23</p>
</td>
<td>SUS_RES_SUPPORT</td>
<td>R</td>
<td><p>Suspense/Resume Support</p>
<p class="BLANK"></p>
<p>This bit indicates whether the Host Controller supports Suspend/Resume functionality. If this bit is 0, the Host Driver does not issue either Suspend or Resume commands because the Suspend and Resume mechanism is not supported.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Supported</li><li>0x1 (TRUE): Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_22"></a>22</p>
</td>
<td>SDMA_SUPPORT</td>
<td>R</td>
<td><p>SDMA Support</p>
<p class="BLANK"></p>
<p>This bit indicates whether the Host Controller is capable of using SDMA to transfer data between the system memory and the Host Controller directly.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): SDMA not Supported</li><li>0x1 (TRUE): SDMA Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_21"></a>21</p>
</td>
<td>HIGH_SPEED_SUPPORT</td>
<td>R</td>
<td><p>High Speed Support</p>
<p class="BLANK"></p>
<p>This bit indicates whether the Host Controller and the Host System supports High Speed mode and they can supply the SD Clock frequency from 25 MHz to 50 MHz.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): High Speed not Supported</li><li>0x1 (TRUE): High Speed Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_20"></a>20</p>
</td>
<td>RSVD_20</td>
<td>R</td>
<td><p>This bit of the CAPABILITIES1_R is a reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_19"></a>19</p>
</td>
<td>ADMA2_SUPPORT</td>
<td>R</td>
<td><p>ADMA2 Support</p>
<p class="BLANK"></p>
<p>This bit indicates whether the Host Controller is capable of using ADMA2.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): ADMA2 not Supported</li><li>0x1 (TRUE): ADMA2 Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_18"></a>18</p>
</td>
<td>Embedded_8_BIT</td>
<td>R</td>
<td><p>8-bit Support for Embedded Device</p>
<p class="BLANK"></p>
<p>This bit indicates whether the Host Controller is capable of using an 8-bit bus width mode. This bit is not effective when the Slot Type is set to 10b.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): 8-bit Bus Width not Supported</li><li>0x1 (TRUE): 8-bit Bus Width Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_17_16"></a>17:16</p>
</td>
<td>MAX_BLK_LEN</td>
<td>R</td>
<td><p>Maximum Block Length</p>
<p class="BLANK"></p>
<p>This bit indicates the maximum block size that the Host driver can read and write to the buffer in the Host Controller. The buffer transfers this block size without wait cycles. The transfer block length is always 512 bytes for the SD Memory irrespective of this bit</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (ZERO): 512 Byte</li><li>0x1 (ONE): 1024 Byte</li><li>0x2 (TWO): 2048 Byte</li><li>0x3 (THREE): Reserved</li></ul><p></p>
<p><span>Value After Reset:</span>0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_15_8"></a>15:8</p>
</td>
<td>BASE_CLK_FREQ</td>
<td>R</td>
<td><p>Base Clock Frequency for SD clock</p>
<p class="BLANK"></p>
<p>These bits indicate the base (maximum) clock frequency for the SD Clock. The definition of these bits depend on the Host Controller Version.</p>
<ul><li>6-Bit Base Clock Frequency: This mode is supported by the Host Controller version 1.00 and 2.00. The upper 2 bits are not effective and are always 0. The unit values are 1 MHz. The supported clock range is 10 MHz to 63 MHz.<ul><li>0x00 : Get information through another method</li><li>0x01 : 1 MHz</li><li>0x02 : 2 MHz</li><li>.............</li><li>0x3F : 63 MHz</li><li>0x40-0xFF : Not Supported</li></ul></li><li>8-Bit Base Clock Frequency: This mode is supported by the Host Controller version 3.00. The unit values are 1 MHz. The supported clock range is 10 MHz to 255 MHz.<ul><li>0x00 : Get information through another method</li><li>0x01 : 1 MHz</li><li>0x02 : 2 MHz</li><li>............</li><li>0xFF : 255 MHz</li></ul></li></ul><p>If the frequency is 16.5 MHz, the larger value is set to 0001001b (17 MHz) because the Host Driver uses this value to calculate the clock divider value and it does not exceed the upper limit of the SD Clock frequency. If these bits are all 0, the Host system has to get information using a different method.</p>
<p><span>Value After Reset:</span>0x64</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_7"></a>7</p>
</td>
<td>TOUT_CLK_UNIT</td>
<td>R</td>
<td><p>Timeout Clock Unit</p>
<p class="BLANK"></p>
<p>This bit shows the unit of base clock frequency used to detect Data TImeout Error.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (KHZ): KHz</li><li>0x1 (MHZ): MHz</li></ul><p></p>
<p><span>Value After Reset:</span>0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_6"></a>6</p>
</td>
<td>RSVD_6</td>
<td>R</td>
<td><p>This bit of the CAPABILITIES1_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES1_R_F_5_0"></a>5:0</p>
</td>
<td>TOUT_CLK_FREQ</td>
<td>R</td>
<td><p>Timeout Clock Frequency</p>
<p class="BLANK"></p>
<p>This bit shows the base clock frequency used to detect Data Timeout Error. The Timeout Clock unit defines the unit of timeout clock frequency. It can be KHz or MHz.</p>
<ul><li>0x00 : Get information through another method</li><li>0x01 : 1KHz / 1MHz</li><li>0x02 : 2KHz / 2MHz</li><li>0x03 : 3KHz / 3MHz</li><li>...........</li><li>0x3F : 63KHz / 63MHz</li></ul><p></p>
<p><span>Value After Reset:</span>0x19</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R"></a><span>CAPABILITIES2_R</span></p>
<ul><li><span>Name:</span>Capabilities Register - 32 to 63</li><li><span>Description:</span>This register provides the Host Driver with information specific to the Host Controller implementation. The host controller may implement these values as fixed or as loaded from flash memory during power on initialization. Capabilities register is segregated into two 32-bit registers, namely CAPABILITIES1_R and CAPABILITIES2_R. The CAPABILITIES2_R register is upper part of Capabilities register.</li><li><span>Size:</span>32 bits</li><li><span>Offset:</span>0x44</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_31_30">31:30</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_29">29</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_28">28</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_27">27</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_26_24">26:24</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_23_16">23:16</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_15_14">15:14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_13">13</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_12">12</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_11_8">11:8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_0">0</a></td>
</tr>
<tr><td>RSVD_62_63</td>
<td>RSVD_61</td>
<td>VDD2_18V_SUPPORT</td>
<td>ADMA3_SUPPORT</td>
<td>RSVD_56_58</td>
<td>CLK_MUL</td>
<td>RE_TUNING_MODES</td>
<td>USE_TUNING_SDR50</td>
<td>RSVD_44</td>
<td>RETUNE_CNT</td>
<td>RSVD_39</td>
<td>DRV_TYPED</td>
<td>DRV_TYPEC</td>
<td>DRV_TYPEA</td>
<td>UHS2_SUPPORT</td>
<td>DDR50_SUPPORT</td>
<td>SDR104_SUPPORT</td>
<td>SDR50_SUPPORT</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R"></a><p class="title">Table�29.�Fields for Register: CAPABILITIES2_R</p>
<table summary="Fields for Register: CAPABILITIES2_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_31_30"></a>31:30</p>
</td>
<td>RSVD_62_63</td>
<td>R</td>
<td><p>These bits (RSVD_62_63) of the CAPABILITIES2_R register are reserved bits. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_29"></a>29</p>
</td>
<td>RSVD_61</td>
<td>R</td>
<td><p>This bit (RSVD_61) of the CAPABILITIES2_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_28"></a>28</p>
</td>
<td>VDD2_18V_SUPPORT</td>
<td>R</td>
<td><p>1.8V VDD2 Support</p>
<p class="BLANK"></p>
<p>This bit indicates support of VDD2 for the Host System.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): 1.8V VDD2 is not Supported</li><li>0x1 (TRUE): 1.8V VDD2 is Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_27"></a>27</p>
</td>
<td>ADMA3_SUPPORT</td>
<td>R</td>
<td><p>ADMA3 Support</p>
<p class="BLANK"></p>
<p>This bit indicates whether the Host Controller is capable of using ADMA3.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): ADMA3 not Supported</li><li>0x1 (TRUE): ADMA3 Supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_26_24"></a>26:24</p>
</td>
<td>RSVD_56_58</td>
<td>R</td>
<td><p>These bits (RSVD_56_58) of the CAPABILITIES2_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_23_16"></a>23:16</p>
</td>
<td>CLK_MUL</td>
<td>R</td>
<td><p>Clock Multiplier</p>
<p class="BLANK"></p>
<p>These bits indicate the clock multiplier of the programmable clock generator. Setting these bits to 0 means that the Host Controller does not support a programmable clock generator.</p>
<ul><li>0x0: Clock Multiplier is not Supported</li><li>0x1: Clock Multiplier M = 2</li><li>0x2: Clock Multiplier M = 3</li><li>.........</li><li>0xFF: Clock Multiplier M = 256</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_15_14"></a>15:14</p>
</td>
<td>RE_TUNING_MODES</td>
<td>R</td>
<td><p>Re-Tuning Modes (UHS-I only)</p>
<p class="BLANK"></p>
<p>These bits select the re-tuning method and limit the maximum data length.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (MODE1): Timer</li><li>0x1 (MODE2): Timer and Re-Tuning Request (Not supported)</li><li>0x2 (MODE3): Auto Re-Tuning (for transfer)</li><li>0x3 (RSVD_MODE): Reserved</li></ul><p></p>
<p><span>Value After Reset:</span>0x2</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_13"></a>13</p>
</td>
<td>USE_TUNING_SDR50</td>
<td>R</td>
<td><p>Use Tuning for SDR50 (UHS-I only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (ZERO): SDR50 does not require tuning</li><li>0x1 (ONE): SDR50 requires tuning</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_12"></a>12</p>
</td>
<td>RSVD_44</td>
<td>R</td>
<td><p>This bit (RSVD_44) of the CAPABILITIES2_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_11_8"></a>11:8</p>
</td>
<td>RETUNE_CNT</td>
<td>R</td>
<td><p>Timer Count for Re-Tuning (UHS-I only)</p>
<ul><li>0x0: Re-Tuning Timer disabled</li><li>0x1: 1 seconds</li><li>0x2: 2 seconds</li><li>0x3: 4 seconds</li><li>........</li><li>0xB: 1024 seconds</li><li>0xC: Reserved</li><li>0xD: Reserved</li><li>0xE: Reserved</li><li>0xF: Get information from other source</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_7"></a>7</p>
</td>
<td>RSVD_39</td>
<td>R</td>
<td><p>This bit (RSVD_39) of the CAPABILITIES2_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_6"></a>6</p>
</td>
<td>DRV_TYPED</td>
<td>R</td>
<td><p>Driver Type D Support (UHS-I only)</p>
<p class="BLANK"></p>
<p>This bit indicates support of Driver Type D for 1.8 Signaling.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Driver Type D is not supported</li><li>0x1 (TRUE): Driver Type D is supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_5"></a>5</p>
</td>
<td>DRV_TYPEC</td>
<td>R</td>
<td><p>Driver Type C Support (UHS-I only)</p>
<p class="BLANK"></p>
<p>This bit indicates support of Driver Type C for 1.8 Signaling.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Driver Type C is not supported</li><li>0x1 (TRUE): Driver Type C is supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_4"></a>4</p>
</td>
<td>DRV_TYPEA</td>
<td>R</td>
<td><p>Driver Type A Support (UHS-I only)</p>
<p class="BLANK"></p>
<p>This bit indicates support of Driver Type A for 1.8 Signaling.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Driver Type A is not supported</li><li>0x1 (TRUE): Driver Type A is supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x1</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_3"></a>3</p>
</td>
<td>UHS2_SUPPORT</td>
<td>R</td>
<td><p>UHS-II Support (UHS-II only - Not Supported)</p>
<p class="BLANK"></p>
<p>This bit indicates whether Host Controller supports UHS-II.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): UHS-II is not supported</li><li>0x1 (TRUE): UHS-II is supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_2"></a>2</p>
</td>
<td>DDR50_SUPPORT</td>
<td>R</td>
<td><p>DDR50 Support (UHS-I only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): DDR50 is not supported</li><li>0x1 (TRUE): DDR50 is supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_1"></a>1</p>
</td>
<td>SDR104_SUPPORT</td>
<td>R</td>
<td><p>SDR104 Support (UHS-I only)</p>
<p class="BLANK"></p>
<p>This bit mentions that SDR104 requires tuning.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): SDR104 is not supported</li><li>0x1 (TRUE): SDR104 is supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CAPABILITIES2_R_F_0"></a>0</p>
</td>
<td>SDR50_SUPPORT</td>
<td>R</td>
<td><p>SDR50 Support (UHS-I only)</p>
<p class="BLANK"></p>
<p>This bit indicates that SDR50 is supported. The bit 13 (USE_TUNING_SDR50) indicates whether SDR50 requires tuning or not.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): SDR50 is not supported</li><li>0x1 (TRUE): SDR50 is supported</li></ul><p></p>
<p><span>Value After Reset:</span>0x1</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES1_R"></a><span>CURR_CAPABILITIES1_R</span></p>
<ul><li><span>Name:</span>Maximum Current Capabilities Register - 0 to 31</li><li><span>Description:</span>This register indicate the maximum current capability for each voltage, for VDD1. The value is meaningful if the Voltage Support is set in the Capabilities
register. If this information is supplied by the Host System through another method, all the Maximum Current Capabilities registers are set to 0.</li><li><span>Size:</span>32 bits</li><li><span>Offset:</span>0x48</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES1_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES1_R_F_31_24">31:24</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES1_R_F_23_16">23:16</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES1_R_F_15_8">15:8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES1_R_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_31_24</td>
<td>MAX_CUR_18V</td>
<td>MAX_CUR_30V</td>
<td>MAX_CUR_33V</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES1_R"></a><p class="title">Table�30.�Fields for Register: CURR_CAPABILITIES1_R</p>
<table summary="Fields for Register: CURR_CAPABILITIES1_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES1_R_F_31_24"></a>31:24</p>
</td>
<td>RSVD_31_24</td>
<td>R</td>
<td><p>These bits of the CURR_CAPABILITIES1_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES1_R_F_23_16"></a>23:16</p>
</td>
<td>MAX_CUR_18V</td>
<td>R</td>
<td><p>Maximum Current for 1.8V</p>
<p class="BLANK"></p>
<p>This bit specifies the Maximum Current for 1.8V VDD1 power supply for the card.</p>
<ul><li>0: Get information through another method</li><li>1: 4mA</li><li>2: 8mA</li><li>3: 13mA</li><li>.......</li><li>255: 1020mA</li></ul><p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES1_R_F_15_8"></a>15:8</p>
</td>
<td>MAX_CUR_30V</td>
<td>R</td>
<td><p>Maximum Current for 3.0V</p>
<p class="BLANK"></p>
<p>This bit specifies the Maximum Current for 3.0V VDD1 power supply for the card.</p>
<ul><li>0: Get information through another method</li><li>1: 4mA</li><li>2: 8mA</li><li>3: 13mA</li><li>.......</li><li>255: 1020mA</li></ul><p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES1_R_F_7_0"></a>7:0</p>
</td>
<td>MAX_CUR_33V</td>
<td>R</td>
<td><p>Maximum Current for 3.3V</p>
<p class="BLANK"></p>
<p>This bit specifies the Maximum Current for 3.3V VDD1 power supply for the card.</p>
<ul><li>0: Get information through another method</li><li>1: 4mA</li><li>2: 8mA</li><li>3: 13mA</li><li>.......</li><li>255: 1020mA</li></ul><p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES2_R"></a><span>CURR_CAPABILITIES2_R</span></p>
<ul><li><span>Name:</span>Maximum Current Capabilities Register - 32 to 63</li><li><span>Description:</span>This register indicates the maximum current capability for each voltage (for VDD2). The value is meaningful if Voltage Support is set in the Capabilities
register. If this information is supplied by the Host System through another method, all the Maximum Current Capabilities registers are set to 0.</li><li><span>Size:</span>32 bits</li><li><span>Offset:</span>0x4c</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES2_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES2_R_F_31_8">31:8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES2_R_F_7_0">7:0</a></td>
</tr>
<tr><td>RSVD_63_40</td>
<td>MAX_CUR_VDD2_18V</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES2_R"></a><p class="title">Table�31.�Fields for Register: CURR_CAPABILITIES2_R</p>
<table summary="Fields for Register: CURR_CAPABILITIES2_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES2_R_F_31_8"></a>31:8</p>
</td>
<td>RSVD_63_40</td>
<td>R</td>
<td><p>These bits of the CURR_CAPABILITIES2_R register are reserved. They always return 0.</p>
<p><span>Reserved Field:</span>Yes</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_CURR_CAPABILITIES2_R_F_7_0"></a>7:0</p>
</td>
<td>MAX_CUR_VDD2_18V</td>
<td>R</td>
<td><p>&lt;Reserved</p>
<ul><li>0: Get information through another method</li><li>1: 4mA</li><li>2: 8mA</li><li>3: 13mA</li><li>.......</li><li>255: 1020mA</li></ul><p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R"></a><span>FORCE_AUTO_CMD_STAT_R</span></p>
<ul><li><span>Name:</span>Force Event Register for Auto CMD Error Status register</li><li><span>Description:</span>The register is not a physically implemented but is an address at which the Auto CMD Error Status register can be written. This register is applicable for an SD/eMMC mode.<ul><li>1 : Sets each bit of the Auto CMD Error Status register</li><li>0 : No effect</li></ul></li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x50</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_15_8">15:8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_0">0</a></td>
</tr>
<tr><td>RSVD_15_8</td>
<td>FORCE_CMD_NOT_ISSUED_AUTO_CMD12</td>
<td>RSVD_6</td>
<td>FORCE_AUTO_CMD_RESP_ERR</td>
<td>FORCE_AUTO_CMD_IDX_ERR</td>
<td>FORCE_AUTO_CMD_EBIT_ERR</td>
<td>FORCE_AUTO_CMD_CRC_ERR</td>
<td>FORCE_AUTO_CMD_TOUT_ERR</td>
<td>FORCE_AUTO_CMD12_NOT_EXEC</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R"></a><p class="title">Table�32.�Fields for Register: FORCE_AUTO_CMD_STAT_R</p>
<table summary="Fields for Register: FORCE_AUTO_CMD_STAT_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_15_8"></a>15:8</p>
</td>
<td>RSVD_15_8</td>
<td>R</td>
<td><p>These bits of the FORCE_AUTO_CMD_STAT_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_7"></a>7</p>
</td>
<td>FORCE_CMD_NOT_ISSUED_AUTO_CMD12</td>
<td>W</td>
<td><p>Force Event for Command Not Issued By Auto CMD12 Error</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): Command Not Issued By Auto CMD12 Error Status is set</li><li>0x0 (FALSE): Not Affected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_6"></a>6</p>
</td>
<td>RSVD_6</td>
<td>R</td>
<td><p>This bit of the FORCE_AUTO_CMD_STAT_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_5"></a>5</p>
</td>
<td>FORCE_AUTO_CMD_RESP_ERR</td>
<td>W</td>
<td><p>Force Event for Auto CMD Response Error</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): Auto CMD Response Error Status is set</li><li>0x0 (FALSE): Not Affected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_4"></a>4</p>
</td>
<td>FORCE_AUTO_CMD_IDX_ERR</td>
<td>W</td>
<td><p>Force Event for Auto CMD Index Error</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): Auto CMD Index Error Status is set</li><li>0x0 (FALSE): Not Affected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_3"></a>3</p>
</td>
<td>FORCE_AUTO_CMD_EBIT_ERR</td>
<td>W</td>
<td><p>Force Event for Auto CMD End Bit Error</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): Auto CMD End Bit Error Status is set</li><li>0x0 (FALSE): Not Affected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_2"></a>2</p>
</td>
<td>FORCE_AUTO_CMD_CRC_ERR</td>
<td>W</td>
<td><p>Force Event for Auto CMD CRC Error</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): Auto CMD CRC Error Status is set</li><li>0x0 (FALSE): Not Affected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_1"></a>1</p>
</td>
<td>FORCE_AUTO_CMD_TOUT_ERR</td>
<td>W</td>
<td><p>Force Event for Auto CMD Timeout Error</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): Auto CMD Timeout Error Status is set</li><li>0x0 (FALSE): Not Affected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_AUTO_CMD_STAT_R_F_0"></a>0</p>
</td>
<td>FORCE_AUTO_CMD12_NOT_EXEC</td>
<td>W</td>
<td><p>Force Event for Auto CMD12 Not Executed</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x1 (TRUE): Auto CMD12 Not Executed Status is set</li><li>0x0 (FALSE): Not Affected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R"></a><span>FORCE_ERROR_INT_STAT_R</span></p>
<ul><li><span>Name:</span>Force Event Register for Error Interrupt Status</li><li><span>Description:</span>This register is not physically implemented but is an address at which the Error Interrupt Status register can be written. The effect of a write to this
address is reflected in the Error Interrupt Status register if the corresponding bit of the Error Interrupt Status Enable register is set. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x52</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_15">15</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_14">14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_13">13</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_12">12</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_11">11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_9">9</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_8">8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_7">7</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_6">6</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_5">5</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_4">4</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_3">3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_1">1</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_0">0</a></td>
</tr>
<tr><td>FORCE_VENDOR_ERR3</td>
<td>FORCE_VENDOR_ERR2</td>
<td>FORCE_VENDOR_ERR1</td>
<td>FORCE_BOOT_ACK_ERR</td>
<td>FORCE_RESP_ERR</td>
<td>FORCE_TUNING_ERR</td>
<td>FORCE_ADMA_ERR</td>
<td>FORCE_AUTO_CMD_ERR</td>
<td>FORCE_CUR_LMT_ERR</td>
<td>FORCE_DATA_END_BIT_ERR</td>
<td>FORCE_DATA_CRC_ERR</td>
<td>FORCE_DATA_TOUT_ERR</td>
<td>FORCE_CMD_IDX_ERR</td>
<td>FORCE_CMD_END_BIT_ERR</td>
<td>FORCE_CMD_CRC_ERR</td>
<td>FORCE_CMD_TOUT_ERR</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R"></a><p class="title">Table�33.�Fields for Register: FORCE_ERROR_INT_STAT_R</p>
<table summary="Fields for Register: FORCE_ERROR_INT_STAT_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_15"></a>15</p>
</td>
<td>FORCE_VENDOR_ERR3</td>
<td>W</td>
<td><p>This bit (FORCE_VENDOR_ERR3) of the FORCE_ERROR_INT_STAT_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_14"></a>14</p>
</td>
<td>FORCE_VENDOR_ERR2</td>
<td>W</td>
<td><p>This bit (FORCE_VENDOR_ERR2) of the FORCE_ERROR_INT_STAT_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_13"></a>13</p>
</td>
<td>FORCE_VENDOR_ERR1</td>
<td>W</td>
<td><p>This bit (FORCE_VENDOR_ERR1) of the FORCE_ERROR_INT_STAT_R register is reserved. It always returns 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_12"></a>12</p>
</td>
<td>FORCE_BOOT_ACK_ERR</td>
<td>W</td>
<td><p>Force Event for Boot Ack error</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Affected</li><li>0x1 (TRUE): Boot ack Error Status is set</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_11"></a>11</p>
</td>
<td>FORCE_RESP_ERR</td>
<td>W</td>
<td><p>Force Event for Response Error (SD Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Affected</li><li>0x1 (TRUE): Response Error Status is set</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_10"></a>10</p>
</td>
<td>FORCE_TUNING_ERR</td>
<td>W</td>
<td><p>Force Event for Tuning Error (UHS-I Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Affected</li><li>0x1 (TRUE): Tuning Error Status is set</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_9"></a>9</p>
</td>
<td>FORCE_ADMA_ERR</td>
<td>W</td>
<td><p>Force Event for ADMA Error</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Affected</li><li>0x1 (TRUE): ADMA Error Status is set</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_8"></a>8</p>
</td>
<td>FORCE_AUTO_CMD_ERR</td>
<td>W</td>
<td><p>Force Event for Auto CMD Error (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Affected</li><li>0x1 (TRUE): Auto CMD Error Status is set</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_7"></a>7</p>
</td>
<td>FORCE_CUR_LMT_ERR</td>
<td>W</td>
<td><p>Force Event for Current Limit Error</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Affected</li><li>0x1 (TRUE): Current Limit Error Status is set</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_6"></a>6</p>
</td>
<td>FORCE_DATA_END_BIT_ERR</td>
<td>W</td>
<td><p>Force Event for Data End Bit Error (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Affected</li><li>0x1 (TRUE): Data End Bit Error Status is set</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_5"></a>5</p>
</td>
<td>FORCE_DATA_CRC_ERR</td>
<td>W</td>
<td><p>Force Event for Data CRC Error (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Affected</li><li>0x1 (TRUE): Data CRC Error Status is set</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_4"></a>4</p>
</td>
<td>FORCE_DATA_TOUT_ERR</td>
<td>W</td>
<td><p>Force Event for Data Timeout Error (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Affected</li><li>0x1 (TRUE): Data Timeout Error Status is set</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_3"></a>3</p>
</td>
<td>FORCE_CMD_IDX_ERR</td>
<td>W</td>
<td><p>Force Event for Command Index Error (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Affected</li><li>0x1 (TRUE): Command Index Error Status is set</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_2"></a>2</p>
</td>
<td>FORCE_CMD_END_BIT_ERR</td>
<td>W</td>
<td><p>Force Event for Command End Bit Error (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Affected</li><li>0x1 (TRUE): Command End Bit Error Status is set</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_1"></a>1</p>
</td>
<td>FORCE_CMD_CRC_ERR</td>
<td>W</td>
<td><p>Force Event for Command CRC Error (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Affected</li><li>0x1 (TRUE): Command CRC Error Status is set</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_FORCE_ERROR_INT_STAT_R_F_0"></a>0</p>
</td>
<td>FORCE_CMD_TOUT_ERR</td>
<td>W</td>
<td><p>Force Event for Command Timeout Error (SD/eMMC Mode only)</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Not Affected</li><li>0x1 (TRUE): Command Timeout Error Status is set</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ADMA_ERR_STAT_R"></a><span>ADMA_ERR_STAT_R</span></p>
<ul><li><span>Name:</span>ADMA Error Status Register</li><li><span>Description:</span>This register stores the ADMA state during an ADMA error. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>8 bits</li><li><span>Offset:</span>0x54</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_ADMA_ERR_STAT_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ADMA_ERR_STAT_R_F_7_3">7:3</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ADMA_ERR_STAT_R_F_2">2</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ADMA_ERR_STAT_R_F_1_0">1:0</a></td>
</tr>
<tr><td>RSVD_7_3</td>
<td>ADMA_LEN_ERR</td>
<td>ADMA_ERR_STATES</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_ADMA_ERR_STAT_R"></a><p class="title">Table�34.�Fields for Register: ADMA_ERR_STAT_R</p>
<table summary="Fields for Register: ADMA_ERR_STAT_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ADMA_ERR_STAT_R_F_7_3"></a>7:3</p>
</td>
<td>RSVD_7_3</td>
<td>R</td>
<td><p>These bits of the ADMA_ERR_STAT_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ADMA_ERR_STAT_R_F_2"></a>2</p>
</td>
<td>ADMA_LEN_ERR</td>
<td>R</td>
<td><p>ADMA Length Mismatch Error States</p>
<p class="BLANK"></p>
<p>This error occurs in the following instances:</p>
<ul><li>While the Block Count Enable is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length</li><li>When the total data length cannot be divided by the block length</li></ul><p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (NO_ERR): No Error</li><li>0x1 (ERROR): Error</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ADMA_ERR_STAT_R_F_1_0"></a>1:0</p>
</td>
<td>ADMA_ERR_STATES</td>
<td>R</td>
<td><p>ADMA Error States</p>
<p class="BLANK"></p>
<p>These bits indicate the state of ADMA when an error occurs during ADMA data transfer.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (ST_STOP): Stop DMA - SYS_ADR register points to a location next to the error descriptor</li><li>0x1 (ST_FDS): Fetch Descriptor - SYS_ADR register points to the error descriptor</li><li>0x2 (UNUSED): Never set this state</li><li>0x3 (ST_TFR): Transfer Data - SYS_ADR register points to a location next to the error descriptor</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ADMA_SA_LOW_R"></a><span>ADMA_SA_LOW_R</span></p>
<ul><li><span>Name:</span>ADMA System Address Register - Low</li><li><span>Description:</span>This register holds the lower 32-bit system address for DMA transfer. This register is applicable for an SD/eMMC mode.</li><li><span>Size:</span>32 bits</li><li><span>Offset:</span>0x58</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_ADMA_SA_LOW_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_ADMA_SA_LOW_R_F_31_0">31:0</a></td>
</tr>
<tr><td>ADMA_SA_LOW</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_ADMA_SA_LOW_R"></a><p class="title">Table�35.�Fields for Register: ADMA_SA_LOW_R</p>
<table summary="Fields for Register: ADMA_SA_LOW_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_ADMA_SA_LOW_R_F_31_0"></a>31:0</p>
</td>
<td>ADMA_SA_LOW</td>
<td>R/W</td>
<td><p>ADMA System Address</p>
<p class="BLANK"></p>
<p>These bits indicate the lower 32 bits of the ADMA system address.</p>
<ul><li>SDMA: If Host Version 4 Enable is set to 1, this register stores the system address of the data location</li><li>ADMA2: This register stores the byte address of the executing command of the descriptor table</li><li>ADMA3: This register is set by ADMA3. ADMA2 increments the address of this register that points to the next line, every time a Descriptor line is fetched.</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_INIT_R"></a><span>PRESET_INIT_R</span></p>
<ul><li><span>Name:</span>Preset Value for Initialization</li><li><span>Description:</span>This register defines Preset Value for Initialization in SD/eMMC mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x60</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_PRESET_INIT_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_INIT_R_F_15_14">15:14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_INIT_R_F_13_11">13:11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_INIT_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_INIT_R_F_9_0">9:0</a></td>
</tr>
<tr><td>DRV_SEL_VAL</td>
<td>RSVD_13_11</td>
<td>CLK_GEN_SEL_VAL</td>
<td>FREQ_SEL_VAL</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_PRESET_INIT_R"></a><p class="title">Table�36.�Fields for Register: PRESET_INIT_R</p>
<table summary="Fields for Register: PRESET_INIT_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_INIT_R_F_15_14"></a>15:14</p>
</td>
<td>DRV_SEL_VAL</td>
<td>R</td>
<td><p>Driver Strength Select Value</p>
<p class="BLANK"></p>
<p>These bits indicate that the Driver strength is supported by 1.8V signaling bus speed modes. These bits are meaningless for 3.3V signaling.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (TYPEB): Driver Type B is selected</li><li>0x1 (TYPEA): Driver Type A is selected</li><li>0x2 (TYPEC): Driver Type C is selected</li><li>0x3 (TYPED): Driver Type D is selected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_INIT_R_F_13_11"></a>13:11</p>
</td>
<td>RSVD_13_11</td>
<td>R</td>
<td><p>These bits of the PRESET_INIT_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_INIT_R_F_10"></a>10</p>
</td>
<td>CLK_GEN_SEL_VAL</td>
<td>R</td>
<td><p>Clock Generator Select Value</p>
<p class="BLANK"></p>
<p>This bit is effective when the Host Controller supports a programmable clock generator.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator</li><li>0x1 (PROG): Programmable Clock Generator</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_INIT_R_F_9_0"></a>9:0</p>
</td>
<td>FREQ_SEL_VAL</td>
<td>R</td>
<td><p>SDCLK/RCLK Frequency Select Value</p>
<p class="BLANK"></p>
<p>10-bit preset value to be set in SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DS_R"></a><span>PRESET_DS_R</span></p>
<ul><li><span>Name:</span>Preset Value for Default Speed</li><li><span>Description:</span>This register defines Preset Value for Default Speed mode in SD mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x62</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_PRESET_DS_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DS_R_F_15_14">15:14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DS_R_F_13_11">13:11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DS_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DS_R_F_9_0">9:0</a></td>
</tr>
<tr><td>DRV_SEL_VAL</td>
<td>RSVD_13_11</td>
<td>CLK_GEN_SEL_VAL</td>
<td>FREQ_SEL_VAL</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_PRESET_DS_R"></a><p class="title">Table�37.�Fields for Register: PRESET_DS_R</p>
<table summary="Fields for Register: PRESET_DS_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DS_R_F_15_14"></a>15:14</p>
</td>
<td>DRV_SEL_VAL</td>
<td>R</td>
<td><p>Driver Strength Select Value</p>
<p class="BLANK"></p>
<p>These bits indicate the Driver strength value supported by 1.8V signaling bus speed modes. This field is meaningless for the Default speed mode as it uses 3.3V signaling.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (TYPEB): Driver Type B is selected</li><li>0x1 (TYPEA): Driver Type A is selected</li><li>0x2 (TYPEC): Driver Type C is selected</li><li>0x3 (TYPED): Driver Type D is selected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DS_R_F_13_11"></a>13:11</p>
</td>
<td>RSVD_13_11</td>
<td>R</td>
<td><p>These bits of the PRESET_DS_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DS_R_F_10"></a>10</p>
</td>
<td>CLK_GEN_SEL_VAL</td>
<td>R</td>
<td><p>Clock Generator Select Value</p>
<p class="BLANK"></p>
<p>This bit is effective when Host Controller supports programmable clock generator.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator</li><li>0x1 (PROG): Programmable Clock Generator</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DS_R_F_9_0"></a>9:0</p>
</td>
<td>FREQ_SEL_VAL</td>
<td>R</td>
<td><p>SDCLK/RCLK Frequency Select Value</p>
<p class="BLANK"></p>
<p>10-bit preset value to be set in SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_HS_R"></a><span>PRESET_HS_R</span></p>
<ul><li><span>Name:</span>Preset Value for High Speed</li><li><span>Description:</span>This register defines Preset Value for High Speed mode in SD mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x64</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_PRESET_HS_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_HS_R_F_15_14">15:14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_HS_R_F_13_11">13:11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_HS_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_HS_R_F_9_0">9:0</a></td>
</tr>
<tr><td>DRV_SEL_VAL</td>
<td>RSVD_13_11</td>
<td>CLK_GEN_SEL_VAL</td>
<td>FREQ_SEL_VAL</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_PRESET_HS_R"></a><p class="title">Table�38.�Fields for Register: PRESET_HS_R</p>
<table summary="Fields for Register: PRESET_HS_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_HS_R_F_15_14"></a>15:14</p>
</td>
<td>DRV_SEL_VAL</td>
<td>R</td>
<td><p>Driver Strength Select Value</p>
<p class="BLANK"></p>
<p>These bits indicate the Driver strength value supported by 1.8V signaling bus speed modes. This field is meaningless for High speed mode as it uses 3.3V signaling.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (TYPEB): Driver Type B is selected</li><li>0x1 (TYPEA): Driver Type A is selected</li><li>0x2 (TYPEC): Driver Type C is selected</li><li>0x3 (TYPED): Driver Type D is selected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_HS_R_F_13_11"></a>13:11</p>
</td>
<td>RSVD_13_11</td>
<td>R</td>
<td><p>These bits of the PRESET_HS_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_HS_R_F_10"></a>10</p>
</td>
<td>CLK_GEN_SEL_VAL</td>
<td>R</td>
<td><p>Clock Generator Select Value</p>
<p class="BLANK"></p>
<p>This bit is effective when Host Controller supports programmable clock generator.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator</li><li>0x1 (PROG): Programmable Clock Generator</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_HS_R_F_9_0"></a>9:0</p>
</td>
<td>FREQ_SEL_VAL</td>
<td>R</td>
<td><p>SDCLK/RCLK Frequency Select Value</p>
<p class="BLANK"></p>
<p>10-bit preset value to be set in SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR12_R"></a><span>PRESET_SDR12_R</span></p>
<ul><li><span>Name:</span>Preset Value for SDR12</li><li><span>Description:</span>This register defines Preset Value for SDR12 and Legacy speed mode in SD and eMMC mode respectively.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x66</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_PRESET_SDR12_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR12_R_F_15_14">15:14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR12_R_F_13_11">13:11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR12_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR12_R_F_9_0">9:0</a></td>
</tr>
<tr><td>DRV_SEL_VAL</td>
<td>RSVD_13_11</td>
<td>CLK_GEN_SEL_VAL</td>
<td>FREQ_SEL_VAL</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_PRESET_SDR12_R"></a><p class="title">Table�39.�Fields for Register: PRESET_SDR12_R</p>
<table summary="Fields for Register: PRESET_SDR12_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR12_R_F_15_14"></a>15:14</p>
</td>
<td>DRV_SEL_VAL</td>
<td>R</td>
<td><p>Driver Strength Select Value</p>
<p class="BLANK"></p>
<p>These bits indicate the Driver strength value supported for the SDR12 bus speed mode. These bits are meaningless for 3.3V signaling.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (TYPEB): Driver Type B is selected</li><li>0x1 (TYPEA): Driver Type A is selected</li><li>0x2 (TYPEC): Driver Type C is selected</li><li>0x3 (TYPED): Driver Type D is selected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR12_R_F_13_11"></a>13:11</p>
</td>
<td>RSVD_13_11</td>
<td>R</td>
<td><p>These bits of the PRESET_SDR12_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR12_R_F_10"></a>10</p>
</td>
<td>CLK_GEN_SEL_VAL</td>
<td>R</td>
<td><p>Clock Generator Select Value</p>
<p class="BLANK"></p>
<p>This bit is effective when Host Controller supports programmable clock generator</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator</li><li>0x1 (PROG): Programmable Clock Generator</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR12_R_F_9_0"></a>9:0</p>
</td>
<td>FREQ_SEL_VAL</td>
<td>R</td>
<td><p>SDCLK/RCLK Frequency Select Value</p>
<p class="BLANK"></p>
<p>10-bit preset value to be set in SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR25_R"></a><span>PRESET_SDR25_R</span></p>
<ul><li><span>Name:</span>Preset Value for SDR25</li><li><span>Description:</span>This register defines Preset Value for SDR25 and High Speed SDR speed mode in SD and eMMC mode respectively.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x68</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_PRESET_SDR25_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR25_R_F_15_14">15:14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR25_R_F_13_11">13:11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR25_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR25_R_F_9_0">9:0</a></td>
</tr>
<tr><td>DRV_SEL_VAL</td>
<td>RSVD_13_11</td>
<td>CLK_GEN_SEL_VAL</td>
<td>FREQ_SEL_VAL</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_PRESET_SDR25_R"></a><p class="title">Table�40.�Fields for Register: PRESET_SDR25_R</p>
<table summary="Fields for Register: PRESET_SDR25_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR25_R_F_15_14"></a>15:14</p>
</td>
<td>DRV_SEL_VAL</td>
<td>R</td>
<td><p>Driver Strength Select Value</p>
<p class="BLANK"></p>
<p>These bits indicate the Driver strength value supported for the SDR25 bus speed mode. These bits are meaningless for 3.3V signaling.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (TYPEB): Driver Type B is selected</li><li>0x1 (TYPEA): Driver Type A is selected</li><li>0x2 (TYPEC): Driver Type C is selected</li><li>0x3 (TYPED): Driver Type D is selected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR25_R_F_13_11"></a>13:11</p>
</td>
<td>RSVD_13_11</td>
<td>R</td>
<td><p>These bits of the PRESET_SDR25_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR25_R_F_10"></a>10</p>
</td>
<td>CLK_GEN_SEL_VAL</td>
<td>R</td>
<td><p>Clock Generator Select Value</p>
<p class="BLANK"></p>
<p>This bit is effective when Host Controller supports programmable clock generator.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator</li><li>0x1 (PROG): Programmable Clock Generator</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR25_R_F_9_0"></a>9:0</p>
</td>
<td>FREQ_SEL_VAL</td>
<td>R</td>
<td><p>SDCLK/RCLK Frequency Select Value</p>
<p class="BLANK"></p>
<p>10-bit preset value to be set in SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR50_R"></a><span>PRESET_SDR50_R</span></p>
<ul><li><span>Name:</span>Preset Value for SDR50</li><li><span>Description:</span>This register defines Preset Value for SDR50 speed mode in SD mode.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x6a</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_PRESET_SDR50_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR50_R_F_15_14">15:14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR50_R_F_13_11">13:11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR50_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR50_R_F_9_0">9:0</a></td>
</tr>
<tr><td>DRV_SEL_VAL</td>
<td>RSVD_13_11</td>
<td>CLK_GEN_SEL_VAL</td>
<td>FREQ_SEL_VAL</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_PRESET_SDR50_R"></a><p class="title">Table�41.�Fields for Register: PRESET_SDR50_R</p>
<table summary="Fields for Register: PRESET_SDR50_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR50_R_F_15_14"></a>15:14</p>
</td>
<td>DRV_SEL_VAL</td>
<td>R</td>
<td><p>Driver Strength Select Value</p>
<p class="BLANK"></p>
<p>These bits indicate Driver strength value supported for SDR50 bus speed mode. These bits are meaningless for 3.3V signaling.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (TYPEB): Driver Type B is selected</li><li>0x1 (TYPEA): Driver Type A is selected</li><li>0x2 (TYPEC): Driver Type C is selected</li><li>0x3 (TYPED): Driver Type D is selected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR50_R_F_13_11"></a>13:11</p>
</td>
<td>RSVD_13_11</td>
<td>R</td>
<td><p>These bits of the PRESET_SDR50_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR50_R_F_10"></a>10</p>
</td>
<td>CLK_GEN_SEL_VAL</td>
<td>R</td>
<td><p>Clock Generator Select Value</p>
<p class="BLANK"></p>
<p>This bit is effective when Host Controller supports programmable clock generator.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator</li><li>0x1 (PROG): Programmable Clock Generator</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR50_R_F_9_0"></a>9:0</p>
</td>
<td>FREQ_SEL_VAL</td>
<td>R</td>
<td><p>SDCLK/RCLK Frequency Select Value</p>
<p class="BLANK"></p>
<p>10-bit preset value to be set in SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR104_R"></a><span>PRESET_SDR104_R</span></p>
<ul><li><span>Name:</span>Preset Value for SDR104</li><li><span>Description:</span>This register defines Preset Value for SDR104 and HS200 speed modes in the SD and eMMC modes, respectively.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x6c</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_PRESET_SDR104_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR104_R_F_15_14">15:14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR104_R_F_13_11">13:11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR104_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR104_R_F_9_0">9:0</a></td>
</tr>
<tr><td>DRV_SEL_VAL</td>
<td>RSVD_13_11</td>
<td>CLK_GEN_SEL_VAL</td>
<td>FREQ_SEL_VAL</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_PRESET_SDR104_R"></a><p class="title">Table�42.�Fields for Register: PRESET_SDR104_R</p>
<table summary="Fields for Register: PRESET_SDR104_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR104_R_F_15_14"></a>15:14</p>
</td>
<td>DRV_SEL_VAL</td>
<td>R</td>
<td><p>Driver Strength Select Value</p>
<p class="BLANK"></p>
<p>These bits indicate Driver strength value supported for SDR104 bus speed mode. These bits are meaningless for 3.3V signaling.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (TYPEB): Driver Type B is selected</li><li>0x1 (TYPEA): Driver Type A is selected</li><li>0x2 (TYPEC): Driver Type C is selected</li><li>0x3 (TYPED): Driver Type D is selected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR104_R_F_13_11"></a>13:11</p>
</td>
<td>RSVD_13_11</td>
<td>R</td>
<td><p>These bits of the PRESET_SDR104_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR104_R_F_10"></a>10</p>
</td>
<td>CLK_GEN_SEL_VAL</td>
<td>R</td>
<td><p>Clock Generator Select Value</p>
<p class="BLANK"></p>
<p>This bit is effective when Host Controller supports programmable clock generator.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator</li><li>0x1 (PROG): Programmable Clock Generator</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_SDR104_R_F_9_0"></a>9:0</p>
</td>
<td>FREQ_SEL_VAL</td>
<td>R</td>
<td><p>SDCLK/RCLK Frequency Select Value</p>
<p class="BLANK"></p>
<p>These bits specify a 10-bit preset value that must be set in the SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DDR50_R"></a><span>PRESET_DDR50_R</span></p>
<ul><li><span>Name:</span>Preset Value for DDR50</li><li><span>Description:</span>This register defines the Preset Value for DDR50 and High Speed DDR speed modes in the SD and eMMC modes, respectively.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x6e</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_PRESET_DDR50_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DDR50_R_F_15_14">15:14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DDR50_R_F_13_11">13:11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DDR50_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DDR50_R_F_9_0">9:0</a></td>
</tr>
<tr><td>DRV_SEL_VAL</td>
<td>RSVD_13_11</td>
<td>CLK_GEN_SEL_VAL</td>
<td>FREQ_SEL_VAL</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_PRESET_DDR50_R"></a><p class="title">Table�43.�Fields for Register: PRESET_DDR50_R</p>
<table summary="Fields for Register: PRESET_DDR50_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DDR50_R_F_15_14"></a>15:14</p>
</td>
<td>DRV_SEL_VAL</td>
<td>R</td>
<td><p>Driver Strength Select Value</p>
<p class="BLANK"></p>
<p>These bits indicate Driver strength value supported for DDR50 bus speed mode. These bits are meaningless for 3.3V signaling.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (TYPEB): Driver Type B is selected</li><li>0x1 (TYPEA): Driver Type A is selected</li><li>0x2 (TYPEC): Driver Type C is selected</li><li>0x3 (TYPED): Driver Type D is selected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DDR50_R_F_13_11"></a>13:11</p>
</td>
<td>RSVD_13_11</td>
<td>R</td>
<td><p>These bits of the PRESET_DDR50_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DDR50_R_F_10"></a>10</p>
</td>
<td>CLK_GEN_SEL_VAL</td>
<td>R</td>
<td><p>Clock Generator Select Value</p>
<p class="BLANK"></p>
<p>This bit is effective when Host Controller supports programmable clock generator.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator</li><li>0x1 (PROG): Programmable Clock Generator</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_DDR50_R_F_9_0"></a>9:0</p>
</td>
<td>FREQ_SEL_VAL</td>
<td>R</td>
<td><p>SDCLK/RCLK Frequency Select Value</p>
<p class="BLANK"></p>
<p>These bits specify a 10-bit preset value that must be set in the SDCLK/RCLK Frequency Select field of the Clock Control register, as described by a Host System.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_UHS2_R"></a><span>PRESET_UHS2_R</span></p>
<ul><li><span>Name:</span>Preset Value for HS400 speed mode in eMMC</li><li><span>Description:</span>This register is used to hold the preset value for UHS-II (Not supported) and HS400 speed modes in the SD and eMMC modes, respectively.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0x74</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_PRESET_UHS2_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_UHS2_R_F_15_14">15:14</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_UHS2_R_F_13_11">13:11</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_UHS2_R_F_10">10</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_UHS2_R_F_9_0">9:0</a></td>
</tr>
<tr><td>DRV_SEL_VAL</td>
<td>RSVD_13_11</td>
<td>CLK_GEN_SEL_VAL</td>
<td>FREQ_SEL_VAL</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_PRESET_UHS2_R"></a><p class="title">Table�44.�Fields for Register: PRESET_UHS2_R</p>
<table summary="Fields for Register: PRESET_UHS2_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_UHS2_R_F_15_14"></a>15:14</p>
</td>
<td>DRV_SEL_VAL</td>
<td>R</td>
<td><p>Driver Strength Select Value</p>
<p class="BLANK"></p>
<p>These bits indicate the Driver strength value supported by 1.8V signaling bus speed modes in the SD mode. In eMMC mode, these bits can be used for selecting
the Drive strength value for HS400 mode.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (TYPEB): Driver Type B is selected</li><li>0x1 (TYPEA): Driver Type A is selected</li><li>0x2 (TYPEC): Driver Type C is selected</li><li>0x3 (TYPED): Driver Type D is selected</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_UHS2_R_F_13_11"></a>13:11</p>
</td>
<td>RSVD_13_11</td>
<td>R</td>
<td><p>These bits of the Preset register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_UHS2_R_F_10"></a>10</p>
</td>
<td>CLK_GEN_SEL_VAL</td>
<td>R</td>
<td><p>Clock Generator Select Value</p>
<p class="BLANK"></p>
<p>This bit is effective when the Host Controller supports a programmable clock generator.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator</li><li>0x1 (PROG): Programmable Clock Generator</li></ul><p></p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_PRESET_UHS2_R_F_9_0"></a>9:0</p>
</td>
<td>FREQ_SEL_VAL</td>
<td>R</td>
<td><p>SDCLK Frequency Select Value</p>
<p class="BLANK"></p>
<p>These bits specify the 10-bit preset value that must be set in the SDCLK Frequency Select field of the Clock Control register, as described by a Host System.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_P_EMBEDDED_CNTRL"></a><span>P_EMBEDDED_CNTRL</span></p>
<ul><li><span>Name:</span>Pointer for Embedded Control</li><li><span>Description:</span>This register points to the location of embedded control registers.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0xe6</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_P_EMBEDDED_CNTRL"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_P_EMBEDDED_CNTRL_F_15_12">15:12</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_P_EMBEDDED_CNTRL_F_11_0">11:0</a></td>
</tr>
<tr><td>RESERVED_15_12</td>
<td>REG_OFFSET_ADDR</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_P_EMBEDDED_CNTRL"></a><p class="title">Table�45.�Fields for Register: P_EMBEDDED_CNTRL</p>
<table summary="Fields for Register: P_EMBEDDED_CNTRL" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_P_EMBEDDED_CNTRL_F_15_12"></a>15:12</p>
</td>
<td>RESERVED_15_12</td>
<td>R</td>
<td><p>These bits of the P_EMBEDDED_CNTRL register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_P_EMBEDDED_CNTRL_F_11_0"></a>11:0</p>
</td>
<td>REG_OFFSET_ADDR</td>
<td>R</td>
<td><p>Offset Address of Embedded Control register.</p>
<p><span>Value After Reset:</span>0xf6c</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_P_VENDOR_SPECIFIC_AREA"></a><span>P_VENDOR_SPECIFIC_AREA</span></p>
<ul><li><span>Name:</span>Pointer for Vendor Specific Area 1</li><li><span>Description:</span>This register used as a pointer for the Vendor Specific Area 1.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0xe8</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_P_VENDOR_SPECIFIC_AREA"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_P_VENDOR_SPECIFIC_AREA_F_15_12">15:12</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_P_VENDOR_SPECIFIC_AREA_F_11_0">11:0</a></td>
</tr>
<tr><td>RESERVED_15_12</td>
<td>REG_OFFSET_ADDR</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_P_VENDOR_SPECIFIC_AREA"></a><p class="title">Table�46.�Fields for Register: P_VENDOR_SPECIFIC_AREA</p>
<table summary="Fields for Register: P_VENDOR_SPECIFIC_AREA" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_P_VENDOR_SPECIFIC_AREA_F_15_12"></a>15:12</p>
</td>
<td>RESERVED_15_12</td>
<td>R</td>
<td><p>These bits of the P_VENDOR_SPECIFIC_AREA register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_P_VENDOR_SPECIFIC_AREA_F_11_0"></a>11:0</p>
</td>
<td>REG_OFFSET_ADDR</td>
<td>R</td>
<td><p>Base offset Address for Vendor-Specific registers.</p>
<p><span>Value After Reset:</span>0x500</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_P_VENDOR2_SPECIFIC_AREA"></a><span>P_VENDOR2_SPECIFIC_AREA</span></p>
<ul><li><span>Name:</span>Pointer for Vendor Specific Area 2</li><li><span>Description:</span>This register is used as a pointer for the Vendor Specific Area 2.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0xea</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_P_VENDOR2_SPECIFIC_AREA"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_P_VENDOR2_SPECIFIC_AREA_F_15_0">15:0</a></td>
</tr>
<tr><td>REG_OFFSET_ADDR</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_P_VENDOR2_SPECIFIC_AREA"></a><p class="title">Table�47.�Fields for Register: P_VENDOR2_SPECIFIC_AREA</p>
<table summary="Fields for Register: P_VENDOR2_SPECIFIC_AREA" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_P_VENDOR2_SPECIFIC_AREA_F_15_0"></a>15:0</p>
</td>
<td>REG_OFFSET_ADDR</td>
<td>R</td>
<td><p>Base offset Address for Command Queuing registers.</p>
<p><span>Value After Reset:</span>0x180</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_SLOT_INTR_STATUS_R"></a><span>SLOT_INTR_STATUS_R</span></p>
<ul><li><span>Name:</span>Slot Interrupt Status Register</li><li><span>Description:</span>This register indicates the Interrupt status of each slot.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0xfc</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_SLOT_INTR_STATUS_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_SLOT_INTR_STATUS_R_F_15_8">15:8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_SLOT_INTR_STATUS_R_F_7_0">7:0</a></td>
</tr>
<tr><td>RESERVED_15_8</td>
<td>INTR_SLOT</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_SLOT_INTR_STATUS_R"></a><p class="title">Table�48.�Fields for Register: SLOT_INTR_STATUS_R</p>
<table summary="Fields for Register: SLOT_INTR_STATUS_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_SLOT_INTR_STATUS_R_F_15_8"></a>15:8</p>
</td>
<td>RESERVED_15_8</td>
<td>R</td>
<td><p>These bits of the SLOT_INTR_STATUS_R register are reserved. They always return 0.</p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_SLOT_INTR_STATUS_R_F_7_0"></a>7:0</p>
</td>
<td>INTR_SLOT</td>
<td>R</td>
<td><p>Interrupt signal for each Slot</p>
<p class="BLANK"></p>
<p>These status bits indicate the logical OR of Interrupt signal and Wakeup signal for each slot. A maximum of 8 slots can be defined. If one interrupt signal is associated with multiple slots, the Host
Driver can identify the interrupt that is generated by reading these bits. By a power on reset or by setting Software Reset For All bit, the interrupt signals are de-asserted and this status reads 00h.</p>
<ul><li>Bit 00: Slot 1</li><li>Bit 01: Slot 2</li><li>Bit 02: Slot 3</li><li>..........</li><li>..........</li><li>Bit 07: Slot 8</li></ul><p class="BLANK"></p>
<p><span><em><span>Note</span></em></span>: MSHC Host Controller support single card slot. This register shall always return 0.</p>
<p class="BLANK"></p>
<p><span>Value After Reset:</span>0x0</p>
<p><span>Volatile:</span>true</p>
</td>
</tr>
</tbody></table><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CNTRL_VERS_R"></a><span>HOST_CNTRL_VERS_R</span></p>
<ul><li><span>Name:</span>Host Controller Version</li><li><span>Description:</span>This register is used to indicate the Host Controller Version number.</li><li><span>Size:</span>16 bits</li><li><span>Offset:</span>0xfe</li></ul><a name="fld-DWC_mshc_map_DWC_mshc_block_HOST_CNTRL_VERS_R"></a><table><colgroup></colgroup><tbody><tr><td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CNTRL_VERS_R_F_15_8">15:8</a></td>
<td><a class="link" href="#H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CNTRL_VERS_R_F_7_0">7:0</a></td>
</tr>
<tr><td>VENDOR_VERSION_NUM</td>
<td>SPEC_VERSION_NUM</td>
</tr>
</tbody></table><a name="fieldtable-DWC_mshc_map_DWC_mshc_block_HOST_CNTRL_VERS_R"></a><p class="title">Table�49.�Fields for Register: HOST_CNTRL_VERS_R</p>
<table summary="Fields for Register: HOST_CNTRL_VERS_R" width="100%"><colgroup></colgroup><thead><tr><tr><th>Bits</th><th>Name</th><th>Memory Access</th><th>Description</th></tr>
</tr></thead><tbody><tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CNTRL_VERS_R_F_15_8"></a>15:8</p>
</td>
<td>VENDOR_VERSION_NUM</td>
<td>R</td>
<td><p>Vendor Version Number</p>
<p class="BLANK"></p>
<p>This field is reserved for the vendor version number. Host Driver must not use this status.</p>
<p><span>Value After Reset:</span>0x0</p>
</td>
</tr>
<tr><td><p><a name="H4-reg-DWC_mshc_map_DWC_mshc_block_HOST_CNTRL_VERS_R_F_7_0"></a>7:0</p>
</td>
<td>SPEC_VERSION_NUM</td>
<td>R</td>
<td><p>Specification Version Number</p>
<p class="BLANK"></p>
<p>These bits indicate the Host controller specification version. The upper and lower 4-bits indicate the version. Values 0x06-0xFF are reserved.</p>
<p class="BLANK"></p>
<p><span>Values:</span></p>
<ul><li>0x0 (VER_1_00): SD Host Controller Specification Version 1.00</li><li>0x1 (VER_2_00): SD Host Controller Specification Version 2.00</li><li>0x2 (VER_3_00): SD Host Controller Specification Version 3.00</li><li>0x3 (VER_4_00): SD Host Controller Specification Version 4.00</li><li>0x4 (VER_4_10): SD Host Controller Specification Version 4.10</li><li>0x5 (VER_4_20): SD Host Controller Specification Version 4.20</li></ul><p></p>
<p><span>Value After Reset:</span>0x5</p>
</td>
</tr>
</tbody></table></body></html>

