<?xml version="1.0" encoding="utf-8"?><html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd"><head><title>VISPDBIF</title></head>
<body>
<p><a NAME="VISPDBIF">"VISPDBIF"<p></p>
</a></p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX1IPI0DH_WrClient_Y_Wr</a></p>
</td>
<td><p>32'h00000000</p>
</td>
<td><p>RAW8 to 64bit Packing selection for Write Client 1<p></p>
RX1IPI0DH_WrClient_Y_upack_Sel[3:0]=<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 16 bit packing<p></p>
[0010] : 24 bit packing ← Use this for RAW8<p></p>
Embedded Data8 to 64bit Packing selection for Write Client 13.<p></p>
RX1IPI0DH_WrClient_M_upack_Sel[3:0]=<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 48 bit packing ← Use this<p></p>
Note: Common pack_sel control for all IPI membedded datas Muxed by CTRL_EMBED1_SEL<p></p>
RX1IPI0DH_uCTRL2_wrClient_Y_input_ctrl[3:0]<p></p>
0: Direct IPI-24-bit(RAW8) to Dhub Write Client<p></p>
1: Direct IPI-24b(RAW8) to Dhub WriteClient<p></p>
having BF_CSI2DHUB_uCTRL1_enable_565_write option. (not used)<p></p>
------<p></p>
2: case[0] but through TG re-timing ASYNC FIFO (Not required)<p></p>
3: Case[1] but through TG re-timing ASYNC FIFO (Not used)<p></p>
BF_VISPDBIF_RX1IPI0DH_uCTRL2_wrClient_M_input_ctrl[1:0]<p></p>
0: Direct IPI Embedded 8bit data to Dhub WriteClient, with option to change Endianness(CTRL_EMBED1_ENDIAN)<p></p>
1: Direct IPI Embeddata8 8bit data to Dhub WriteClient as it is in IPI-48bit data.<p></p>
Note: Common Input control selection control for all IPI membedded datas Muxed by CTRL_EMBED1_SEL<p></p>
Register for write Client RAW8/Yluma</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX1IPI0DH_WrClient_Y_pix</a></p>
</td>
<td><p>32'h00000004</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX1IPI0DH_WrClient_Y_NonStdRes</a></p>
</td>
<td><p>32'h00000008</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX1IPI0DH_WrClient_Y_pack</a></p>
</td>
<td><p>32'h0000000C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX1IPI0DH_WrClient_C_Wr</a></p>
</td>
<td><p>32'h00000010</p>
</td>
<td><p>Register for write Client Chroma</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX1IPI0DH_WrClient_C_pix</a></p>
</td>
<td><p>32'h00000014</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX1IPI0DH_WrClient_C_NonStdRes</a></p>
</td>
<td><p>32'h00000018</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX1IPI0DH_WrClient_C_pack</a></p>
</td>
<td><p>32'h0000001C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX1IPI0DH_WrClient_M_Wr</a></p>
</td>
<td><p>32'h00000020</p>
</td>
<td><p>Register for write Client Embedded Data</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX1IPI0DH_WrClient_M_pix</a></p>
</td>
<td><p>32'h00000024</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX1IPI0DH_WrClient_M_NonStdRes</a></p>
</td>
<td><p>32'h00000028</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX1IPI0DH_WrClient_M_pack</a></p>
</td>
<td><p>32'h0000002C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL">VISPDBIF_RX1IPI0DH_TG_CTRL</a></p>
</td>
<td><p>32'h00000030</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_tg_start">tg_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>TG start</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_tg_clear">tg_clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>TG clear</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl0">clken_ctrl0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client1 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl1">clken_ctrl1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client2 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl6">clken_ctrl6</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client3 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl2">clken_ctrl2</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on IPI fifo status.<p></p>
0: disabled<p></p>
1: enabled</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl3">clken_ctrl3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client1 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl4">clken_ctrl4</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client2 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl7">clken_ctrl7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client3 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl5">clken_ctrl5</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client 1 and client2 ready.<p></p>
0: disabled<p></p>
1: enabled</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_fifo_ctrlEn">fifo_ctrlEn</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on IPI input FIFO status.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_zero_line_delay_en">zero_line_delay_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable zero line delay programming mode.<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL">VISPDBIF_RX1IPI0DH_CLKEN_CTRL</a></p>
</td>
<td><p>32'h00000034</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_C_clken">WrClient_C_clken</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Clock gating bit for chroma write client.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_M_clken">WrClient_M_clken</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Clock gating bit for Embedded data write client.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_Y_clken">WrClient_Y_clken</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Clock gating bit for Luma/RAW data write client OCPF.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_fifo_read_on_TG_ACTIVE_en">fifo_read_on_TG_ACTIVE_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable ipi fifo read also based on TG active signal apart from hde, vde and ipi fifo status.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1">VISPDBIF_RX1IPI0DH_CTRL1</a></p>
</td>
<td><p>32'h00000038</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_IPIswap_Y_ctrl">IPIswap_Y_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In IPI48bit interface, Three 16bit IPI component RAW/Y data position swapping control.<p></p>
case(IPIswap_Y_ctrl[2:0])<p></p>
3'b000 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[31:16],ipi_pixdata[15: 0]};<p></p>
3'b001 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[31:16],ipi_pixdata[47:32]};<p></p>
3'b010 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[47:32],ipi_pixdata[15: 0]};<p></p>
3'b011 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[15: 0],ipi_pixdata[47:32]};<p></p>
3'b100 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[15: 0],ipi_pixdata[31:16]};<p></p>
3'b101 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[47:32],ipi_pixdata[31:16]};<p></p>
NOTE: IPIswap_Y_ctrl can be 0 if “endianness_Y” control programming is used.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_endianness_Y">endianness_Y</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Works on the IPI data given out by the swap (IPIswap_Y_ctrl) logic.<p></p>
1: Change the Data write order for RAW/Y data. Nth data first (LSB) and N+1th data next (MSB).<p></p>
Example: wrClient_pixdata[47:0]= {ipidata_raw48b[15:0],ipidata_raw48b[31:16],ipidata_raw48b[47:32]}<p></p>
0: Do not Change the Data write order for RAW/Y data. order remain same as received from CSI2RX. N+1th data first (LSB) and Nth data next (MSB).<p></p>
Example wrClient_pixdata[47:0]= {ipidata_raw48b[47:32],ipidata_raw48b[31:16],ipidata_raw48b[15:0]}<p></p>
NOTE: IPIswap_Y_ctrl must be 0 while programming “endianness_Y” control</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_IPIswap_M_ctrl">IPIswap_M_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In IPI48bit interface, Three 16bit IPI Embedded data position swapping control.<p></p>
case(IPIswap_M_ctrl[2:0])<p></p>
3'b000 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[31:16],ipi_pixdata[15: 0]};<p></p>
3'b001 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[31:16],ipi_pixdata[47:32]};<p></p>
3'b010 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[47:32],ipi_pixdata[15: 0]};<p></p>
3'b011 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[15: 0],ipi_pixdata[47:32]};<p></p>
3'b100 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[15: 0],ipi_pixdata[31:16]};<p></p>
3'b101 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[47:32],ipi_pixdata[31:16]};<p></p>
NOTE: IPIswap_M_ctrl can be 0 if “endianness_M” control programming is used.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_endianness_M">endianness_M</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Works on the IPI Embedded data given out by the swap (IPIswap_M_ctrl) logic.<p></p>
1: Change the Data write order for Embedded data. Nth data first (LSB) and N+1th data next (MSB).<p></p>
Example: wrClient_pixdata[47:0]= {ipidata_raw48b[15:0],ipidata_raw48b[31:16],ipidata_raw48b[47:32]}<p></p>
0: Do not Change the Data write order for Embedded data. order remain same as received from CSI2RX. N+1th data first (LSB) and Nth data next (MSB).<p></p>
Example wrClient_pixdata[47:0]= {ipidata_raw48b[47:32],ipidata_raw48b[31:16],ipidata_raw48b[15:0]}<p></p>
NOTE: IPIswap_M_ctrl must be 0 while programming “endianness_M” control</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enb_YC_haltback">enb_YC_haltback</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable output haltback from IPI data write clients (RAW8/Y)&C.<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enb_M_haltback">enb_M_haltback</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable output haltback from IPI Embedded data write clients (Embedded).<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_Y">ClientRdy_ctrl_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI Y data WriteClient (RAW8/Y), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient Y will be overridden with ClientRdy_ctrl_Y to keep the WriteClient always ready. The Halt signal from WriteClient Y will not be asserted.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_C">ClientRdy_ctrl_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI C WriteClient (C data), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient C will be overridden with ClientRdy_ctrl_C to keep the WriteClient always ready. The Halt signal from WriteClient C will not be asserted.</p>
</td>
</tr>
<tr><td><p>[12:12]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_M">ClientRdy_ctrl_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI EmbMeta WriteClient (Embedded Metadata ), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient Embeddata will be overridden with ClientRdy_ctrl_M to keep the WriteClient always ready. The Halt signal from WriteClient Embeddata will not be asserted.</p>
</td>
</tr>
<tr><td><p>[13:13]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_fifo_flush">fifo_flush</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>ipi input fifo flush.</p>
</td>
</tr>
<tr><td><p>[14:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_contemp_UV420">contemp_UV420</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>IPI data YUV420 format in Contemporary mode (Non-Legacy)<p></p>
UV-data= {ipi_pixdata[19:12],ipi_pixdata[9:2]}</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ipi_uv_swap_ctrl">ipi_uv_swap_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>1: {ipidata_uv[7:0],ipidata_uv[15:8]}={V,U}<p></p>
0: {ipidata_uv[15:8],ipidata_uv[7:0]}={U,V}<p></p>
NOTE: endianness is not used for UV data.<p></p>
ipi_uv_swap_ctrl can be used as endianness change while writing UV to Dhub.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enable_565_write">enable_565_write</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>888 format will be packed as 565 before dhub write.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2">VISPDBIF_RX1IPI0DH_CTRL2</a></p>
</td>
<td><p>32'h0000003C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_C_input_ctrl">wrClient_C_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DHUB write input selection for CSIRX2-IPI to write client C<p></p>
4'h0 : Monochrome formats, UV="0<p"></p>
4'h1 : YUV422-UV16b format :: Write 16bit UV on alternate Pixel<p></p>
4'h2 : YUV422-C8b format :: Write U in ODD pix, V in EVEN pix<p></p>
4'h3 : YUV420-UV16b :: Write 16bit UV on even pixel of even Line, Else =0<p></p>
4'h4 : YUV420-C8b Legacy format<p></p>
4'h8 : YUV422-UV16b format :: Write 16bit UV on alternate Pixel<p></p>
4'h9 : YUV422-C8b format :: Write U in ODD pix, V in EVEN pix<p></p>
4'hA : YUV420-UV16b :: Write 16bit UV on even pixel of even Line, Else =0<p></p>
4'hB : YUV420-C8b Legacy format</p>
</td>
</tr>
<tr><td><p>[7:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_Y_input_ctrl">wrClient_Y_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input control for CSIRX1-IPI0 and CSIRX1-IPI1 write clients<p></p>
4'h0 : host IPI to DHUB ( 24-bit) RAW8<p></p>
4'h1 : host IPI to DHUB ( 16/24-bit)<p></p>
4'h2 : host IPI < FIFO > DHUB ( 24-bit) RAW8<p></p>
4'h3 : host IPI < FIFO > DHUB ( 16/24-bit)<p></p>
default : host IPI to DHUB ( 24-bit) RAW8<p></p>
------------------------------------------<p></p>
Input control for CSIRX2-IPI Y write clients<p></p>
4'h0 : RAW8 = 24b/16b (16b for RGB565)<p></p>
4'h1 : RAW10 = 30b<p></p>
4'h2 : RAW12 = 36b<p></p>
4'h3 : RAW16 = 48b<p></p>
4'h4 : YUV422-Y8b = 8b<p></p>
4'h5 : YUV420-Y8b = 16b<p></p>
4'h8 : RAW8 = 24b/16b (16b for RGB565)<p></p>
4'h9 : RAW10 = 30b<p></p>
4'hA : RAW12 = 36b<p></p>
4'hB : RAW16 = 48b<p></p>
4'hC : YUV422-Y8b = 8b<p></p>
4'hD : YUV420-Y8b = 16b<p></p>
default :RAW8 = 24b</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_M_input_ctrl">wrClient_M_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input control for Embedded data Write client<p></p>
0: Swapped and Endian corrected Embedded data<p></p>
1: Endian corrected Embedded data</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_C">WrClient_clear_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Chroma write client clear</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_C">WrClient_start_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Chroma write client start</p>
</td>
</tr>
<tr><td><p>[12:12]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_Y">WrClient_clear_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Luma write client clear</p>
</td>
</tr>
<tr><td><p>[13:13]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_Y">WrClient_start_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Luma write client start</p>
</td>
</tr>
<tr><td><p>[14:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_M">WrClient_clear_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Embedded data write client clear</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_M">WrClient_start_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Embedded data write client start</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL3">VISPDBIF_RX1IPI0DH_CTRL3</a></p>
</td>
<td><p>32'h00000040</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL3_ipipix_tot">ipipix_tot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Total pixel count at IPI input fifo</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4">VISPDBIF_RX1IPI0DH_CTRL4</a></p>
</td>
<td><p>32'h00000044</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[13:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4_image_width">image_width</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Image width of sequencer for sync to start end signal conversion.</p>
</td>
</tr>
<tr><td><p>[27:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4_image_height">image_height</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Image height of sequencer for sync to start end signal conversion.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5">VISPDBIF_RX1IPI0DH_CTRL5</a></p>
</td>
<td><p>32'h00000048</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5_hblank">hblank</a></p>
</td>
<td><p>0x10</p>
</td>
<td><p>Hblank added in sequencer while doing sync to start end signal conversion.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5_iif_mode">iif_mode</a></p>
</td>
<td><p>0x10</p>
</td>
<td><p>Iif input mode for sync2se block.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX1IPI1DH_WrClient_Y_Wr</a></p>
</td>
<td><p>32'h0000004C</p>
</td>
<td><p>RAW8 to 64bit Packing selection for Write Client 3<p></p>
RX1IPI1DH_WrClient_Y_upack_Sel[3:0]=<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 16 bit packing<p></p>
[0010] : 24 bit packing ← Use this for RAW8<p></p>
RX1IPI1DH_uCTRL2_wrClient_Y_input_ctrl[3:0]<p></p>
0: Direct IPI-24-bit(RAW8) to Dhub Write Client<p></p>
1: Direct IPI-24b(RAW8) to Dhub WriteClient<p></p>
having BF_CSI2DHUB_uCTRL1_enable_565_write option. (not used)<p></p>
------<p></p>
2: case[0] but through TG re-timing ASYNC FIFO (Not required)<p></p>
3: Case[1] but through TG re-timing ASYNC FIFO (Not used)<p></p>
Register for write Client RAW8/Yluma</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX1IPI1DH_WrClient_Y_pix</a></p>
</td>
<td><p>32'h00000050</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX1IPI1DH_WrClient_Y_NonStdRes</a></p>
</td>
<td><p>32'h00000054</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX1IPI1DH_WrClient_Y_pack</a></p>
</td>
<td><p>32'h00000058</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX1IPI1DH_WrClient_C_Wr</a></p>
</td>
<td><p>32'h0000005C</p>
</td>
<td><p>Register for write Client Chroma</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX1IPI1DH_WrClient_C_pix</a></p>
</td>
<td><p>32'h00000060</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX1IPI1DH_WrClient_C_NonStdRes</a></p>
</td>
<td><p>32'h00000064</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX1IPI1DH_WrClient_C_pack</a></p>
</td>
<td><p>32'h00000068</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX1IPI1DH_WrClient_M_Wr</a></p>
</td>
<td><p>32'h0000006C</p>
</td>
<td><p>Register for write Client Embedded Data</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX1IPI1DH_WrClient_M_pix</a></p>
</td>
<td><p>32'h00000070</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX1IPI1DH_WrClient_M_NonStdRes</a></p>
</td>
<td><p>32'h00000074</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX1IPI1DH_WrClient_M_pack</a></p>
</td>
<td><p>32'h00000078</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL">VISPDBIF_RX1IPI1DH_TG_CTRL</a></p>
</td>
<td><p>32'h0000007C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_tg_start">tg_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>TG start</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_tg_clear">tg_clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>TG clear</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl0">clken_ctrl0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client1 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl1">clken_ctrl1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client2 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl6">clken_ctrl6</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client3 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl2">clken_ctrl2</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on IPI fifo status.<p></p>
0: disabled<p></p>
1: enabled</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl3">clken_ctrl3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client1 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl4">clken_ctrl4</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client2 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl7">clken_ctrl7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client3 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl5">clken_ctrl5</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client 1 and client2 ready.<p></p>
0: disabled<p></p>
1: enabled</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_fifo_ctrlEn">fifo_ctrlEn</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on IPI input FIFO status.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_zero_line_delay_en">zero_line_delay_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable zero line delay programming mode.<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL">VISPDBIF_RX1IPI1DH_CLKEN_CTRL</a></p>
</td>
<td><p>32'h00000080</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_C_clken">WrClient_C_clken</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Clock gating bit for chroma write client.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_M_clken">WrClient_M_clken</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Clock gating bit for Embedded data write client.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_Y_clken">WrClient_Y_clken</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Clock gating bit for Luma/RAW data write client OCPF.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_fifo_read_on_TG_ACTIVE_en">fifo_read_on_TG_ACTIVE_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable ipi fifo read also based on TG active signal apart from hde, vde and ipi fifo status.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1">VISPDBIF_RX1IPI1DH_CTRL1</a></p>
</td>
<td><p>32'h00000084</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_IPIswap_Y_ctrl">IPIswap_Y_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In IPI48bit interface, Three 16bit IPI component RAW/Y data position swapping control.<p></p>
case(IPIswap_Y_ctrl[2:0])<p></p>
3'b000 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[31:16],ipi_pixdata[15: 0]};<p></p>
3'b001 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[31:16],ipi_pixdata[47:32]};<p></p>
3'b010 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[47:32],ipi_pixdata[15: 0]};<p></p>
3'b011 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[15: 0],ipi_pixdata[47:32]};<p></p>
3'b100 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[15: 0],ipi_pixdata[31:16]};<p></p>
3'b101 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[47:32],ipi_pixdata[31:16]};<p></p>
NOTE: IPIswap_Y_ctrl can be 0 if “endianness_Y” control programming is used.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_endianness_Y">endianness_Y</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Works on the IPI data given out by the swap (IPIswap_Y_ctrl) logic.<p></p>
1: Change the Data write order for RAW/Y data. Nth data first (LSB) and N+1th data next (MSB).<p></p>
Example: wrClient_pixdata[47:0]= {ipidata_raw48b[15:0],ipidata_raw48b[31:16],ipidata_raw48b[47:32]}<p></p>
0: Do not Change the Data write order for RAW/Y data. order remain same as received from CSI2RX. N+1th data first (LSB) and Nth data next (MSB).<p></p>
Example wrClient_pixdata[47:0]= {ipidata_raw48b[47:32],ipidata_raw48b[31:16],ipidata_raw48b[15:0]}<p></p>
NOTE: IPIswap_Y_ctrl must be 0 while programming “endianness_Y” control</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_IPIswap_M_ctrl">IPIswap_M_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In IPI48bit interface, Three 16bit IPI Embedded data position swapping control.<p></p>
case(IPIswap_M_ctrl[2:0])<p></p>
3'b000 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[31:16],ipi_pixdata[15: 0]};<p></p>
3'b001 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[31:16],ipi_pixdata[47:32]};<p></p>
3'b010 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[47:32],ipi_pixdata[15: 0]};<p></p>
3'b011 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[15: 0],ipi_pixdata[47:32]};<p></p>
3'b100 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[15: 0],ipi_pixdata[31:16]};<p></p>
3'b101 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[47:32],ipi_pixdata[31:16]};<p></p>
NOTE: IPIswap_M_ctrl can be 0 if “endianness_M” control programming is used.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_endianness_M">endianness_M</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Works on the IPI Embedded data given out by the swap (IPIswap_M_ctrl) logic.<p></p>
1: Change the Data write order for Embedded data. Nth data first (LSB) and N+1th data next (MSB).<p></p>
Example: wrClient_pixdata[47:0]= {ipidata_raw48b[15:0],ipidata_raw48b[31:16],ipidata_raw48b[47:32]}<p></p>
0: Do not Change the Data write order for Embedded data. order remain same as received from CSI2RX. N+1th data first (LSB) and Nth data next (MSB).<p></p>
Example wrClient_pixdata[47:0]= {ipidata_raw48b[47:32],ipidata_raw48b[31:16],ipidata_raw48b[15:0]}<p></p>
NOTE: IPIswap_M_ctrl must be 0 while programming “endianness_M” control</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enb_YC_haltback">enb_YC_haltback</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable output haltback from IPI data write clients (RAW8/Y)&C.<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enb_M_haltback">enb_M_haltback</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable output haltback from IPI Embedded data write clients (Embedded).<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_Y">ClientRdy_ctrl_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI Y data WriteClient (RAW8/Y), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient Y will be overridden with ClientRdy_ctrl_Y to keep the WriteClient always ready. The Halt signal from WriteClient Y will not be asserted.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_C">ClientRdy_ctrl_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI C WriteClient (C data), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient C will be overridden with ClientRdy_ctrl_C to keep the WriteClient always ready. The Halt signal from WriteClient C will not be asserted.</p>
</td>
</tr>
<tr><td><p>[12:12]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_M">ClientRdy_ctrl_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI EmbMeta WriteClient (Embedded Metadata ), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient Embeddata will be overridden with ClientRdy_ctrl_M to keep the WriteClient always ready. The Halt signal from WriteClient Embeddata will not be asserted.</p>
</td>
</tr>
<tr><td><p>[13:13]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_fifo_flush">fifo_flush</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>ipi input fifo flush.</p>
</td>
</tr>
<tr><td><p>[14:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_contemp_UV420">contemp_UV420</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>IPI data YUV420 format in Contemporary mode (Non-Legacy)<p></p>
UV-data= {ipi_pixdata[19:12],ipi_pixdata[9:2]}</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ipi_uv_swap_ctrl">ipi_uv_swap_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>1: {ipidata_uv[7:0],ipidata_uv[15:8]}={V,U}<p></p>
0: {ipidata_uv[15:8],ipidata_uv[7:0]}={U,V}<p></p>
NOTE: endianness is not used for UV data.<p></p>
ipi_uv_swap_ctrl can be used as endianness change while writing UV to Dhub.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enable_565_write">enable_565_write</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>888 format will be packed as 565 before dhub write.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2">VISPDBIF_RX1IPI1DH_CTRL2</a></p>
</td>
<td><p>32'h00000088</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_C_input_ctrl">wrClient_C_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DHUB write input selection for CSIRX2-IPI to write client C<p></p>
4'h0 : Monochrome formats, UV="0<p"></p>
4'h1 : YUV422-UV16b format :: Write 16bit UV on alternate Pixel<p></p>
4'h2 : YUV422-C8b format :: Write U in ODD pix, V in EVEN pix<p></p>
4'h3 : YUV420-UV16b :: Write 16bit UV on even pixel of even Line, Else =0<p></p>
4'h4 : YUV420-C8b Legacy format<p></p>
4'h8 : YUV422-UV16b format :: Write 16bit UV on alternate Pixel<p></p>
4'h9 : YUV422-C8b format :: Write U in ODD pix, V in EVEN pix<p></p>
4'hA : YUV420-UV16b :: Write 16bit UV on even pixel of even Line, Else =0<p></p>
4'hB : YUV420-C8b Legacy format</p>
</td>
</tr>
<tr><td><p>[7:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_Y_input_ctrl">wrClient_Y_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input control for CSIRX1-IPI0 and CSIRX1-IPI1 write clients<p></p>
4'h0 : host IPI to DHUB ( 24-bit) RAW8<p></p>
4'h1 : host IPI to DHUB ( 16/24-bit)<p></p>
4'h2 : host IPI < FIFO > DHUB ( 24-bit) RAW8<p></p>
4'h3 : host IPI < FIFO > DHUB ( 16/24-bit)<p></p>
default : host IPI to DHUB ( 24-bit) RAW8<p></p>
------------------------------------------<p></p>
Input control for CSIRX2-IPI Y write clients<p></p>
4'h0 : RAW8 = 24b/16b (16b for RGB565)<p></p>
4'h1 : RAW10 = 30b<p></p>
4'h2 : RAW12 = 36b<p></p>
4'h3 : RAW16 = 48b<p></p>
4'h4 : YUV422-Y8b = 8b<p></p>
4'h5 : YUV420-Y8b = 16b<p></p>
4'h8 : RAW8 = 24b/16b (16b for RGB565)<p></p>
4'h9 : RAW10 = 30b<p></p>
4'hA : RAW12 = 36b<p></p>
4'hB : RAW16 = 48b<p></p>
4'hC : YUV422-Y8b = 8b<p></p>
4'hD : YUV420-Y8b = 16b<p></p>
default :RAW8 = 24b</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_M_input_ctrl">wrClient_M_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input control for Embedded data Write client<p></p>
0: Swapped and Endian corrected Embedded data<p></p>
1: Endian corrected Embedded data</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_C">WrClient_clear_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Chroma write client clear</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_C">WrClient_start_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Chroma write client start</p>
</td>
</tr>
<tr><td><p>[12:12]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_Y">WrClient_clear_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Luma write client clear</p>
</td>
</tr>
<tr><td><p>[13:13]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_Y">WrClient_start_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Luma write client start</p>
</td>
</tr>
<tr><td><p>[14:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_M">WrClient_clear_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Embedded data write client clear</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_M">WrClient_start_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Embedded data write client start</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL3">VISPDBIF_RX1IPI1DH_CTRL3</a></p>
</td>
<td><p>32'h0000008C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL3_ipipix_tot">ipipix_tot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Total pixel count at IPI input fifo</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4">VISPDBIF_RX1IPI1DH_CTRL4</a></p>
</td>
<td><p>32'h00000090</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[13:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4_image_width">image_width</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Image width of sequencer for sync to start end signal conversion.</p>
</td>
</tr>
<tr><td><p>[27:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4_image_height">image_height</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Image height of sequencer for sync to start end signal conversion.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5">VISPDBIF_RX1IPI1DH_CTRL5</a></p>
</td>
<td><p>32'h00000094</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5_hblank">hblank</a></p>
</td>
<td><p>0x10</p>
</td>
<td><p>Hblank added in sequencer while doing sync to start end signal conversion.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5_iif_mode">iif_mode</a></p>
</td>
<td><p>0x10</p>
</td>
<td><p>Iif input mode for sync2se block.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX1IPI2DH_WrClient_Y_Wr</a></p>
</td>
<td><p>32'h00000098</p>
</td>
<td><p>RAW8 to 64bit Packing selection for Write Client 5<p></p>
RX1IPI2DH_WrClient_Y_upack_Sel[3:0]=<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 16 bit packing<p></p>
[0010] : 24 bit packing ← Use this for RAW8<p></p>
RX1IPI2DH_uCTRL2_wrClient_Y_input_ctrl[3:0]<p></p>
0: Direct IPI-24-bit(RAW8) to Dhub Write Client<p></p>
1: Direct IPI-24b(RAW8) to Dhub WriteClient<p></p>
having BF_CSI2DHUB_uCTRL1_enable_565_write option. (not used)<p></p>
------<p></p>
2: case[0] but through TG re-timing ASYNC FIFO (Not required)<p></p>
3: Case[1] but through TG re-timing ASYNC FIFO (Not used)<p></p>
Register for write Client RAW8/Yluma</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX1IPI2DH_WrClient_Y_pix</a></p>
</td>
<td><p>32'h0000009C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX1IPI2DH_WrClient_Y_NonStdRes</a></p>
</td>
<td><p>32'h000000A0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX1IPI2DH_WrClient_Y_pack</a></p>
</td>
<td><p>32'h000000A4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX1IPI2DH_WrClient_C_Wr</a></p>
</td>
<td><p>32'h000000A8</p>
</td>
<td><p>Register for write Client Chroma</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX1IPI2DH_WrClient_C_pix</a></p>
</td>
<td><p>32'h000000AC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX1IPI2DH_WrClient_C_NonStdRes</a></p>
</td>
<td><p>32'h000000B0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX1IPI2DH_WrClient_C_pack</a></p>
</td>
<td><p>32'h000000B4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX1IPI2DH_WrClient_M_Wr</a></p>
</td>
<td><p>32'h000000B8</p>
</td>
<td><p>Register for write Client Embedded Data</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX1IPI2DH_WrClient_M_pix</a></p>
</td>
<td><p>32'h000000BC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX1IPI2DH_WrClient_M_NonStdRes</a></p>
</td>
<td><p>32'h000000C0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX1IPI2DH_WrClient_M_pack</a></p>
</td>
<td><p>32'h000000C4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL">VISPDBIF_RX1IPI2DH_TG_CTRL</a></p>
</td>
<td><p>32'h000000C8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_tg_start">tg_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>TG start</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_tg_clear">tg_clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>TG clear</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl0">clken_ctrl0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client1 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl1">clken_ctrl1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client2 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl6">clken_ctrl6</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client3 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl2">clken_ctrl2</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on IPI fifo status.<p></p>
0: disabled<p></p>
1: enabled</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl3">clken_ctrl3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client1 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl4">clken_ctrl4</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client2 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl7">clken_ctrl7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client3 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl5">clken_ctrl5</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client 1 and client2 ready.<p></p>
0: disabled<p></p>
1: enabled</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_fifo_ctrlEn">fifo_ctrlEn</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on IPI input FIFO status.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_zero_line_delay_en">zero_line_delay_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable zero line delay programming mode.<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL">VISPDBIF_RX1IPI2DH_CLKEN_CTRL</a></p>
</td>
<td><p>32'h000000CC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_C_clken">WrClient_C_clken</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Clock gating bit for chroma write client.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_M_clken">WrClient_M_clken</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Clock gating bit for Embedded data write client.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_Y_clken">WrClient_Y_clken</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Clock gating bit for Luma/RAW data write client OCPF.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_fifo_read_on_TG_ACTIVE_en">fifo_read_on_TG_ACTIVE_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable ipi fifo read also based on TG active signal apart from hde, vde and ipi fifo status.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1">VISPDBIF_RX1IPI2DH_CTRL1</a></p>
</td>
<td><p>32'h000000D0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_IPIswap_Y_ctrl">IPIswap_Y_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In IPI48bit interface, Three 16bit IPI component RAW/Y data position swapping control.<p></p>
case(IPIswap_Y_ctrl[2:0])<p></p>
3'b000 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[31:16],ipi_pixdata[15: 0]};<p></p>
3'b001 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[31:16],ipi_pixdata[47:32]};<p></p>
3'b010 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[47:32],ipi_pixdata[15: 0]};<p></p>
3'b011 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[15: 0],ipi_pixdata[47:32]};<p></p>
3'b100 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[15: 0],ipi_pixdata[31:16]};<p></p>
3'b101 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[47:32],ipi_pixdata[31:16]};<p></p>
NOTE: IPIswap_Y_ctrl can be 0 if “endianness_Y” control programming is used.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_endianness_Y">endianness_Y</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Works on the IPI data given out by the swap (IPIswap_Y_ctrl) logic.<p></p>
1: Change the Data write order for RAW/Y data. Nth data first (LSB) and N+1th data next (MSB).<p></p>
Example: wrClient_pixdata[47:0]= {ipidata_raw48b[15:0],ipidata_raw48b[31:16],ipidata_raw48b[47:32]}<p></p>
0: Do not Change the Data write order for RAW/Y data. order remain same as received from CSI2RX. N+1th data first (LSB) and Nth data next (MSB).<p></p>
Example wrClient_pixdata[47:0]= {ipidata_raw48b[47:32],ipidata_raw48b[31:16],ipidata_raw48b[15:0]}<p></p>
NOTE: IPIswap_Y_ctrl must be 0 while programming “endianness_Y” control</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_IPIswap_M_ctrl">IPIswap_M_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In IPI48bit interface, Three 16bit IPI Embedded data position swapping control.<p></p>
case(IPIswap_M_ctrl[2:0])<p></p>
3'b000 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[31:16],ipi_pixdata[15: 0]};<p></p>
3'b001 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[31:16],ipi_pixdata[47:32]};<p></p>
3'b010 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[47:32],ipi_pixdata[15: 0]};<p></p>
3'b011 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[15: 0],ipi_pixdata[47:32]};<p></p>
3'b100 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[15: 0],ipi_pixdata[31:16]};<p></p>
3'b101 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[47:32],ipi_pixdata[31:16]};<p></p>
NOTE: IPIswap_M_ctrl can be 0 if “endianness_M” control programming is used.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_endianness_M">endianness_M</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Works on the IPI Embedded data given out by the swap (IPIswap_M_ctrl) logic.<p></p>
1: Change the Data write order for Embedded data. Nth data first (LSB) and N+1th data next (MSB).<p></p>
Example: wrClient_pixdata[47:0]= {ipidata_raw48b[15:0],ipidata_raw48b[31:16],ipidata_raw48b[47:32]}<p></p>
0: Do not Change the Data write order for Embedded data. order remain same as received from CSI2RX. N+1th data first (LSB) and Nth data next (MSB).<p></p>
Example wrClient_pixdata[47:0]= {ipidata_raw48b[47:32],ipidata_raw48b[31:16],ipidata_raw48b[15:0]}<p></p>
NOTE: IPIswap_M_ctrl must be 0 while programming “endianness_M” control</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enb_YC_haltback">enb_YC_haltback</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable output haltback from IPI data write clients (RAW8/Y)&C.<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enb_M_haltback">enb_M_haltback</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable output haltback from IPI Embedded data write clients (Embedded).<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_Y">ClientRdy_ctrl_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI Y data WriteClient (RAW8/Y), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient Y will be overridden with ClientRdy_ctrl_Y to keep the WriteClient always ready. The Halt signal from WriteClient Y will not be asserted.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_C">ClientRdy_ctrl_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI C WriteClient (C data), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient C will be overridden with ClientRdy_ctrl_C to keep the WriteClient always ready. The Halt signal from WriteClient C will not be asserted.</p>
</td>
</tr>
<tr><td><p>[12:12]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_M">ClientRdy_ctrl_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI EmbMeta WriteClient (Embedded Metadata ), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient Embeddata will be overridden with ClientRdy_ctrl_M to keep the WriteClient always ready. The Halt signal from WriteClient Embeddata will not be asserted.</p>
</td>
</tr>
<tr><td><p>[13:13]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_fifo_flush">fifo_flush</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>ipi input fifo flush.</p>
</td>
</tr>
<tr><td><p>[14:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_contemp_UV420">contemp_UV420</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>IPI data YUV420 format in Contemporary mode (Non-Legacy)<p></p>
UV-data= {ipi_pixdata[19:12],ipi_pixdata[9:2]}</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ipi_uv_swap_ctrl">ipi_uv_swap_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>1: {ipidata_uv[7:0],ipidata_uv[15:8]}={V,U}<p></p>
0: {ipidata_uv[15:8],ipidata_uv[7:0]}={U,V}<p></p>
NOTE: endianness is not used for UV data.<p></p>
ipi_uv_swap_ctrl can be used as endianness change while writing UV to Dhub.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enable_565_write">enable_565_write</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>888 format will be packed as 565 before dhub write.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2">VISPDBIF_RX1IPI2DH_CTRL2</a></p>
</td>
<td><p>32'h000000D4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_C_input_ctrl">wrClient_C_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DHUB write input selection for CSIRX2-IPI to write client C<p></p>
4'h0 : Monochrome formats, UV="0<p"></p>
4'h1 : YUV422-UV16b format :: Write 16bit UV on alternate Pixel<p></p>
4'h2 : YUV422-C8b format :: Write U in ODD pix, V in EVEN pix<p></p>
4'h3 : YUV420-UV16b :: Write 16bit UV on even pixel of even Line, Else =0<p></p>
4'h4 : YUV420-C8b Legacy format<p></p>
4'h8 : YUV422-UV16b format :: Write 16bit UV on alternate Pixel<p></p>
4'h9 : YUV422-C8b format :: Write U in ODD pix, V in EVEN pix<p></p>
4'hA : YUV420-UV16b :: Write 16bit UV on even pixel of even Line, Else =0<p></p>
4'hB : YUV420-C8b Legacy format</p>
</td>
</tr>
<tr><td><p>[7:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_Y_input_ctrl">wrClient_Y_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input control for CSIRX1-IPI0 and CSIRX1-IPI1 write clients<p></p>
4'h0 : host IPI to DHUB ( 24-bit) RAW8<p></p>
4'h1 : host IPI to DHUB ( 16/24-bit)<p></p>
4'h2 : host IPI < FIFO > DHUB ( 24-bit) RAW8<p></p>
4'h3 : host IPI < FIFO > DHUB ( 16/24-bit)<p></p>
default : host IPI to DHUB ( 24-bit) RAW8<p></p>
------------------------------------------<p></p>
Input control for CSIRX2-IPI Y write clients<p></p>
4'h0 : RAW8 = 24b/16b (16b for RGB565)<p></p>
4'h1 : RAW10 = 30b<p></p>
4'h2 : RAW12 = 36b<p></p>
4'h3 : RAW16 = 48b<p></p>
4'h4 : YUV422-Y8b = 8b<p></p>
4'h5 : YUV420-Y8b = 16b<p></p>
4'h8 : RAW8 = 24b/16b (16b for RGB565)<p></p>
4'h9 : RAW10 = 30b<p></p>
4'hA : RAW12 = 36b<p></p>
4'hB : RAW16 = 48b<p></p>
4'hC : YUV422-Y8b = 8b<p></p>
4'hD : YUV420-Y8b = 16b<p></p>
default :RAW8 = 24b</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_M_input_ctrl">wrClient_M_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input control for Embedded data Write client<p></p>
0: Swapped and Endian corrected Embedded data<p></p>
1: Endian corrected Embedded data</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_C">WrClient_clear_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Chroma write client clear</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_C">WrClient_start_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Chroma write client start</p>
</td>
</tr>
<tr><td><p>[12:12]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_Y">WrClient_clear_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Luma write client clear</p>
</td>
</tr>
<tr><td><p>[13:13]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_Y">WrClient_start_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Luma write client start</p>
</td>
</tr>
<tr><td><p>[14:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_M">WrClient_clear_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Embedded data write client clear</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_M">WrClient_start_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Embedded data write client start</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL3">VISPDBIF_RX1IPI2DH_CTRL3</a></p>
</td>
<td><p>32'h000000D8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL3_ipipix_tot">ipipix_tot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Total pixel count at IPI input fifo</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4">VISPDBIF_RX1IPI2DH_CTRL4</a></p>
</td>
<td><p>32'h000000DC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[13:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4_image_width">image_width</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Image width of sequencer for sync to start end signal conversion.</p>
</td>
</tr>
<tr><td><p>[27:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4_image_height">image_height</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Image height of sequencer for sync to start end signal conversion.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5">VISPDBIF_RX1IPI2DH_CTRL5</a></p>
</td>
<td><p>32'h000000E0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5_hblank">hblank</a></p>
</td>
<td><p>0x10</p>
</td>
<td><p>Hblank added in sequencer while doing sync to start end signal conversion.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5_iif_mode">iif_mode</a></p>
</td>
<td><p>0x10</p>
</td>
<td><p>Iif input mode for sync2se block.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX1IPI3DH_WrClient_Y_Wr</a></p>
</td>
<td><p>32'h000000E4</p>
</td>
<td><p>RAW8 to 64bit Packing selection for Write Client 7<p></p>
RX1IPI3DH_WrClient_Y_upack_Sel[3:0]=<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 16 bit packing<p></p>
[0010] : 24 bit packing ← Use this for RAW8<p></p>
RX1IPI3DH_uCTRL2_wrClient_Y_input_ctrl[3:0]<p></p>
0: Direct IPI-24-bit(RAW8) to Dhub Write Client<p></p>
1: Direct IPI-24b(RAW8) to Dhub WriteClient<p></p>
having BF_CSI2DHUB_uCTRL1_enable_565_write option. (not used)<p></p>
------<p></p>
2: case[0] but through TG re-timing ASYNC FIFO (Not required)<p></p>
3: Case[1] but through TG re-timing ASYNC FIFO (Not used)<p></p>
Register for write Client RAW8/Yluma</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX1IPI3DH_WrClient_Y_pix</a></p>
</td>
<td><p>32'h000000E8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX1IPI3DH_WrClient_Y_NonStdRes</a></p>
</td>
<td><p>32'h000000EC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX1IPI3DH_WrClient_Y_pack</a></p>
</td>
<td><p>32'h000000F0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX1IPI3DH_WrClient_C_Wr</a></p>
</td>
<td><p>32'h000000F4</p>
</td>
<td><p>Register for write Client Chroma</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX1IPI3DH_WrClient_C_pix</a></p>
</td>
<td><p>32'h000000F8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX1IPI3DH_WrClient_C_NonStdRes</a></p>
</td>
<td><p>32'h000000FC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX1IPI3DH_WrClient_C_pack</a></p>
</td>
<td><p>32'h00000100</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX1IPI3DH_WrClient_M_Wr</a></p>
</td>
<td><p>32'h00000104</p>
</td>
<td><p>Register for write Client Embedded Data</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX1IPI3DH_WrClient_M_pix</a></p>
</td>
<td><p>32'h00000108</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX1IPI3DH_WrClient_M_NonStdRes</a></p>
</td>
<td><p>32'h0000010C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX1IPI3DH_WrClient_M_pack</a></p>
</td>
<td><p>32'h00000110</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL">VISPDBIF_RX1IPI3DH_TG_CTRL</a></p>
</td>
<td><p>32'h00000114</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_tg_start">tg_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>TG start</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_tg_clear">tg_clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>TG clear</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl0">clken_ctrl0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client1 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl1">clken_ctrl1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client2 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl6">clken_ctrl6</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client3 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl2">clken_ctrl2</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on IPI fifo status.<p></p>
0: disabled<p></p>
1: enabled</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl3">clken_ctrl3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client1 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl4">clken_ctrl4</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client2 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl7">clken_ctrl7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client3 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl5">clken_ctrl5</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client 1 and client2 ready.<p></p>
0: disabled<p></p>
1: enabled</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_fifo_ctrlEn">fifo_ctrlEn</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on IPI input FIFO status.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_zero_line_delay_en">zero_line_delay_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable zero line delay programming mode.<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL">VISPDBIF_RX1IPI3DH_CLKEN_CTRL</a></p>
</td>
<td><p>32'h00000118</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_C_clken">WrClient_C_clken</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Clock gating bit for chroma write client.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_M_clken">WrClient_M_clken</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Clock gating bit for Embedded data write client.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_Y_clken">WrClient_Y_clken</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Clock gating bit for Luma/RAW data write client OCPF.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_fifo_read_on_TG_ACTIVE_en">fifo_read_on_TG_ACTIVE_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable ipi fifo read also based on TG active signal apart from hde, vde and ipi fifo status.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1">VISPDBIF_RX1IPI3DH_CTRL1</a></p>
</td>
<td><p>32'h0000011C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_IPIswap_Y_ctrl">IPIswap_Y_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In IPI48bit interface, Three 16bit IPI component RAW/Y data position swapping control.<p></p>
case(IPIswap_Y_ctrl[2:0])<p></p>
3'b000 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[31:16],ipi_pixdata[15: 0]};<p></p>
3'b001 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[31:16],ipi_pixdata[47:32]};<p></p>
3'b010 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[47:32],ipi_pixdata[15: 0]};<p></p>
3'b011 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[15: 0],ipi_pixdata[47:32]};<p></p>
3'b100 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[15: 0],ipi_pixdata[31:16]};<p></p>
3'b101 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[47:32],ipi_pixdata[31:16]};<p></p>
NOTE: IPIswap_Y_ctrl can be 0 if “endianness_Y” control programming is used.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_endianness_Y">endianness_Y</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Works on the IPI data given out by the swap (IPIswap_Y_ctrl) logic.<p></p>
1: Change the Data write order for RAW/Y data. Nth data first (LSB) and N+1th data next (MSB).<p></p>
Example: wrClient_pixdata[47:0]= {ipidata_raw48b[15:0],ipidata_raw48b[31:16],ipidata_raw48b[47:32]}<p></p>
0: Do not Change the Data write order for RAW/Y data. order remain same as received from CSI2RX. N+1th data first (LSB) and Nth data next (MSB).<p></p>
Example wrClient_pixdata[47:0]= {ipidata_raw48b[47:32],ipidata_raw48b[31:16],ipidata_raw48b[15:0]}<p></p>
NOTE: IPIswap_Y_ctrl must be 0 while programming “endianness_Y” control</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_IPIswap_M_ctrl">IPIswap_M_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In IPI48bit interface, Three 16bit IPI Embedded data position swapping control.<p></p>
case(IPIswap_M_ctrl[2:0])<p></p>
3'b000 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[31:16],ipi_pixdata[15: 0]};<p></p>
3'b001 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[31:16],ipi_pixdata[47:32]};<p></p>
3'b010 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[47:32],ipi_pixdata[15: 0]};<p></p>
3'b011 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[15: 0],ipi_pixdata[47:32]};<p></p>
3'b100 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[15: 0],ipi_pixdata[31:16]};<p></p>
3'b101 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[47:32],ipi_pixdata[31:16]};<p></p>
NOTE: IPIswap_M_ctrl can be 0 if “endianness_M” control programming is used.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_endianness_M">endianness_M</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Works on the IPI Embedded data given out by the swap (IPIswap_M_ctrl) logic.<p></p>
1: Change the Data write order for Embedded data. Nth data first (LSB) and N+1th data next (MSB).<p></p>
Example: wrClient_pixdata[47:0]= {ipidata_raw48b[15:0],ipidata_raw48b[31:16],ipidata_raw48b[47:32]}<p></p>
0: Do not Change the Data write order for Embedded data. order remain same as received from CSI2RX. N+1th data first (LSB) and Nth data next (MSB).<p></p>
Example wrClient_pixdata[47:0]= {ipidata_raw48b[47:32],ipidata_raw48b[31:16],ipidata_raw48b[15:0]}<p></p>
NOTE: IPIswap_M_ctrl must be 0 while programming “endianness_M” control</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enb_YC_haltback">enb_YC_haltback</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable output haltback from IPI data write clients (RAW8/Y)&C.<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enb_M_haltback">enb_M_haltback</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable output haltback from IPI Embedded data write clients (Embedded).<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_Y">ClientRdy_ctrl_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI Y data WriteClient (RAW8/Y), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient Y will be overridden with ClientRdy_ctrl_Y to keep the WriteClient always ready. The Halt signal from WriteClient Y will not be asserted.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_C">ClientRdy_ctrl_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI C WriteClient (C data), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient C will be overridden with ClientRdy_ctrl_C to keep the WriteClient always ready. The Halt signal from WriteClient C will not be asserted.</p>
</td>
</tr>
<tr><td><p>[12:12]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_M">ClientRdy_ctrl_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI EmbMeta WriteClient (Embedded Metadata ), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient Embeddata will be overridden with ClientRdy_ctrl_M to keep the WriteClient always ready. The Halt signal from WriteClient Embeddata will not be asserted.</p>
</td>
</tr>
<tr><td><p>[13:13]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_fifo_flush">fifo_flush</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>ipi input fifo flush.</p>
</td>
</tr>
<tr><td><p>[14:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_contemp_UV420">contemp_UV420</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>IPI data YUV420 format in Contemporary mode (Non-Legacy)<p></p>
UV-data= {ipi_pixdata[19:12],ipi_pixdata[9:2]}</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ipi_uv_swap_ctrl">ipi_uv_swap_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>1: {ipidata_uv[7:0],ipidata_uv[15:8]}={V,U}<p></p>
0: {ipidata_uv[15:8],ipidata_uv[7:0]}={U,V}<p></p>
NOTE: endianness is not used for UV data.<p></p>
ipi_uv_swap_ctrl can be used as endianness change while writing UV to Dhub.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enable_565_write">enable_565_write</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>888 format will be packed as 565 before dhub write.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2">VISPDBIF_RX1IPI3DH_CTRL2</a></p>
</td>
<td><p>32'h00000120</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_C_input_ctrl">wrClient_C_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DHUB write input selection for CSIRX2-IPI to write client C<p></p>
4'h0 : Monochrome formats, UV="0<p"></p>
4'h1 : YUV422-UV16b format :: Write 16bit UV on alternate Pixel<p></p>
4'h2 : YUV422-C8b format :: Write U in ODD pix, V in EVEN pix<p></p>
4'h3 : YUV420-UV16b :: Write 16bit UV on even pixel of even Line, Else =0<p></p>
4'h4 : YUV420-C8b Legacy format<p></p>
4'h8 : YUV422-UV16b format :: Write 16bit UV on alternate Pixel<p></p>
4'h9 : YUV422-C8b format :: Write U in ODD pix, V in EVEN pix<p></p>
4'hA : YUV420-UV16b :: Write 16bit UV on even pixel of even Line, Else =0<p></p>
4'hB : YUV420-C8b Legacy format</p>
</td>
</tr>
<tr><td><p>[7:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_Y_input_ctrl">wrClient_Y_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input control for CSIRX1-IPI0 and CSIRX1-IPI1 write clients<p></p>
4'h0 : host IPI to DHUB ( 24-bit) RAW8<p></p>
4'h1 : host IPI to DHUB ( 16/24-bit)<p></p>
4'h2 : host IPI < FIFO > DHUB ( 24-bit) RAW8<p></p>
4'h3 : host IPI < FIFO > DHUB ( 16/24-bit)<p></p>
default : host IPI to DHUB ( 24-bit) RAW8<p></p>
------------------------------------------<p></p>
Input control for CSIRX2-IPI Y write clients<p></p>
4'h0 : RAW8 = 24b/16b (16b for RGB565)<p></p>
4'h1 : RAW10 = 30b<p></p>
4'h2 : RAW12 = 36b<p></p>
4'h3 : RAW16 = 48b<p></p>
4'h4 : YUV422-Y8b = 8b<p></p>
4'h5 : YUV420-Y8b = 16b<p></p>
4'h8 : RAW8 = 24b/16b (16b for RGB565)<p></p>
4'h9 : RAW10 = 30b<p></p>
4'hA : RAW12 = 36b<p></p>
4'hB : RAW16 = 48b<p></p>
4'hC : YUV422-Y8b = 8b<p></p>
4'hD : YUV420-Y8b = 16b<p></p>
default :RAW8 = 24b</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_M_input_ctrl">wrClient_M_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input control for Embedded data Write client<p></p>
0: Swapped and Endian corrected Embedded data<p></p>
1: Endian corrected Embedded data</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_C">WrClient_clear_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Chroma write client clear</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_C">WrClient_start_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Chroma write client start</p>
</td>
</tr>
<tr><td><p>[12:12]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_Y">WrClient_clear_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Luma write client clear</p>
</td>
</tr>
<tr><td><p>[13:13]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_Y">WrClient_start_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Luma write client start</p>
</td>
</tr>
<tr><td><p>[14:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_M">WrClient_clear_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Embedded data write client clear</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_M">WrClient_start_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Embedded data write client start</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL3">VISPDBIF_RX1IPI3DH_CTRL3</a></p>
</td>
<td><p>32'h00000124</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL3_ipipix_tot">ipipix_tot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Total pixel count at IPI input fifo</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4">VISPDBIF_RX1IPI3DH_CTRL4</a></p>
</td>
<td><p>32'h00000128</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[13:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4_image_width">image_width</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Image width of sequencer for sync to start end signal conversion.</p>
</td>
</tr>
<tr><td><p>[27:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4_image_height">image_height</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Image height of sequencer for sync to start end signal conversion.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5">VISPDBIF_RX1IPI3DH_CTRL5</a></p>
</td>
<td><p>32'h0000012C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5_hblank">hblank</a></p>
</td>
<td><p>0x10</p>
</td>
<td><p>Hblank added in sequencer while doing sync to start end signal conversion.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5_iif_mode">iif_mode</a></p>
</td>
<td><p>0x10</p>
</td>
<td><p>Iif input mode for sync2se block.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX2IPI0DH_WrClient_Y_Wr</a></p>
</td>
<td><p>32'h00000130</p>
</td>
<td><p>64bit Packing selection Supported formats<p></p>
RAW 8/10/12/16b<p></p>
MONO-8b<p></p>
YUV420SP-8b<p></p>
YUV422SP-8b<p></p>
---------------------------<p></p>
RAW8,RAW10,RAW12,RAW16,Mono8,Y8: Packing selection for Write Client 9:<p></p>
RX2IPI0DH_WrClient_Y_upack_Sel[3:0]=<p></p>
[0000] : 8 bit packing ← YUV422-Y8b<p></p>
[0001] : 16 bit packing ← YUV420-2Y8b<p></p>
[0010] : 24 bit packing ← RAW8<p></p>
[0011] : 30 bit packing ← RAW10<p></p>
[0100] : 32 bit packing ← RAW10(DWA)<p></p>
[0101] : 36 bit packing ← RAW12<p></p>
[0110] : 48 bit packing ← RAW16<p></p>
C8/UV16 Packing selection for Write Client 11:<p></p>
RX2IPI0DH_WrClient_C_upack_Sel[3:0]=<p></p>
[0000]:8bit packing ← YUV422/YUV420-C8b Legacy<p></p>
[0001]:16bit packing ← YUV422/YUV420-UV16b<p></p>
EmbedData8 Packing selection for Write Client 15:<p></p>
RX2IPI0DH_WrClient_M_upack_Sel[3:0]=<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 48 bit packing ← Use this<p></p>
RX2IPI0DH_uCTRL2_wrClient_Y_input_ctrl[3:0]<p></p>
0: Direct, IPI-24-bit(RAW8) to Dhub Write Client (there is option to use BF_CSI2DHUB_uCTRL1_enable_565_write)<p></p>
1: Direct, IPI-30b(RAW10) to Dhub WriteClient<p></p>
2: Direct, IPI-36b(RAW12) to Dhub WriteClient<p></p>
3: Direct, IPI-48b(RAW16) to Dhub WriteClient<p></p>
4: Direct, IPI YUV422-Y8b(Y8/Mono8) to Dhub WriteClient<p></p>
5: Direct, IPI YUV420-Y16b(2xY8) to Dhub WriteClient<p></p>
------<p></p>
8 to 13: Same as 0 to 5 case<p></p>
But through TG re-timing ASYNC FIFO (Not required)<p></p>
RX2IPI0DH_uCTRL2_wrClient_C_input_ctrl[3:0]<p></p>
0:Direct, IPI-C Turned OFF , RAW/Mono8 modes<p></p>
1:Diect,IPI YUV422-UV16b data on every alternate pixel to Dhub WriteClient<p></p>
2:Diect,IPI YUV422-C8b data to Dhub WriteClient,i.e U8b of odd and V8b of even pixels<p></p>
3: Direct,IPI YUV420-UV16b data to Dhub WriteClient, UV16b data in alternate pixel clock and alternate lines<p></p>
4: Direct IPI Legacy YUV420-C8b data to Dhub WriteClient,i.e U8b of odd and V8b of even pixels data in alternate lines<p></p>
------<p></p>
9 to 11: same as case[0~4] But through TG re-timing ASYNC FIFO (Not required)<p></p>
RX2IPI0DH_uCTRL2_wrClient_M_input_ctrl[1:0]<p></p>
0: Direct IPI Embedded 8bit data to Dhub WriteClient, with option to change Endianness(CTRL_EMBED2_ENDIAN)<p></p>
1: Direct IPI Embeddata8 8bit data to Dhub WriteClient as it is in IPI-48bit data.<p></p>
Register for write Client RAW8/Yluma</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX2IPI0DH_WrClient_Y_pix</a></p>
</td>
<td><p>32'h00000134</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX2IPI0DH_WrClient_Y_NonStdRes</a></p>
</td>
<td><p>32'h00000138</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX2IPI0DH_WrClient_Y_pack</a></p>
</td>
<td><p>32'h0000013C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX2IPI0DH_WrClient_C_Wr</a></p>
</td>
<td><p>32'h00000140</p>
</td>
<td><p>Register for write Client Chroma</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX2IPI0DH_WrClient_C_pix</a></p>
</td>
<td><p>32'h00000144</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX2IPI0DH_WrClient_C_NonStdRes</a></p>
</td>
<td><p>32'h00000148</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX2IPI0DH_WrClient_C_pack</a></p>
</td>
<td><p>32'h0000014C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr">VISPDBIF_RX2IPI0DH_WrClient_M_Wr</a></p>
</td>
<td><p>32'h00000150</p>
</td>
<td><p>Register for write Client Embedded Data</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start bit for the respective clients.<p></p>
0 : No effect on hardware.<p></p>
1 : start the client.<p></p>
The write 1 to this register is used to kick the hardware.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_Wr_clear">clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>0 : Don't clear, normal state.<p></p>
1 : Clear the asynchronous FIFO between the respective client and dHub.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix">VISPDBIF_RX2IPI0DH_WrClient_M_pix</a></p>
</td>
<td><p>32'h00000154</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pix_tot">tot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Specifies the total number of pixels expected from input to write client. This is used to generate flush in Write client to write the partially formed 128-bit data (if any) to DDR.<p></p>
Should be programmed with (ovres*ohres).</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes">VISPDBIF_RX2IPI0DH_WrClient_M_NonStdRes</a></p>
</td>
<td><p>32'h00000158</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable for Read Client when resolution is not integer multiple of 16</p>
</td>
</tr>
<tr><td><p>[13:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_NonStdRes_pixlineTot">pixlineTot</a></p>
</td>
<td><p>0x64</p>
</td>
<td><p>Total number of pixels in a line (for Write Client)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack">VISPDBIF_RX2IPI0DH_WrClient_M_pack</a></p>
</td>
<td><p>32'h0000015C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#WriteClient_pack_Sel">Sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>PackSel for Write Client<p></p>
[0000] : 8 bit packing<p></p>
[0001] : 10 bit packing<p></p>
[0010] : 12 bit packing<p></p>
[0011] : 15 bit packing<p></p>
[0100] : 16 bit packing<p></p>
[0101] : 20 bit packing<p></p>
[0110] : 24 bit packing<p></p>
[0111] : 30 bit packing<p></p>
[1000] : 32 bit packing</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL">VISPDBIF_RX2IPI0DH_TG_CTRL</a></p>
</td>
<td><p>32'h00000160</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_tg_start">tg_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>TG start</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_tg_clear">tg_clear</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>TG clear</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl0">clken_ctrl0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client1 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl1">clken_ctrl1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client2 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl6">clken_ctrl6</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on write client3 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl2">clken_ctrl2</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on IPI fifo status.<p></p>
0: disabled<p></p>
1: enabled</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl3">clken_ctrl3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client1 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl4">clken_ctrl4</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client2 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl7">clken_ctrl7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client3 ready.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_clken_ctrl5">clken_ctrl5</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Front end (path before IPI fifo) Control flow based on write client 1 and client2 ready.<p></p>
0: disabled<p></p>
1: enabled</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_fifo_ctrlEn">fifo_ctrlEn</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Pipe TG Control flow based on IPI input FIFO status.<p></p>
0: enabled<p></p>
1: disabled</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_TG_CTRL_zero_line_delay_en">zero_line_delay_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable zero line delay programming mode.<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL">VISPDBIF_RX2IPI0DH_CLKEN_CTRL</a></p>
</td>
<td><p>32'h00000164</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_C_clken">WrClient_C_clken</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Clock gating bit for chroma write client.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_M_clken">WrClient_M_clken</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Clock gating bit for Embedded data write client.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_WrClient_Y_clken">WrClient_Y_clken</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Clock gating bit for Luma/RAW data write client OCPF.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CLKEN_CTRL_fifo_read_on_TG_ACTIVE_en">fifo_read_on_TG_ACTIVE_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable ipi fifo read also based on TG active signal apart from hde, vde and ipi fifo status.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1">VISPDBIF_RX2IPI0DH_CTRL1</a></p>
</td>
<td><p>32'h00000168</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_IPIswap_Y_ctrl">IPIswap_Y_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In IPI48bit interface, Three 16bit IPI component RAW/Y data position swapping control.<p></p>
case(IPIswap_Y_ctrl[2:0])<p></p>
3'b000 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[31:16],ipi_pixdata[15: 0]};<p></p>
3'b001 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[31:16],ipi_pixdata[47:32]};<p></p>
3'b010 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[47:32],ipi_pixdata[15: 0]};<p></p>
3'b011 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[15: 0],ipi_pixdata[47:32]};<p></p>
3'b100 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[15: 0],ipi_pixdata[31:16]};<p></p>
3'b101 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[47:32],ipi_pixdata[31:16]};<p></p>
NOTE: IPIswap_Y_ctrl can be 0 if “endianness_Y” control programming is used.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_endianness_Y">endianness_Y</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Works on the IPI data given out by the swap (IPIswap_Y_ctrl) logic.<p></p>
1: Change the Data write order for RAW/Y data. Nth data first (LSB) and N+1th data next (MSB).<p></p>
Example: wrClient_pixdata[47:0]= {ipidata_raw48b[15:0],ipidata_raw48b[31:16],ipidata_raw48b[47:32]}<p></p>
0: Do not Change the Data write order for RAW/Y data. order remain same as received from CSI2RX. N+1th data first (LSB) and Nth data next (MSB).<p></p>
Example wrClient_pixdata[47:0]= {ipidata_raw48b[47:32],ipidata_raw48b[31:16],ipidata_raw48b[15:0]}<p></p>
NOTE: IPIswap_Y_ctrl must be 0 while programming “endianness_Y” control</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_IPIswap_M_ctrl">IPIswap_M_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In IPI48bit interface, Three 16bit IPI Embedded data position swapping control.<p></p>
case(IPIswap_M_ctrl[2:0])<p></p>
3'b000 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[31:16],ipi_pixdata[15: 0]};<p></p>
3'b001 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[31:16],ipi_pixdata[47:32]};<p></p>
3'b010 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[47:32],ipi_pixdata[15: 0]};<p></p>
3'b011 : ipidata_raw48b[47:0] = {ipi_pixdata[31:16],ipi_pixdata[15: 0],ipi_pixdata[47:32]};<p></p>
3'b100 : ipidata_raw48b[47:0] = {ipi_pixdata[47:32],ipi_pixdata[15: 0],ipi_pixdata[31:16]};<p></p>
3'b101 : ipidata_raw48b[47:0] = {ipi_pixdata[15: 0],ipi_pixdata[47:32],ipi_pixdata[31:16]};<p></p>
NOTE: IPIswap_M_ctrl can be 0 if “endianness_M” control programming is used.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_endianness_M">endianness_M</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Works on the IPI Embedded data given out by the swap (IPIswap_M_ctrl) logic.<p></p>
1: Change the Data write order for Embedded data. Nth data first (LSB) and N+1th data next (MSB).<p></p>
Example: wrClient_pixdata[47:0]= {ipidata_raw48b[15:0],ipidata_raw48b[31:16],ipidata_raw48b[47:32]}<p></p>
0: Do not Change the Data write order for Embedded data. order remain same as received from CSI2RX. N+1th data first (LSB) and Nth data next (MSB).<p></p>
Example wrClient_pixdata[47:0]= {ipidata_raw48b[47:32],ipidata_raw48b[31:16],ipidata_raw48b[15:0]}<p></p>
NOTE: IPIswap_M_ctrl must be 0 while programming “endianness_M” control</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enb_YC_haltback">enb_YC_haltback</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable output haltback from IPI data write clients (RAW8/Y)&C.<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enb_M_haltback">enb_M_haltback</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Enable output haltback from IPI Embedded data write clients (Embedded).<p></p>
1: enabled<p></p>
0: disabled</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_Y">ClientRdy_ctrl_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI Y data WriteClient (RAW8/Y), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient Y will be overridden with ClientRdy_ctrl_Y to keep the WriteClient always ready. The Halt signal from WriteClient Y will not be asserted.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_C">ClientRdy_ctrl_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI C WriteClient (C data), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient C will be overridden with ClientRdy_ctrl_C to keep the WriteClient always ready. The Halt signal from WriteClient C will not be asserted.</p>
</td>
</tr>
<tr><td><p>[12:12]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ClientRdy_ctrl_M">ClientRdy_ctrl_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>CSI2RX < + > IPI EmbMeta WriteClient (Embedded Metadata ), Control flow based on write client ready.<p></p>
0: enabled<p></p>
1: disabled<p></p>
Note: The Ready signal from WriteClient Embeddata will be overridden with ClientRdy_ctrl_M to keep the WriteClient always ready. The Halt signal from WriteClient Embeddata will not be asserted.</p>
</td>
</tr>
<tr><td><p>[13:13]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_fifo_flush">fifo_flush</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>ipi input fifo flush.</p>
</td>
</tr>
<tr><td><p>[14:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_contemp_UV420">contemp_UV420</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>IPI data YUV420 format in Contemporary mode (Non-Legacy)<p></p>
UV-data= {ipi_pixdata[19:12],ipi_pixdata[9:2]}</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_ipi_uv_swap_ctrl">ipi_uv_swap_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>1: {ipidata_uv[7:0],ipidata_uv[15:8]}={V,U}<p></p>
0: {ipidata_uv[15:8],ipidata_uv[7:0]}={U,V}<p></p>
NOTE: endianness is not used for UV data.<p></p>
ipi_uv_swap_ctrl can be used as endianness change while writing UV to Dhub.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL1_enable_565_write">enable_565_write</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>888 format will be packed as 565 before dhub write.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2">VISPDBIF_RX2IPI0DH_CTRL2</a></p>
</td>
<td><p>32'h0000016C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_C_input_ctrl">wrClient_C_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DHUB write input selection for CSIRX2-IPI to write client C<p></p>
4'h0 : Monochrome formats, UV="0<p"></p>
4'h1 : YUV422-UV16b format :: Write 16bit UV on alternate Pixel<p></p>
4'h2 : YUV422-C8b format :: Write U in ODD pix, V in EVEN pix<p></p>
4'h3 : YUV420-UV16b :: Write 16bit UV on even pixel of even Line, Else =0<p></p>
4'h4 : YUV420-C8b Legacy format<p></p>
4'h8 : YUV422-UV16b format :: Write 16bit UV on alternate Pixel<p></p>
4'h9 : YUV422-C8b format :: Write U in ODD pix, V in EVEN pix<p></p>
4'hA : YUV420-UV16b :: Write 16bit UV on even pixel of even Line, Else =0<p></p>
4'hB : YUV420-C8b Legacy format</p>
</td>
</tr>
<tr><td><p>[7:4]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_Y_input_ctrl">wrClient_Y_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input control for CSIRX1-IPI0 and CSIRX1-IPI1 write clients<p></p>
4'h0 : host IPI to DHUB ( 24-bit) RAW8<p></p>
4'h1 : host IPI to DHUB ( 16/24-bit)<p></p>
4'h2 : host IPI < FIFO > DHUB ( 24-bit) RAW8<p></p>
4'h3 : host IPI < FIFO > DHUB ( 16/24-bit)<p></p>
default : host IPI to DHUB ( 24-bit) RAW8<p></p>
------------------------------------------<p></p>
Input control for CSIRX2-IPI Y write clients<p></p>
4'h0 : RAW8 = 24b/16b (16b for RGB565)<p></p>
4'h1 : RAW10 = 30b<p></p>
4'h2 : RAW12 = 36b<p></p>
4'h3 : RAW16 = 48b<p></p>
4'h4 : YUV422-Y8b = 8b<p></p>
4'h5 : YUV420-Y8b = 16b<p></p>
4'h8 : RAW8 = 24b/16b (16b for RGB565)<p></p>
4'h9 : RAW10 = 30b<p></p>
4'hA : RAW12 = 36b<p></p>
4'hB : RAW16 = 48b<p></p>
4'hC : YUV422-Y8b = 8b<p></p>
4'hD : YUV420-Y8b = 16b<p></p>
default :RAW8 = 24b</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_wrClient_M_input_ctrl">wrClient_M_input_ctrl</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input control for Embedded data Write client<p></p>
0: Swapped and Endian corrected Embedded data<p></p>
1: Endian corrected Embedded data</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_C">WrClient_clear_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Chroma write client clear</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_C">WrClient_start_C</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Chroma write client start</p>
</td>
</tr>
<tr><td><p>[12:12]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_Y">WrClient_clear_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Luma write client clear</p>
</td>
</tr>
<tr><td><p>[13:13]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_Y">WrClient_start_Y</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Luma write client start</p>
</td>
</tr>
<tr><td><p>[14:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_clear_M">WrClient_clear_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Embedded data write client clear</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL2_WrClient_start_M">WrClient_start_M</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Embedded data write client start</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL3">VISPDBIF_RX2IPI0DH_CTRL3</a></p>
</td>
<td><p>32'h00000170</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL3_ipipix_tot">ipipix_tot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Total pixel count at IPI input fifo</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4">VISPDBIF_RX2IPI0DH_CTRL4</a></p>
</td>
<td><p>32'h00000174</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[13:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4_image_width">image_width</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Image width of sequencer for sync to start end signal conversion.</p>
</td>
</tr>
<tr><td><p>[27:14]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL4_image_height">image_height</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Image height of sequencer for sync to start end signal conversion.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5">VISPDBIF_RX2IPI0DH_CTRL5</a></p>
</td>
<td><p>32'h00000178</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5_hblank">hblank</a></p>
</td>
<td><p>0x10</p>
</td>
<td><p>Hblank added in sequencer while doing sync to start end signal conversion.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#CSI2DHUB_CTRL5_iif_mode">iif_mode</a></p>
</td>
<td><p>0x10</p>
</td>
<td><p>Iif input mode for sync2se block.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_CTRL">VISPDBIF_CTRL</a></p>
</td>
<td><p>32'h0000017C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_CTRL_EMBED1_SEL">EMBED1_SEL</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>RX1-IPI Embedded Data to DHUB Write selection, Embedded data DHUB Write client input Switch<p></p>
0: RX1-IPI0 Embedded data Write to DHUB<p></p>
1: RX1-IPI1 Embedded data Write to DHUB<p></p>
2: RX1-IPI2 Embedded data Write to DHUB<p></p>
3: RX1-IPI3 Embedded data Write to DHUB</p>
</td>
</tr>
<tr><td><p>[6:2]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_CTRL_enb_halt_back">enb_halt_back</a></p>
</td>
<td><p>0x1F</p>
</td>
<td><p>1: Enable Halt back from DHUB memory write client<p></p>
0: Disable Halt back from DHUB memory write client<p></p>
[0]: Enable Halt back from DHUB memory write client-RX1 IPI0<p></p>
[1]: Enable Halt back from DHUB memory write client-RX1 IPI1<p></p>
[2]: Enable Halt back from DHUB memory write client-RX1 IPI2<p></p>
[3]: Enable Halt back from DHUB memory write client-RX1 IPI3<p></p>
[4]: Enable Halt back from DHUB memory write client-RX2 IPI</p>
</td>
</tr>
<tr><td><p>[8:7]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_CTRL_sel_halt_back">sel_halt_back</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>1: Enable Halt back from DHUB memory write client<p></p>
0: Disable Halt back from DHUB memory write client<p></p>
[0] Enable Halt back from IPI data channel write client<p></p>
[1] Enable Halt back from Embedded Data channel write client</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_ENB">VISPDBIF_ENB</a></p>
</td>
<td><p>32'h00000180</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_ENB_CFG">CFG</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_STAT0">VISPDBIF_STAT0</a></p>
</td>
<td><p>32'h00000184</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_STAT0_FLG">FLG</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMLARX1">VISPDBIF_EMLARX1</a></p>
</td>
<td><p>32'h00000188</p>
</td>
<td><p>Address to fetch CSIRX1 Embedded data Payload size per line information stored in HW , both ODD, EVEN address at once</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMLARX1_ADDR0">ADDR0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMLARX1_ADDR1">ADDR1</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMPSRX1">VISPDBIF_EMPSRX1</a></p>
</td>
<td><p>32'h0000018C</p>
</td>
<td><p>Read status registers for the CSIRX1 Embedded data Payload size per line information stored in HW , both ODD EVEN payload size at once</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMPSRX1_SIZE0">SIZE0</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMPSRX1_SIZE1">SIZE1</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMLARX2">VISPDBIF_EMLARX2</a></p>
</td>
<td><p>32'h00000190</p>
</td>
<td><p>Address to fetch CSIRX2 Embedded data Payload size per line information stored in HW , both ODD, EVEN address at once</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMLARX2_ADDR0">ADDR0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMLARX2_ADDR1">ADDR1</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMPSRX2">VISPDBIF_EMPSRX2</a></p>
</td>
<td><p>32'h00000194</p>
</td>
<td><p>Read status registers for the CSIRX2 Embedded data Payload size per line information stored in HW , both ODD EVEN payload size at once</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMPSRX2_SIZE0">SIZE0</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMPSRX2_SIZE1">SIZE1</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMBTSRX1">VISPDBIF_EMBTSRX1</a></p>
</td>
<td><p>32'h00000198</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMBTSRX1_FSIZE">FSIZE</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p>CSI2-RX1 IPI Embedded data Per frame Payload information.<p></p>
[31:30]: IPI channel (0,1,2,3) 2bits Index<p></p>
[29:8]: Total Embedded IPI48bits data count in the Frame, 22bits Max<p></p>
[7:0]: Total Embedded data lines in the frame. 8Bits Max</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMBTSRX2">VISPDBIF_EMBTSRX2</a></p>
</td>
<td><p>32'h0000019C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="vispDhIntf.htm#VISPDBIF_EMBTSRX2_FSIZE">FSIZE</a></p>
</td>
<td><p><p></p>
</p>
</td>
<td><p>CSI2-RX2 IPI Embedded data Per frame Payload information.<p></p>
[31:30]: Always 0<p></p>
[29:8]: Total Embedded IPI48bits data count in the Frame, 22bits Max<p></p>
[7:0]: Total Embedded data lines in the frame. 8Bits Max<p></p>
End</p>
</td>
</tr>
</table><p><p></p>
</p>
</body></html>