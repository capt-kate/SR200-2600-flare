<?xml version="1.0" encoding="utf-8"?><html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd"><head><title>TCPWM</title></head>
<body>
<h1><a name="TCPWM">"TCPWM"</a>
        </h1>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL">TCPWM_group00_CLK_CTRL</a></p>
</td>
<td><p>32'h00000000</p>
</td>
<td><p>counter groups #0 for 16/32-bit counters, Array size is<p></p>
matched to HW parameter CNTNUM</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL_clkdiv_sel">clkdiv_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>All TCPWM counter clock (the counter clock before active event<p></p>
and prescaling) (including otrigClk used for counter output<p></p>
triggers) are generated by a group of clock dividers, the<p></p>
number of clock divider is controlled by design parameter<p></p>
CDIVNUM (which is set to 6 by default in design), the clock<p></p>
source for all clock dividers is periClk from SoC.<p></p>
This 4-bit field is used to select the one out of CDIVNUM clock<p></p>
dividers to provide the clock enable signal which is combined<p></p>
with active event and prescaling together to generate the<p></p>
counter’s operation clock in each of TCPWM counter. (otrigClk<p></p>
is only derived from clock divider)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL">TCPWM_group00_CTRL</a></p>
</td>
<td><p>32'h00000004</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc0">auto_reload_cc0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC0 and buffered CC0 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 0 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc1">auto_reload_cc1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC1 and buffered CC1 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 1 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_period">auto_reload_period</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the PERIOD and buffered PERIOD values.<p></p>
This field has a function in PWM and PWM_DT modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.<p></p>
In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to<p></p>
select the index / wrap-around capture function.<p></p>
'0': Captures on index (reload) event. The counter value is<p></p>
copied to the PERIOD register on an index (reload) event.<p></p>
'1': Captures when COUNTER equals 0 or 0xffff. The counter value<p></p>
is copied to the PERIOD register when COUNTER equals 0 or<p></p>
0xffff.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_line_sel">auto_reload_line_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values.<p></p>
This field has a function in PWM and PWM_PR modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_up_en">cc0_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting up<p></p>
'1': compare match 0 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_down_en">cc0_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 0 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_up_en">cc1_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting up<p></p>
'1': compare match 1 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_down_en">cc1_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 1 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_imm_kill">pwm_imm_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the kill event immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals or with the next module<p></p>
clock ("active count" pre-scaled counter clock).<p></p>
'0': synchronous kill activation. Deactivates the "line_out" and<p></p>
"line_compl_out" signals with the next module clock ("active<p></p>
count" pre-scaled counter clock).<p></p>
'1': immediate kill activation. Immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_stop_on_kill">pwm_stop_on_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the counter stops on a kill events:<p></p>
'0': kill event does NOT stop counter.<p></p>
'1': kill event stops counter.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_sync_kill">pwm_sync_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies asynchronous/synchronous kill release behavior:<p></p>
'1': synchronous kill mode: the kill event disables the<p></p>
"line_out" and "line_compl_out" signals till the next terminal<p></p>
count event (synchronous kill). In synchronous kill mode,<p></p>
STOP_EDGE should be NO_EDGE_DET.<p></p>
'0': asynchronous kill mode: the kill event only disables the<p></p>
"line_out" and "line_compl_out" signals when present. In<p></p>
asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET.<p></p>
This field has a function in PWM and PWM_DT modes only. This<p></p>
field is only used when PWM_STOP_ON_KILL is '0'.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b11">reserved_b11</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[13:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_disable_mode">pwm_disable_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the behavior of the PWM outputs "line_out" and<p></p>
"line_compl_out" while the TCPWM counter is disabled<p></p>
(CTL.ENABLED='0') or stopped.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the immediate kill logic and line_out polarity<p></p>
settings (CTRL.QUAD_ENCODING_MODE).<p></p>
0x0 : Z : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are NOT driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the TCPWM output "line_out_en"<p></p>
to 0.<p></p>
When the counter is stopped upon a stop event the PWM outputs<p></p>
are deactivated (to the polarity defined by<p></p>
CTRL.QUAD_ENCODING_MODE).<p></p>
0x1 : RETAIN : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM outputs are retained (keep their previous levels).<p></p>
While the counter is disabled or stopped the PWM outputs can be<p></p>
changed via LINE_SEL.<p></p>
0x2 : L : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '0' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '1'.<p></p>
0x3 : H : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '1' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '0'.</p>
</td>
</tr>
<tr><td><p>[15:14]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b14to15">reserved_b14to15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[17:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_up_down_mode">up_down_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Determines counter direction.<p></p>
In QUAD mode this field acts as QUAD_RANGE_MODE field selecting<p></p>
between different counter range, reload value and compare /<p></p>
capture behavior.<p></p>
0x0 : COUNT_UP : Count up (to PERIOD). An overflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals PERIOD. A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals PERIOD.<p></p>
0x0 : QUAD_RANGE0 : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0 mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- on reload / index event:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- tc and cc0_match events are generated<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- cc0_match event is generated<p></p>
0x1 : COUNT_DOWN : Count down (to "0"). An underflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x1 : QUAD_RANGE0_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0_CMP mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- the capture0 event acts as 2nd reload / index event<p></p>
- on reload / index event:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on index' is selected (AUTO_RELOAD_PERIOD=0):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER is copied to PERIOD<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on wrap-around' is selected<p></p>
(AUTO_RELOAD_PERIOD=1):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to PERIOD<p></p>
- 1 or 2 compare functions (depending on CC1_PRESENT) available<p></p>
Because of that the PERIOD/PERIOD_BUFF registers are used<p></p>
instead of CC0/CC_BUFF registers to capture COUNTER at reload /<p></p>
index event or wrap-around.<p></p>
0x2 : COUNT_UPDN1 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x2 : QUAD_RANGE1_CAPT : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CAPT mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and PERIOD<p></p>
- on reload / index event:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- when COUNTER is 0x0000 and decrementing:<p></p>
- COUNTER is set to PERIOD<p></p>
- tc event is generated<p></p>
- when COUNTER equals PERIOD and is incrementing:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- 1 or 2 capture functions (depending on CC1_PRESENT) available<p></p>
- on capture0 / capture1 event:<p></p>
- CC0 / CC1 is copied to CC0_BUFF / CC1_BUFF<p></p>
- COUNTER value is copied to CC0<p></p>
It allows that the COUNTER register reflects the current angle<p></p>
position of the rotary encoder, i.e. no MOD or SUB calculations<p></p>
need to be done in SW on the COUNTER value to get the current<p></p>
angle position. This allows a DMA copy of the angle position<p></p>
from the COUNTER register. However, a disadvantage of this mode<p></p>
is that fast sequences of tc interrupts can occur (when encoder<p></p>
moves back and forth around start position). It is recommended<p></p>
to not use the tc interrupt in this mode.<p></p>
0x3 : COUNT_UPDN2 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0"<p></p>
AND when the counter changes from a state in which COUNTER<p></p>
equals PERIOD (this counter direction can be used for PWM<p></p>
functionality with asymmetrical updates).<p></p>
0x3 : QUAD_RANGE1_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CMP mode.<p></p>
The behavior is the same as for QUAD_RANGE1_CAPT mode described<p></p>
above with the only difference that 1 or 2 compare functions<p></p>
(depending on CC1_PRESENT) are available instead of 1 or 2<p></p>
capture functions.</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_one_shot">one_shot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter runs continuous. When '1', counter is turned<p></p>
off by hardware when a terminal count event is generated.</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b19">reserved_b19</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[21:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_quad_encoding_mode">quad_encoding_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In QUAD mode this field selects the quadrature encoding mode<p></p>
(X1/X2/X4) or the Up / Down rotary counting mode.<p></p>
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to<p></p>
invert "line_out" and "line_compl_out". Inversion is the last<p></p>
step in generation of "line_out" and "line_compl_out"; i.e. a<p></p>
disabled output line "line_out" has the value<p></p>
QUAD_ENCODING_MODE[0] and a disabled output line<p></p>
"line_compl_out" has the value QUAD_ENCODING_MODE[1].<p></p>
0x0 : X1 : X1 encoding (QUAD mode)<p></p>
This encoding is identical with an up / down counting<p></p>
functionality of the following way: Rising edges of input phiA<p></p>
increment or decrement the counter depending on the state of<p></p>
input phiB (direction input).<p></p>
0x1 : X2 : X2 encoding (QUAD mode)<p></p>
0x1 : INV_OUT : When bit 0 is '1', QUADRATURE_ENCODING_MODE[0]<p></p>
inverts "line_out" (PWM/PWM_DT modes)<p></p>
0x2 : X4 : X4 encoding (QUAD mode)<p></p>
0x2 : INV_COMPL_OUT : When bit 1 is '1',<p></p>
QUADRATURE_ENCODING_MODE[1] inverts "line_compl_out"<p></p>
(PWM/PWM_DT modes)<p></p>
0x3 : UP_DOWN : Up / Down rotary counting mode. Input phiA<p></p>
increments the counter, input phiB decrements the counter. The<p></p>
trigger edge detection settings apply.</p>
</td>
</tr>
<tr><td><p>[23:22]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b22tob23">reserved_b22tob23</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_mode">mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter mode.<p></p>
0x0 : TIMER : Timer mode<p></p>
0x1 : EXT : Extension mode, which is defined in ext_mode[2:0]<p></p>
0x2 : CAPTURE : Capture mode<p></p>
0x3 : QUAD : Quadrature mode<p></p>
Different encoding modes can be selected by QUAD_ENCODING_MODE<p></p>
including up/down count functionality.<p></p>
Different counter range, reload value and capture behavior can<p></p>
be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).<p></p>
0x4 : PWM : Pulse width modulation (PWM) mode<p></p>
0x5 : PWM_DT : PWM with deadtime insertion mode<p></p>
0x6 : PWM_PR : Pseudo random pulse width modulation<p></p>
0x7 : SR : Shift register mode.</p>
</td>
</tr>
<tr><td><p>[29:27]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_ext_mode">ext_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>counter extension mode when mode[2:0] = 0x1<p></p>
0x0: DSHOT mode<p></p>
0x1~0x7: reserved</p>
</td>
</tr>
<tr><td><p>[30:30]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_dbg_freeze_en">dbg_freeze_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the counter behavior in debug mode.<p></p>
'0': The counter operation continues in debug mode.<p></p>
'1': The counter operation freezes in debug mode.</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_enabled">enabled</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter enable.<p></p>
'0': counter disabled.<p></p>
'1': counter enabled.<p></p>
Counter static configuration information (e.g. CTRL.mode, all<p></p>
TRIN_CTRL0/1, TRIN_EDGE_SEL, PWM_CTRL and TROUT_SEL register<p></p>
fields) should only be modified when the counter is disabled.<p></p>
When a counter is disabled, command and status information<p></p>
associated to the counter is cleared by HW, this includes:<p></p>
- the associated counter triggers in the CMD register are set to<p></p>
'0'.<p></p>
- the counter's interrupt cause fields in counter's INTR<p></p>
register.<p></p>
- the counter's status fields in counter's STATUS register..<p></p>
- the counter's trigger outputs ("tr_out0" and tr_out1").<p></p>
- the counter's line outputs ("line_out" and "line_compl_out").</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS">TCPWM_group00_STATUS</a></p>
</td>
<td><p>32'h00000008</p>
</td>
<td><p>When the counter is disabled (CTRL.enabled = 0), then the<p></p>
STATUS.tr_* bit fields are typically reset to their default<p></p>
values. However, there are exceptions possible in the following<p></p>
cases, based on the selected input trigger via TRIN_SEL*.*_sel:<p></p>
- If a constant '0' is selected, then a '0' is read.<p></p>
- If a constant '1' is selected, then a '1' is read.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_down">down</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter is counting up. When '1', counter is counting<p></p>
down. In QUAD mode, this field indicates the direction of the<p></p>
latest counter change: '0' when last incremented and '1' when<p></p>
last decremented.</p>
</td>
</tr>
<tr><td><p>[3:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b1tob3">reserved_b1tob3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture0">tr_capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 0 trigger.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_count">tr_count</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Indicates the actual level of the selected count trigger.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_reload">tr_reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected reload trigger.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_stop">tr_stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected stop trigger.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_start">tr_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected start trigger.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture1">tr_capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_out">line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the PWM line output signal.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_compl_out">line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the complementary PWM line output<p></p>
signal</p>
</td>
</tr>
<tr><td><p>[14:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b12tob14">reserved_b12tob14</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_running">running</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', the counter is NOT running. When '1', the counter is<p></p>
running.<p></p>
This field is used to indicate that the counter is running after<p></p>
a start/reload event and that the counter is stopped after a<p></p>
stop event.<p></p>
When a running counter operation is paused in debug state (see<p></p>
CTRL.dbg_pause) then the RUNNING bit is still '1'.</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_dt_cnt">dt_cnt</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Generic 16-bit counter field. In PWM_DT mode, this counter is<p></p>
used for dead time insertion on PWM line_out<p></p>
In all other modes, this counter is used for pre-scaling the<p></p>
selected counter clock. PWM_DT mode can NOT use prescaled clock<p></p>
functionality.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0">TCPWM_group00_CC0</a></p>
</td>
<td><p>32'h0000000C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_cc0">cc0</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
1. SW reads this register when the counter is enabled<p></p>
(CTRL.enabled = 1) already; or<p></p>
2. SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1">TCPWM_group00_CC1</a></p>
</td>
<td><p>32'h00000010</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_cc1">cc1</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD">TCPWM_group00_PERIOD</a></p>
</td>
<td><p>32'h00000014</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_period">period</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>The maximum value the counter can reach. When the counter is<p></p>
designed to count for n cycles, this field should be set to<p></p>
n-1.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER">TCPWM_group00_COUNTER</a></p>
</td>
<td><p>32'h00000018</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER_val">val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>32-bit counter value. It is advised to not write to the this<p></p>
field when the counter is running.<p></p>
TCPWM counter can only be initialized by software in PWM_PR and<p></p>
SR mode.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL">TCPWM_group00_PWM_CTRL</a></p>
</td>
<td><p>32'h0000001C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc0_match_mode">cc0_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 0 event (COUNTER equals<p></p>
CC0 register) on the "line" output signals. Note that INVERT is<p></p>
especially useful for center aligned pulse width modulation.<p></p>
To generate a duty cycle of 0%, the counter CC0 register should<p></p>
be set to "0". For a 100% duty cycle, the counter CC0 register<p></p>
should be set to larger than the counter PERIOD register.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_overflow_mode">overflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter overflow event (COUNTER<p></p>
reaches PERIOD) on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_underflow_mode">underflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter underflow event (COUNTER<p></p>
reaches "0") on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc1_match_mode">cc1_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 1 event (COUNTER equals<p></p>
CC1 register) on the "line_out" output signals.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL">TCPWM_group00_LINE_SEL</a></p>
</td>
<td><p>32'h00000020</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects the source for the output signal "line_out". Default<p></p>
setting is the PWM signal "line". Other settings are useful for<p></p>
Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_out polarity setting<p></p>
(CTRL.quad_encoding_mode[0]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_out" is not driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the output "line_out_en" to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects the source for the output signal "line_compl_out".<p></p>
Default setting is the inverted PWM signal "line". Other<p></p>
settings are useful for Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_compl_out polarity<p></p>
setting (CTRL.quad_encoding_mode[1]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_compl_out" is not driven by the<p></p>
TCPWM. Instead the port default level configuration applies,<p></p>
e.g. "Z" (high impedance).<p></p>
Note: This is realized by driving the output "line_compl_out_en"<p></p>
to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF">TCPWM_group00_CC0_BUFF</a></p>
</td>
<td><p>32'h00000024</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF_cc0_buff">cc0_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC0 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF">TCPWM_group00_CC1_BUFF</a></p>
</td>
<td><p>32'h00000028</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF_cc1_buff">cc1_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC1 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF">TCPWM_group00_PERIOD_BUFF</a></p>
</td>
<td><p>32'h0000002C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF_period_buff">period_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter PERIOD register.<p></p>
In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit<p></p>
represents a tap of the shift register which can be feed back<p></p>
to the MSB of counter via an XOR tree.<p></p>
Examples for CNTWIDTH = 16:<p></p>
- Maximum length 16bit LFSR<p></p>
- polynomial x^16 + x^14 + x^13 + x^11 + 1<p></p>
- taps 0,2,3,5 - > PERIOD_BUFF = 0x002d<p></p>
- period is 2^16-1 = 65535 cycles<p></p>
- Maximum length 8bit LFSR:<p></p>
- polynomial x^8 + x^6 + x^5 + x^4 + 1<p></p>
- taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)<p></p>
- period is 2^8-1 = 255 cycles<p></p>
In SR mode PERIOD_BUFF defines which tap of the shift register<p></p>
generates the PWM output signals. For a delay of n cycles (from<p></p>
capture event to PWM output) the bit CNT_WIDTH-n should be set<p></p>
to '1'. For a shift register function only one tap should be<p></p>
use, i.e. a one-hot value must be written to PERIOD_BUFF. If<p></p>
multiple bits in PERIOD_BUFF are set then the taps are XOR<p></p>
combined.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF">TCPWM_group00_LINE_SEL_BUFF</a></p>
</td>
<td><p>32'h00000030</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Buffer for LINE_SEL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.out_sel on a terminal count event<p></p>
with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Buffer for LINE_SEL.COMPL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.compl_out_sel on a terminal count<p></p>
event with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0">TCPWM_group00_TRIN_CTRL0</a></p>
</td>
<td><p>32'h00000034</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_capture0_sel">capture0_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the up to 256 input triggers as a capture0<p></p>
trigger. Input trigger 0 is always '0' and input trigger 1 is<p></p>
always '1'.<p></p>
In the PWM, PWM_DT and PWM_PR modes this trigger is used to<p></p>
switch the values of the compare and period registers with<p></p>
their buffer counterparts.</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_count_sel">count_sel</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Selects one of the 256 input triggers as a count trigger.<p></p>
In QUAD mode, this is the first phase (phi A). Default setting<p></p>
selects input trigger 1, which is always '1'.<p></p>
Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the<p></p>
counter is externally triggered ( COUNT_SEL > 1), an external<p></p>
trigger will be required for each TR_CMD to execute. For<p></p>
example, a write to TR_CMD.START will not start the counter<p></p>
until the trigger selected by COUNT_SEL asserts. The next<p></p>
trigger will increment the counter since the counter is now<p></p>
running. This goes for all TR_CMD fields.</p>
</td>
</tr>
<tr><td><p>[23:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_reload_sel">reload_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a reload trigger.<p></p>
In QUAD mode, this is the index or revolution pulse. In these<p></p>
modes, it will update the counter with 0x8000 (counter<p></p>
midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</p>
</td>
</tr>
<tr><td><p>[31:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_stop_sel">stop_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a stop trigger.<p></p>
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In<p></p>
these modes, the kill trigger is used to either temporarily<p></p>
block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the<p></p>
functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT<p></p>
modes, the blocking of the output signals can be asynchronous<p></p>
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is<p></p>
as long as the trigger is '1' or synchronous (STOP_EDGE should<p></p>
be RISING_EDGE) in which case it extends till the next terminal<p></p>
count event.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1">TCPWM_group00_TRIN_CTRL1</a></p>
</td>
<td><p>32'h00000038</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_sel">start_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a start trigger. In<p></p>
QUAD mode, this is the second phase (phi B).</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_sel">capture1_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture0_inv">capture0_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture0 will be inverted before counter usage.</p>
</td>
</tr>
<tr><td><p>[17:17]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_count_inv">count_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger count will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_reload_inv">reload_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger reload will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_stop_inv">stop_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger stop will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[20:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_inv">start_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger start will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[21:21]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_inv">capture1_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture1 will be inverted before counter usage</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL">TCPWM_group00_TRIN_EDGE_SEL</a></p>
</td>
<td><p>32'h0000003C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture0_edge">capture0_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_count_edge">count_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_reload_edge">reload_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_stop_edge">stop_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_start_edge">start_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[11:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture1_edge">capture1_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL">TCPWM_group00_TROUT_SEL</a></p>
</td>
<td><p>32'h00000040</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out0">out0</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 0. Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH: Compare match 0 event<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7: Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_3">reserved_3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out1">out1</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 1. Default setting selects the compare match 0 event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event<p></p>
0x3 : CC0_MATCH: Compare match 0 event (default selection)<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7 : Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_7">reserved_7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD">TCPWM_group00_TR_CMD</a></p>
</td>
<td><p>32'h00000044</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture0">capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture 0 trigger. When written with '1', a capture 0 trigger<p></p>
is generated and the HW sets the field to '0' when the SW<p></p>
trigger has taken effect. It should be noted that the HW<p></p>
operates on the counter frequency. If the counter is disabled<p></p>
through CTRL.ENABLED, the field is immediately set to '0'.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reserved_1">reserved_1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reload">reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW reload trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_stop">stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW stop trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW start trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture1">capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture1 trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(WOC-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA">TCPWM_group00_INTR_STA</a></p>
</td>
<td><p>32'h00000048</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when a terminal count or DSHOT done is detected, write<p></p>
‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare0 (CC0)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare1 (CC1)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(W-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET">TCPWM_group00_INTR_SET</a></p>
</td>
<td><p>32'h0000004C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK">TCPWM_group00_INTR_MASK</a></p>
</td>
<td><p>32'h00000050</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.tc, when it is set, the counter interrupt<p></p>
will ignore the status of INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc0_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc1_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED">TCPWM_group00_INTR_MASKED</a></p>
</td>
<td><p>32'h00000054</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.tc and INTR_MASK.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc0_match and INTR_MASK.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc1_match and INTR_MASK.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME">TCPWM_group00_DEADTIME</a></p>
</td>
<td><p>32'h00000058</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_out">dt_line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In PWM_DT mode, this field is used to determine dead time before<p></p>
activating the PWM line output signal "line_out": amount of dead<p></p>
time cycles in the counter clock domain.<p></p>
In all other modes, the lower 3 bits of this field determine<p></p>
pre-scaling of the selected counter clock.<p></p>
0x0 : DIVBY1 : Divide by 1 (other-than-PWM_DT mode)<p></p>
0x1 : DIVBY2 : Divide by 2 (other-than-PWM_DT mode)<p></p>
0x2 : DIVBY4 : Divide by 4 (other-than-PWM_DT mode)<p></p>
0x3 : DIVBY8 : Divide by 8 (other-than-PWM_DT mode)<p></p>
0x4 : DIVBY16 : Divide by 16 (other-than-PWM_DT mode)<p></p>
0x5 : DIVBY32 : Divide by 32 (other-than-PWM_DT mode)<p></p>
0x6 : DIVBY64 : Divide by 64 (other-than-PWM_DT mode)<p></p>
0x7 : DIVBY128 : Divide by 128 (other-than-PWM_DT mode)</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_compl_out">dt_line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>in PWM_DT mode, this field is used to determine the dead time<p></p>
before activating the complementary PWM line output signal<p></p>
"line_compl_out": amount of dead time cycles in the counter<p></p>
clock domain.<p></p>
In all other modes, this field has no effect.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL">TCPWM_group00_SEMA_CTRL</a></p>
</td>
<td><p>32'h0000005C</p>
</td>
<td><p>there are two semaphores (sema#0 and sema#1) per counter, they<p></p>
are used to synchronize counter operation and descriptor master<p></p>
cfg automation, selected counter signal will be used to set the<p></p>
corresponding semaphore, descriptor SYN command header info<p></p>
SYN.op, SYN.msk_grp and SYN.msk will choose how to unset<p></p>
(clear) semaphore.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema0_sel">sema0_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to set sema#0.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema1_sel">sema1_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to set sema#1.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b7">reserved_b7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS">TCPWM_group00_SEMA_STS</a></p>
</td>
<td><p>32'h00000060</p>
</td>
<td><p>used to indicate two semaphores bit status, both Hardware and<p></p>
Software can access: counter will set semaphore status when the<p></p>
event defined by SEMA_CTRL occurs, SYN descriptor execution with<p></p>
OP code 4’b10 also set semaphore status; semaphore status is<p></p>
cleared when SYN descriptor with OP code 4’b11 is performed;<p></p>
Software can set semaphore status when an early SYN descriptor<p></p>
termination is required, this is useful during debug process.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema0_val">sema0_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#0 status</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema1_val">sema1_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#1 status</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME">TCPWM_group00_DSHOT_FRAME</a></p>
</td>
<td><p>32'h00000064</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME_frame">frame</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT frame 16-bit value<p></p>
[10:0] 11-bit value for throttle command (0~2047)<p></p>
[11] 1-bit flag: 1 telemetry is requested from the drone ESC<p></p>
(Electronic Speed Controller); 0 otherwise<p></p>
[15:12] 4-bit checksum for error detection</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY">TCPWM_group00_DSHOT_DUTY</a></p>
</td>
<td><p>32'h00000068</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_high">high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 1 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “1”</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_low">low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 0 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “0”</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL">TCPWM_group01_CLK_CTRL</a></p>
</td>
<td><p>32'h0000006C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL_clkdiv_sel">clkdiv_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>All TCPWM counter clock (the counter clock before active event<p></p>
and prescaling) (including otrigClk used for counter output<p></p>
triggers) are generated by a group of clock dividers, the<p></p>
number of clock divider is controlled by design parameter<p></p>
CDIVNUM (which is set to 6 by default in design), the clock<p></p>
source for all clock dividers is periClk from SoC.<p></p>
This 4-bit field is used to select the one out of CDIVNUM clock<p></p>
dividers to provide the clock enable signal which is combined<p></p>
with active event and prescaling together to generate the<p></p>
counter’s operation clock in each of TCPWM counter. (otrigClk<p></p>
is only derived from clock divider)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL">TCPWM_group01_CTRL</a></p>
</td>
<td><p>32'h00000070</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc0">auto_reload_cc0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC0 and buffered CC0 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 0 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc1">auto_reload_cc1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC1 and buffered CC1 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 1 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_period">auto_reload_period</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the PERIOD and buffered PERIOD values.<p></p>
This field has a function in PWM and PWM_DT modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.<p></p>
In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to<p></p>
select the index / wrap-around capture function.<p></p>
'0': Captures on index (reload) event. The counter value is<p></p>
copied to the PERIOD register on an index (reload) event.<p></p>
'1': Captures when COUNTER equals 0 or 0xffff. The counter value<p></p>
is copied to the PERIOD register when COUNTER equals 0 or<p></p>
0xffff.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_line_sel">auto_reload_line_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values.<p></p>
This field has a function in PWM and PWM_PR modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_up_en">cc0_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting up<p></p>
'1': compare match 0 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_down_en">cc0_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 0 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_up_en">cc1_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting up<p></p>
'1': compare match 1 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_down_en">cc1_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 1 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_imm_kill">pwm_imm_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the kill event immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals or with the next module<p></p>
clock ("active count" pre-scaled counter clock).<p></p>
'0': synchronous kill activation. Deactivates the "line_out" and<p></p>
"line_compl_out" signals with the next module clock ("active<p></p>
count" pre-scaled counter clock).<p></p>
'1': immediate kill activation. Immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_stop_on_kill">pwm_stop_on_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the counter stops on a kill events:<p></p>
'0': kill event does NOT stop counter.<p></p>
'1': kill event stops counter.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_sync_kill">pwm_sync_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies asynchronous/synchronous kill release behavior:<p></p>
'1': synchronous kill mode: the kill event disables the<p></p>
"line_out" and "line_compl_out" signals till the next terminal<p></p>
count event (synchronous kill). In synchronous kill mode,<p></p>
STOP_EDGE should be NO_EDGE_DET.<p></p>
'0': asynchronous kill mode: the kill event only disables the<p></p>
"line_out" and "line_compl_out" signals when present. In<p></p>
asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET.<p></p>
This field has a function in PWM and PWM_DT modes only. This<p></p>
field is only used when PWM_STOP_ON_KILL is '0'.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b11">reserved_b11</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[13:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_disable_mode">pwm_disable_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the behavior of the PWM outputs "line_out" and<p></p>
"line_compl_out" while the TCPWM counter is disabled<p></p>
(CTL.ENABLED='0') or stopped.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the immediate kill logic and line_out polarity<p></p>
settings (CTRL.QUAD_ENCODING_MODE).<p></p>
0x0 : Z : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are NOT driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the TCPWM output "line_out_en"<p></p>
to 0.<p></p>
When the counter is stopped upon a stop event the PWM outputs<p></p>
are deactivated (to the polarity defined by<p></p>
CTRL.QUAD_ENCODING_MODE).<p></p>
0x1 : RETAIN : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM outputs are retained (keep their previous levels).<p></p>
While the counter is disabled or stopped the PWM outputs can be<p></p>
changed via LINE_SEL.<p></p>
0x2 : L : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '0' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '1'.<p></p>
0x3 : H : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '1' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '0'.</p>
</td>
</tr>
<tr><td><p>[15:14]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b14to15">reserved_b14to15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[17:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_up_down_mode">up_down_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Determines counter direction.<p></p>
In QUAD mode this field acts as QUAD_RANGE_MODE field selecting<p></p>
between different counter range, reload value and compare /<p></p>
capture behavior.<p></p>
0x0 : COUNT_UP : Count up (to PERIOD). An overflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals PERIOD. A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals PERIOD.<p></p>
0x0 : QUAD_RANGE0 : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0 mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- on reload / index event:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- tc and cc0_match events are generated<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- cc0_match event is generated<p></p>
0x1 : COUNT_DOWN : Count down (to "0"). An underflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x1 : QUAD_RANGE0_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0_CMP mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- the capture0 event acts as 2nd reload / index event<p></p>
- on reload / index event:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on index' is selected (AUTO_RELOAD_PERIOD=0):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER is copied to PERIOD<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on wrap-around' is selected<p></p>
(AUTO_RELOAD_PERIOD=1):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to PERIOD<p></p>
- 1 or 2 compare functions (depending on CC1_PRESENT) available<p></p>
Because of that the PERIOD/PERIOD_BUFF registers are used<p></p>
instead of CC0/CC_BUFF registers to capture COUNTER at reload /<p></p>
index event or wrap-around.<p></p>
0x2 : COUNT_UPDN1 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x2 : QUAD_RANGE1_CAPT : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CAPT mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and PERIOD<p></p>
- on reload / index event:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- when COUNTER is 0x0000 and decrementing:<p></p>
- COUNTER is set to PERIOD<p></p>
- tc event is generated<p></p>
- when COUNTER equals PERIOD and is incrementing:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- 1 or 2 capture functions (depending on CC1_PRESENT) available<p></p>
- on capture0 / capture1 event:<p></p>
- CC0 / CC1 is copied to CC0_BUFF / CC1_BUFF<p></p>
- COUNTER value is copied to CC0<p></p>
It allows that the COUNTER register reflects the current angle<p></p>
position of the rotary encoder, i.e. no MOD or SUB calculations<p></p>
need to be done in SW on the COUNTER value to get the current<p></p>
angle position. This allows a DMA copy of the angle position<p></p>
from the COUNTER register. However, a disadvantage of this mode<p></p>
is that fast sequences of tc interrupts can occur (when encoder<p></p>
moves back and forth around start position). It is recommended<p></p>
to not use the tc interrupt in this mode.<p></p>
0x3 : COUNT_UPDN2 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0"<p></p>
AND when the counter changes from a state in which COUNTER<p></p>
equals PERIOD (this counter direction can be used for PWM<p></p>
functionality with asymmetrical updates).<p></p>
0x3 : QUAD_RANGE1_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CMP mode.<p></p>
The behavior is the same as for QUAD_RANGE1_CAPT mode described<p></p>
above with the only difference that 1 or 2 compare functions<p></p>
(depending on CC1_PRESENT) are available instead of 1 or 2<p></p>
capture functions.</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_one_shot">one_shot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter runs continuous. When '1', counter is turned<p></p>
off by hardware when a terminal count event is generated.</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b19">reserved_b19</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[21:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_quad_encoding_mode">quad_encoding_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In QUAD mode this field selects the quadrature encoding mode<p></p>
(X1/X2/X4) or the Up / Down rotary counting mode.<p></p>
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to<p></p>
invert "line_out" and "line_compl_out". Inversion is the last<p></p>
step in generation of "line_out" and "line_compl_out"; i.e. a<p></p>
disabled output line "line_out" has the value<p></p>
QUAD_ENCODING_MODE[0] and a disabled output line<p></p>
"line_compl_out" has the value QUAD_ENCODING_MODE[1].<p></p>
0x0 : X1 : X1 encoding (QUAD mode)<p></p>
This encoding is identical with an up / down counting<p></p>
functionality of the following way: Rising edges of input phiA<p></p>
increment or decrement the counter depending on the state of<p></p>
input phiB (direction input).<p></p>
0x1 : X2 : X2 encoding (QUAD mode)<p></p>
0x1 : INV_OUT : When bit 0 is '1', QUADRATURE_ENCODING_MODE[0]<p></p>
inverts "line_out" (PWM/PWM_DT modes)<p></p>
0x2 : X4 : X4 encoding (QUAD mode)<p></p>
0x2 : INV_COMPL_OUT : When bit 1 is '1',<p></p>
QUADRATURE_ENCODING_MODE[1] inverts "line_compl_out"<p></p>
(PWM/PWM_DT modes)<p></p>
0x3 : UP_DOWN : Up / Down rotary counting mode. Input phiA<p></p>
increments the counter, input phiB decrements the counter. The<p></p>
trigger edge detection settings apply.</p>
</td>
</tr>
<tr><td><p>[23:22]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b22tob23">reserved_b22tob23</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_mode">mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter mode.<p></p>
0x0 : TIMER : Timer mode<p></p>
0x1 : EXT : Extension mode, which is defined in ext_mode[2:0]<p></p>
0x2 : CAPTURE : Capture mode<p></p>
0x3 : QUAD : Quadrature mode<p></p>
Different encoding modes can be selected by QUAD_ENCODING_MODE<p></p>
including up/down count functionality.<p></p>
Different counter range, reload value and capture behavior can<p></p>
be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).<p></p>
0x4 : PWM : Pulse width modulation (PWM) mode<p></p>
0x5 : PWM_DT : PWM with deadtime insertion mode<p></p>
0x6 : PWM_PR : Pseudo random pulse width modulation<p></p>
0x7 : SR : Shift register mode.</p>
</td>
</tr>
<tr><td><p>[29:27]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_ext_mode">ext_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>counter extension mode when mode[2:0] = 0x1<p></p>
0x0: DSHOT mode<p></p>
0x1~0x7: reserved</p>
</td>
</tr>
<tr><td><p>[30:30]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_dbg_freeze_en">dbg_freeze_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the counter behavior in debug mode.<p></p>
'0': The counter operation continues in debug mode.<p></p>
'1': The counter operation freezes in debug mode.</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_enabled">enabled</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter enable.<p></p>
'0': counter disabled.<p></p>
'1': counter enabled.<p></p>
Counter static configuration information (e.g. CTRL.mode, all<p></p>
TRIN_CTRL0/1, TRIN_EDGE_SEL, PWM_CTRL and TROUT_SEL register<p></p>
fields) should only be modified when the counter is disabled.<p></p>
When a counter is disabled, command and status information<p></p>
associated to the counter is cleared by HW, this includes:<p></p>
- the associated counter triggers in the CMD register are set to<p></p>
'0'.<p></p>
- the counter's interrupt cause fields in counter's INTR<p></p>
register.<p></p>
- the counter's status fields in counter's STATUS register..<p></p>
- the counter's trigger outputs ("tr_out0" and tr_out1").<p></p>
- the counter's line outputs ("line_out" and "line_compl_out").</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS">TCPWM_group01_STATUS</a></p>
</td>
<td><p>32'h00000074</p>
</td>
<td><p>When the counter is disabled (CTRL.enabled = 0), then the<p></p>
STATUS.tr_* bit fields are typically reset to their default<p></p>
values. However, there are exceptions possible in the following<p></p>
cases, based on the selected input trigger via TRIN_SEL*.*_sel:<p></p>
- If a constant '0' is selected, then a '0' is read.<p></p>
- If a constant '1' is selected, then a '1' is read.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_down">down</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter is counting up. When '1', counter is counting<p></p>
down. In QUAD mode, this field indicates the direction of the<p></p>
latest counter change: '0' when last incremented and '1' when<p></p>
last decremented.</p>
</td>
</tr>
<tr><td><p>[3:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b1tob3">reserved_b1tob3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture0">tr_capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 0 trigger.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_count">tr_count</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Indicates the actual level of the selected count trigger.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_reload">tr_reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected reload trigger.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_stop">tr_stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected stop trigger.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_start">tr_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected start trigger.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture1">tr_capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_out">line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the PWM line output signal.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_compl_out">line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the complementary PWM line output<p></p>
signal</p>
</td>
</tr>
<tr><td><p>[14:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b12tob14">reserved_b12tob14</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_running">running</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', the counter is NOT running. When '1', the counter is<p></p>
running.<p></p>
This field is used to indicate that the counter is running after<p></p>
a start/reload event and that the counter is stopped after a<p></p>
stop event.<p></p>
When a running counter operation is paused in debug state (see<p></p>
CTRL.dbg_pause) then the RUNNING bit is still '1'.</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_dt_cnt">dt_cnt</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Generic 16-bit counter field. In PWM_DT mode, this counter is<p></p>
used for dead time insertion on PWM line_out<p></p>
In all other modes, this counter is used for pre-scaling the<p></p>
selected counter clock. PWM_DT mode can NOT use prescaled clock<p></p>
functionality.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0">TCPWM_group01_CC0</a></p>
</td>
<td><p>32'h00000078</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_cc0">cc0</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
1. SW reads this register when the counter is enabled<p></p>
(CTRL.enabled = 1) already; or<p></p>
2. SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1">TCPWM_group01_CC1</a></p>
</td>
<td><p>32'h0000007C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_cc1">cc1</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD">TCPWM_group01_PERIOD</a></p>
</td>
<td><p>32'h00000080</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_period">period</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>The maximum value the counter can reach. When the counter is<p></p>
designed to count for n cycles, this field should be set to<p></p>
n-1.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER">TCPWM_group01_COUNTER</a></p>
</td>
<td><p>32'h00000084</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER_val">val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>32-bit counter value. It is advised to not write to the this<p></p>
field when the counter is running.<p></p>
TCPWM counter can only be initialized by software in PWM_PR and<p></p>
SR mode.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL">TCPWM_group01_PWM_CTRL</a></p>
</td>
<td><p>32'h00000088</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc0_match_mode">cc0_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 0 event (COUNTER equals<p></p>
CC0 register) on the "line" output signals. Note that INVERT is<p></p>
especially useful for center aligned pulse width modulation.<p></p>
To generate a duty cycle of 0%, the counter CC0 register should<p></p>
be set to "0". For a 100% duty cycle, the counter CC0 register<p></p>
should be set to larger than the counter PERIOD register.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_overflow_mode">overflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter overflow event (COUNTER<p></p>
reaches PERIOD) on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_underflow_mode">underflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter underflow event (COUNTER<p></p>
reaches "0") on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc1_match_mode">cc1_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 1 event (COUNTER equals<p></p>
CC1 register) on the "line_out" output signals.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL">TCPWM_group01_LINE_SEL</a></p>
</td>
<td><p>32'h0000008C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects the source for the output signal "line_out". Default<p></p>
setting is the PWM signal "line". Other settings are useful for<p></p>
Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_out polarity setting<p></p>
(CTRL.quad_encoding_mode[0]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_out" is not driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the output "line_out_en" to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects the source for the output signal "line_compl_out".<p></p>
Default setting is the inverted PWM signal "line". Other<p></p>
settings are useful for Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_compl_out polarity<p></p>
setting (CTRL.quad_encoding_mode[1]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_compl_out" is not driven by the<p></p>
TCPWM. Instead the port default level configuration applies,<p></p>
e.g. "Z" (high impedance).<p></p>
Note: This is realized by driving the output "line_compl_out_en"<p></p>
to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF">TCPWM_group01_CC0_BUFF</a></p>
</td>
<td><p>32'h00000090</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF_cc0_buff">cc0_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC0 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF">TCPWM_group01_CC1_BUFF</a></p>
</td>
<td><p>32'h00000094</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF_cc1_buff">cc1_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC1 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF">TCPWM_group01_PERIOD_BUFF</a></p>
</td>
<td><p>32'h00000098</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF_period_buff">period_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter PERIOD register.<p></p>
In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit<p></p>
represents a tap of the shift register which can be feed back<p></p>
to the MSB of counter via an XOR tree.<p></p>
Examples for CNTWIDTH = 16:<p></p>
- Maximum length 16bit LFSR<p></p>
- polynomial x^16 + x^14 + x^13 + x^11 + 1<p></p>
- taps 0,2,3,5 - > PERIOD_BUFF = 0x002d<p></p>
- period is 2^16-1 = 65535 cycles<p></p>
- Maximum length 8bit LFSR:<p></p>
- polynomial x^8 + x^6 + x^5 + x^4 + 1<p></p>
- taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)<p></p>
- period is 2^8-1 = 255 cycles<p></p>
In SR mode PERIOD_BUFF defines which tap of the shift register<p></p>
generates the PWM output signals. For a delay of n cycles (from<p></p>
capture event to PWM output) the bit CNT_WIDTH-n should be set<p></p>
to '1'. For a shift register function only one tap should be<p></p>
use, i.e. a one-hot value must be written to PERIOD_BUFF. If<p></p>
multiple bits in PERIOD_BUFF are set then the taps are XOR<p></p>
combined.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF">TCPWM_group01_LINE_SEL_BUFF</a></p>
</td>
<td><p>32'h0000009C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Buffer for LINE_SEL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.out_sel on a terminal count event<p></p>
with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Buffer for LINE_SEL.COMPL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.compl_out_sel on a terminal count<p></p>
event with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0">TCPWM_group01_TRIN_CTRL0</a></p>
</td>
<td><p>32'h000000A0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_capture0_sel">capture0_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the up to 256 input triggers as a capture0<p></p>
trigger. Input trigger 0 is always '0' and input trigger 1 is<p></p>
always '1'.<p></p>
In the PWM, PWM_DT and PWM_PR modes this trigger is used to<p></p>
switch the values of the compare and period registers with<p></p>
their buffer counterparts.</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_count_sel">count_sel</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Selects one of the 256 input triggers as a count trigger.<p></p>
In QUAD mode, this is the first phase (phi A). Default setting<p></p>
selects input trigger 1, which is always '1'.<p></p>
Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the<p></p>
counter is externally triggered ( COUNT_SEL > 1), an external<p></p>
trigger will be required for each TR_CMD to execute. For<p></p>
example, a write to TR_CMD.START will not start the counter<p></p>
until the trigger selected by COUNT_SEL asserts. The next<p></p>
trigger will increment the counter since the counter is now<p></p>
running. This goes for all TR_CMD fields.</p>
</td>
</tr>
<tr><td><p>[23:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_reload_sel">reload_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a reload trigger.<p></p>
In QUAD mode, this is the index or revolution pulse. In these<p></p>
modes, it will update the counter with 0x8000 (counter<p></p>
midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</p>
</td>
</tr>
<tr><td><p>[31:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_stop_sel">stop_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a stop trigger.<p></p>
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In<p></p>
these modes, the kill trigger is used to either temporarily<p></p>
block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the<p></p>
functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT<p></p>
modes, the blocking of the output signals can be asynchronous<p></p>
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is<p></p>
as long as the trigger is '1' or synchronous (STOP_EDGE should<p></p>
be RISING_EDGE) in which case it extends till the next terminal<p></p>
count event.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1">TCPWM_group01_TRIN_CTRL1</a></p>
</td>
<td><p>32'h000000A4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_sel">start_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a start trigger. In<p></p>
QUAD mode, this is the second phase (phi B).</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_sel">capture1_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture0_inv">capture0_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture0 will be inverted before counter usage.</p>
</td>
</tr>
<tr><td><p>[17:17]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_count_inv">count_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger count will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_reload_inv">reload_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger reload will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_stop_inv">stop_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger stop will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[20:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_inv">start_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger start will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[21:21]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_inv">capture1_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture1 will be inverted before counter usage</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL">TCPWM_group01_TRIN_EDGE_SEL</a></p>
</td>
<td><p>32'h000000A8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture0_edge">capture0_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_count_edge">count_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_reload_edge">reload_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_stop_edge">stop_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_start_edge">start_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[11:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture1_edge">capture1_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL">TCPWM_group01_TROUT_SEL</a></p>
</td>
<td><p>32'h000000AC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out0">out0</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 0. Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH: Compare match 0 event<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7: Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_3">reserved_3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out1">out1</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 1. Default setting selects the compare match 0 event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event<p></p>
0x3 : CC0_MATCH: Compare match 0 event (default selection)<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7 : Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_7">reserved_7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD">TCPWM_group01_TR_CMD</a></p>
</td>
<td><p>32'h000000B0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture0">capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture 0 trigger. When written with '1', a capture 0 trigger<p></p>
is generated and the HW sets the field to '0' when the SW<p></p>
trigger has taken effect. It should be noted that the HW<p></p>
operates on the counter frequency. If the counter is disabled<p></p>
through CTRL.ENABLED, the field is immediately set to '0'.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reserved_1">reserved_1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reload">reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW reload trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_stop">stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW stop trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW start trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture1">capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture1 trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(WOC-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA">TCPWM_group01_INTR_STA</a></p>
</td>
<td><p>32'h000000B4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when a terminal count or DSHOT done is detected, write<p></p>
‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare0 (CC0)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare1 (CC1)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(W-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET">TCPWM_group01_INTR_SET</a></p>
</td>
<td><p>32'h000000B8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK">TCPWM_group01_INTR_MASK</a></p>
</td>
<td><p>32'h000000BC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.tc, when it is set, the counter interrupt<p></p>
will ignore the status of INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc0_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc1_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED">TCPWM_group01_INTR_MASKED</a></p>
</td>
<td><p>32'h000000C0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.tc and INTR_MASK.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc0_match and INTR_MASK.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc1_match and INTR_MASK.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME">TCPWM_group01_DEADTIME</a></p>
</td>
<td><p>32'h000000C4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_out">dt_line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In PWM_DT mode, this field is used to determine dead time before<p></p>
activating the PWM line output signal "line_out": amount of dead<p></p>
time cycles in the counter clock domain.<p></p>
In all other modes, the lower 3 bits of this field determine<p></p>
pre-scaling of the selected counter clock.<p></p>
0x0 : DIVBY1 : Divide by 1 (other-than-PWM_DT mode)<p></p>
0x1 : DIVBY2 : Divide by 2 (other-than-PWM_DT mode)<p></p>
0x2 : DIVBY4 : Divide by 4 (other-than-PWM_DT mode)<p></p>
0x3 : DIVBY8 : Divide by 8 (other-than-PWM_DT mode)<p></p>
0x4 : DIVBY16 : Divide by 16 (other-than-PWM_DT mode)<p></p>
0x5 : DIVBY32 : Divide by 32 (other-than-PWM_DT mode)<p></p>
0x6 : DIVBY64 : Divide by 64 (other-than-PWM_DT mode)<p></p>
0x7 : DIVBY128 : Divide by 128 (other-than-PWM_DT mode)</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_compl_out">dt_line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>in PWM_DT mode, this field is used to determine the dead time<p></p>
before activating the complementary PWM line output signal<p></p>
"line_compl_out": amount of dead time cycles in the counter<p></p>
clock domain.<p></p>
In all other modes, this field has no effect.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL">TCPWM_group01_SEMA_CTRL</a></p>
</td>
<td><p>32'h000000C8</p>
</td>
<td><p>there are two semaphores (sema#0 and sema#1) per counter, they<p></p>
are used to synchronize counter operation and descriptor master<p></p>
cfg automation, selected counter signal will be used to set the<p></p>
corresponding semaphore, descriptor SYN command header info<p></p>
SYN.op, SYN.msk_grp and SYN.msk will choose how to unset<p></p>
(clear) semaphore.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema0_sel">sema0_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to set sema#0.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema1_sel">sema1_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to set sema#1.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b7">reserved_b7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS">TCPWM_group01_SEMA_STS</a></p>
</td>
<td><p>32'h000000CC</p>
</td>
<td><p>used to indicate two semaphores bit status, both Hardware and<p></p>
Software can access: counter will set semaphore status when the<p></p>
event defined by SEMA_CTRL occurs, SYN descriptor execution with<p></p>
OP code 4’b10 also set semaphore status; semaphore status is<p></p>
cleared when SYN descriptor with OP code 4’b11 is performed;<p></p>
Software can set semaphore status when an early SYN descriptor<p></p>
termination is required, this is useful during debug process.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema0_val">sema0_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#0 status</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema1_val">sema1_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#1 status</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME">TCPWM_group01_DSHOT_FRAME</a></p>
</td>
<td><p>32'h000000D0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME_frame">frame</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT frame 16-bit value<p></p>
[10:0] 11-bit value for throttle command (0~2047)<p></p>
[11] 1-bit flag: 1 telemetry is requested from the drone ESC<p></p>
(Electronic Speed Controller); 0 otherwise<p></p>
[15:12] 4-bit checksum for error detection</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY">TCPWM_group01_DSHOT_DUTY</a></p>
</td>
<td><p>32'h000000D4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_high">high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 1 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “1”</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_low">low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 0 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “0”</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL">TCPWM_group02_CLK_CTRL</a></p>
</td>
<td><p>32'h000000D8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL_clkdiv_sel">clkdiv_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>All TCPWM counter clock (the counter clock before active event<p></p>
and prescaling) (including otrigClk used for counter output<p></p>
triggers) are generated by a group of clock dividers, the<p></p>
number of clock divider is controlled by design parameter<p></p>
CDIVNUM (which is set to 6 by default in design), the clock<p></p>
source for all clock dividers is periClk from SoC.<p></p>
This 4-bit field is used to select the one out of CDIVNUM clock<p></p>
dividers to provide the clock enable signal which is combined<p></p>
with active event and prescaling together to generate the<p></p>
counter’s operation clock in each of TCPWM counter. (otrigClk<p></p>
is only derived from clock divider)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL">TCPWM_group02_CTRL</a></p>
</td>
<td><p>32'h000000DC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc0">auto_reload_cc0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC0 and buffered CC0 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 0 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc1">auto_reload_cc1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC1 and buffered CC1 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 1 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_period">auto_reload_period</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the PERIOD and buffered PERIOD values.<p></p>
This field has a function in PWM and PWM_DT modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.<p></p>
In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to<p></p>
select the index / wrap-around capture function.<p></p>
'0': Captures on index (reload) event. The counter value is<p></p>
copied to the PERIOD register on an index (reload) event.<p></p>
'1': Captures when COUNTER equals 0 or 0xffff. The counter value<p></p>
is copied to the PERIOD register when COUNTER equals 0 or<p></p>
0xffff.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_line_sel">auto_reload_line_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values.<p></p>
This field has a function in PWM and PWM_PR modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_up_en">cc0_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting up<p></p>
'1': compare match 0 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_down_en">cc0_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 0 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_up_en">cc1_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting up<p></p>
'1': compare match 1 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_down_en">cc1_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 1 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_imm_kill">pwm_imm_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the kill event immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals or with the next module<p></p>
clock ("active count" pre-scaled counter clock).<p></p>
'0': synchronous kill activation. Deactivates the "line_out" and<p></p>
"line_compl_out" signals with the next module clock ("active<p></p>
count" pre-scaled counter clock).<p></p>
'1': immediate kill activation. Immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_stop_on_kill">pwm_stop_on_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the counter stops on a kill events:<p></p>
'0': kill event does NOT stop counter.<p></p>
'1': kill event stops counter.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_sync_kill">pwm_sync_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies asynchronous/synchronous kill release behavior:<p></p>
'1': synchronous kill mode: the kill event disables the<p></p>
"line_out" and "line_compl_out" signals till the next terminal<p></p>
count event (synchronous kill). In synchronous kill mode,<p></p>
STOP_EDGE should be NO_EDGE_DET.<p></p>
'0': asynchronous kill mode: the kill event only disables the<p></p>
"line_out" and "line_compl_out" signals when present. In<p></p>
asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET.<p></p>
This field has a function in PWM and PWM_DT modes only. This<p></p>
field is only used when PWM_STOP_ON_KILL is '0'.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b11">reserved_b11</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[13:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_disable_mode">pwm_disable_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the behavior of the PWM outputs "line_out" and<p></p>
"line_compl_out" while the TCPWM counter is disabled<p></p>
(CTL.ENABLED='0') or stopped.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the immediate kill logic and line_out polarity<p></p>
settings (CTRL.QUAD_ENCODING_MODE).<p></p>
0x0 : Z : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are NOT driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the TCPWM output "line_out_en"<p></p>
to 0.<p></p>
When the counter is stopped upon a stop event the PWM outputs<p></p>
are deactivated (to the polarity defined by<p></p>
CTRL.QUAD_ENCODING_MODE).<p></p>
0x1 : RETAIN : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM outputs are retained (keep their previous levels).<p></p>
While the counter is disabled or stopped the PWM outputs can be<p></p>
changed via LINE_SEL.<p></p>
0x2 : L : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '0' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '1'.<p></p>
0x3 : H : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '1' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '0'.</p>
</td>
</tr>
<tr><td><p>[15:14]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b14to15">reserved_b14to15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[17:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_up_down_mode">up_down_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Determines counter direction.<p></p>
In QUAD mode this field acts as QUAD_RANGE_MODE field selecting<p></p>
between different counter range, reload value and compare /<p></p>
capture behavior.<p></p>
0x0 : COUNT_UP : Count up (to PERIOD). An overflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals PERIOD. A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals PERIOD.<p></p>
0x0 : QUAD_RANGE0 : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0 mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- on reload / index event:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- tc and cc0_match events are generated<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- cc0_match event is generated<p></p>
0x1 : COUNT_DOWN : Count down (to "0"). An underflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x1 : QUAD_RANGE0_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0_CMP mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- the capture0 event acts as 2nd reload / index event<p></p>
- on reload / index event:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on index' is selected (AUTO_RELOAD_PERIOD=0):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER is copied to PERIOD<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on wrap-around' is selected<p></p>
(AUTO_RELOAD_PERIOD=1):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to PERIOD<p></p>
- 1 or 2 compare functions (depending on CC1_PRESENT) available<p></p>
Because of that the PERIOD/PERIOD_BUFF registers are used<p></p>
instead of CC0/CC_BUFF registers to capture COUNTER at reload /<p></p>
index event or wrap-around.<p></p>
0x2 : COUNT_UPDN1 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x2 : QUAD_RANGE1_CAPT : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CAPT mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and PERIOD<p></p>
- on reload / index event:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- when COUNTER is 0x0000 and decrementing:<p></p>
- COUNTER is set to PERIOD<p></p>
- tc event is generated<p></p>
- when COUNTER equals PERIOD and is incrementing:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- 1 or 2 capture functions (depending on CC1_PRESENT) available<p></p>
- on capture0 / capture1 event:<p></p>
- CC0 / CC1 is copied to CC0_BUFF / CC1_BUFF<p></p>
- COUNTER value is copied to CC0<p></p>
It allows that the COUNTER register reflects the current angle<p></p>
position of the rotary encoder, i.e. no MOD or SUB calculations<p></p>
need to be done in SW on the COUNTER value to get the current<p></p>
angle position. This allows a DMA copy of the angle position<p></p>
from the COUNTER register. However, a disadvantage of this mode<p></p>
is that fast sequences of tc interrupts can occur (when encoder<p></p>
moves back and forth around start position). It is recommended<p></p>
to not use the tc interrupt in this mode.<p></p>
0x3 : COUNT_UPDN2 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0"<p></p>
AND when the counter changes from a state in which COUNTER<p></p>
equals PERIOD (this counter direction can be used for PWM<p></p>
functionality with asymmetrical updates).<p></p>
0x3 : QUAD_RANGE1_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CMP mode.<p></p>
The behavior is the same as for QUAD_RANGE1_CAPT mode described<p></p>
above with the only difference that 1 or 2 compare functions<p></p>
(depending on CC1_PRESENT) are available instead of 1 or 2<p></p>
capture functions.</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_one_shot">one_shot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter runs continuous. When '1', counter is turned<p></p>
off by hardware when a terminal count event is generated.</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b19">reserved_b19</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[21:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_quad_encoding_mode">quad_encoding_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In QUAD mode this field selects the quadrature encoding mode<p></p>
(X1/X2/X4) or the Up / Down rotary counting mode.<p></p>
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to<p></p>
invert "line_out" and "line_compl_out". Inversion is the last<p></p>
step in generation of "line_out" and "line_compl_out"; i.e. a<p></p>
disabled output line "line_out" has the value<p></p>
QUAD_ENCODING_MODE[0] and a disabled output line<p></p>
"line_compl_out" has the value QUAD_ENCODING_MODE[1].<p></p>
0x0 : X1 : X1 encoding (QUAD mode)<p></p>
This encoding is identical with an up / down counting<p></p>
functionality of the following way: Rising edges of input phiA<p></p>
increment or decrement the counter depending on the state of<p></p>
input phiB (direction input).<p></p>
0x1 : X2 : X2 encoding (QUAD mode)<p></p>
0x1 : INV_OUT : When bit 0 is '1', QUADRATURE_ENCODING_MODE[0]<p></p>
inverts "line_out" (PWM/PWM_DT modes)<p></p>
0x2 : X4 : X4 encoding (QUAD mode)<p></p>
0x2 : INV_COMPL_OUT : When bit 1 is '1',<p></p>
QUADRATURE_ENCODING_MODE[1] inverts "line_compl_out"<p></p>
(PWM/PWM_DT modes)<p></p>
0x3 : UP_DOWN : Up / Down rotary counting mode. Input phiA<p></p>
increments the counter, input phiB decrements the counter. The<p></p>
trigger edge detection settings apply.</p>
</td>
</tr>
<tr><td><p>[23:22]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b22tob23">reserved_b22tob23</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_mode">mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter mode.<p></p>
0x0 : TIMER : Timer mode<p></p>
0x1 : EXT : Extension mode, which is defined in ext_mode[2:0]<p></p>
0x2 : CAPTURE : Capture mode<p></p>
0x3 : QUAD : Quadrature mode<p></p>
Different encoding modes can be selected by QUAD_ENCODING_MODE<p></p>
including up/down count functionality.<p></p>
Different counter range, reload value and capture behavior can<p></p>
be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).<p></p>
0x4 : PWM : Pulse width modulation (PWM) mode<p></p>
0x5 : PWM_DT : PWM with deadtime insertion mode<p></p>
0x6 : PWM_PR : Pseudo random pulse width modulation<p></p>
0x7 : SR : Shift register mode.</p>
</td>
</tr>
<tr><td><p>[29:27]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_ext_mode">ext_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>counter extension mode when mode[2:0] = 0x1<p></p>
0x0: DSHOT mode<p></p>
0x1~0x7: reserved</p>
</td>
</tr>
<tr><td><p>[30:30]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_dbg_freeze_en">dbg_freeze_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the counter behavior in debug mode.<p></p>
'0': The counter operation continues in debug mode.<p></p>
'1': The counter operation freezes in debug mode.</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_enabled">enabled</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter enable.<p></p>
'0': counter disabled.<p></p>
'1': counter enabled.<p></p>
Counter static configuration information (e.g. CTRL.mode, all<p></p>
TRIN_CTRL0/1, TRIN_EDGE_SEL, PWM_CTRL and TROUT_SEL register<p></p>
fields) should only be modified when the counter is disabled.<p></p>
When a counter is disabled, command and status information<p></p>
associated to the counter is cleared by HW, this includes:<p></p>
- the associated counter triggers in the CMD register are set to<p></p>
'0'.<p></p>
- the counter's interrupt cause fields in counter's INTR<p></p>
register.<p></p>
- the counter's status fields in counter's STATUS register..<p></p>
- the counter's trigger outputs ("tr_out0" and tr_out1").<p></p>
- the counter's line outputs ("line_out" and "line_compl_out").</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS">TCPWM_group02_STATUS</a></p>
</td>
<td><p>32'h000000E0</p>
</td>
<td><p>When the counter is disabled (CTRL.enabled = 0), then the<p></p>
STATUS.tr_* bit fields are typically reset to their default<p></p>
values. However, there are exceptions possible in the following<p></p>
cases, based on the selected input trigger via TRIN_SEL*.*_sel:<p></p>
- If a constant '0' is selected, then a '0' is read.<p></p>
- If a constant '1' is selected, then a '1' is read.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_down">down</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter is counting up. When '1', counter is counting<p></p>
down. In QUAD mode, this field indicates the direction of the<p></p>
latest counter change: '0' when last incremented and '1' when<p></p>
last decremented.</p>
</td>
</tr>
<tr><td><p>[3:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b1tob3">reserved_b1tob3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture0">tr_capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 0 trigger.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_count">tr_count</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Indicates the actual level of the selected count trigger.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_reload">tr_reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected reload trigger.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_stop">tr_stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected stop trigger.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_start">tr_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected start trigger.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture1">tr_capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_out">line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the PWM line output signal.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_compl_out">line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the complementary PWM line output<p></p>
signal</p>
</td>
</tr>
<tr><td><p>[14:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b12tob14">reserved_b12tob14</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_running">running</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', the counter is NOT running. When '1', the counter is<p></p>
running.<p></p>
This field is used to indicate that the counter is running after<p></p>
a start/reload event and that the counter is stopped after a<p></p>
stop event.<p></p>
When a running counter operation is paused in debug state (see<p></p>
CTRL.dbg_pause) then the RUNNING bit is still '1'.</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_dt_cnt">dt_cnt</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Generic 16-bit counter field. In PWM_DT mode, this counter is<p></p>
used for dead time insertion on PWM line_out<p></p>
In all other modes, this counter is used for pre-scaling the<p></p>
selected counter clock. PWM_DT mode can NOT use prescaled clock<p></p>
functionality.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0">TCPWM_group02_CC0</a></p>
</td>
<td><p>32'h000000E4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_cc0">cc0</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
1. SW reads this register when the counter is enabled<p></p>
(CTRL.enabled = 1) already; or<p></p>
2. SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1">TCPWM_group02_CC1</a></p>
</td>
<td><p>32'h000000E8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_cc1">cc1</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD">TCPWM_group02_PERIOD</a></p>
</td>
<td><p>32'h000000EC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_period">period</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>The maximum value the counter can reach. When the counter is<p></p>
designed to count for n cycles, this field should be set to<p></p>
n-1.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER">TCPWM_group02_COUNTER</a></p>
</td>
<td><p>32'h000000F0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER_val">val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>32-bit counter value. It is advised to not write to the this<p></p>
field when the counter is running.<p></p>
TCPWM counter can only be initialized by software in PWM_PR and<p></p>
SR mode.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL">TCPWM_group02_PWM_CTRL</a></p>
</td>
<td><p>32'h000000F4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc0_match_mode">cc0_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 0 event (COUNTER equals<p></p>
CC0 register) on the "line" output signals. Note that INVERT is<p></p>
especially useful for center aligned pulse width modulation.<p></p>
To generate a duty cycle of 0%, the counter CC0 register should<p></p>
be set to "0". For a 100% duty cycle, the counter CC0 register<p></p>
should be set to larger than the counter PERIOD register.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_overflow_mode">overflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter overflow event (COUNTER<p></p>
reaches PERIOD) on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_underflow_mode">underflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter underflow event (COUNTER<p></p>
reaches "0") on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc1_match_mode">cc1_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 1 event (COUNTER equals<p></p>
CC1 register) on the "line_out" output signals.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL">TCPWM_group02_LINE_SEL</a></p>
</td>
<td><p>32'h000000F8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects the source for the output signal "line_out". Default<p></p>
setting is the PWM signal "line". Other settings are useful for<p></p>
Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_out polarity setting<p></p>
(CTRL.quad_encoding_mode[0]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_out" is not driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the output "line_out_en" to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects the source for the output signal "line_compl_out".<p></p>
Default setting is the inverted PWM signal "line". Other<p></p>
settings are useful for Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_compl_out polarity<p></p>
setting (CTRL.quad_encoding_mode[1]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_compl_out" is not driven by the<p></p>
TCPWM. Instead the port default level configuration applies,<p></p>
e.g. "Z" (high impedance).<p></p>
Note: This is realized by driving the output "line_compl_out_en"<p></p>
to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF">TCPWM_group02_CC0_BUFF</a></p>
</td>
<td><p>32'h000000FC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF_cc0_buff">cc0_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC0 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF">TCPWM_group02_CC1_BUFF</a></p>
</td>
<td><p>32'h00000100</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF_cc1_buff">cc1_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC1 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF">TCPWM_group02_PERIOD_BUFF</a></p>
</td>
<td><p>32'h00000104</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF_period_buff">period_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter PERIOD register.<p></p>
In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit<p></p>
represents a tap of the shift register which can be feed back<p></p>
to the MSB of counter via an XOR tree.<p></p>
Examples for CNTWIDTH = 16:<p></p>
- Maximum length 16bit LFSR<p></p>
- polynomial x^16 + x^14 + x^13 + x^11 + 1<p></p>
- taps 0,2,3,5 - > PERIOD_BUFF = 0x002d<p></p>
- period is 2^16-1 = 65535 cycles<p></p>
- Maximum length 8bit LFSR:<p></p>
- polynomial x^8 + x^6 + x^5 + x^4 + 1<p></p>
- taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)<p></p>
- period is 2^8-1 = 255 cycles<p></p>
In SR mode PERIOD_BUFF defines which tap of the shift register<p></p>
generates the PWM output signals. For a delay of n cycles (from<p></p>
capture event to PWM output) the bit CNT_WIDTH-n should be set<p></p>
to '1'. For a shift register function only one tap should be<p></p>
use, i.e. a one-hot value must be written to PERIOD_BUFF. If<p></p>
multiple bits in PERIOD_BUFF are set then the taps are XOR<p></p>
combined.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF">TCPWM_group02_LINE_SEL_BUFF</a></p>
</td>
<td><p>32'h00000108</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Buffer for LINE_SEL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.out_sel on a terminal count event<p></p>
with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Buffer for LINE_SEL.COMPL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.compl_out_sel on a terminal count<p></p>
event with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0">TCPWM_group02_TRIN_CTRL0</a></p>
</td>
<td><p>32'h0000010C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_capture0_sel">capture0_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the up to 256 input triggers as a capture0<p></p>
trigger. Input trigger 0 is always '0' and input trigger 1 is<p></p>
always '1'.<p></p>
In the PWM, PWM_DT and PWM_PR modes this trigger is used to<p></p>
switch the values of the compare and period registers with<p></p>
their buffer counterparts.</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_count_sel">count_sel</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Selects one of the 256 input triggers as a count trigger.<p></p>
In QUAD mode, this is the first phase (phi A). Default setting<p></p>
selects input trigger 1, which is always '1'.<p></p>
Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the<p></p>
counter is externally triggered ( COUNT_SEL > 1), an external<p></p>
trigger will be required for each TR_CMD to execute. For<p></p>
example, a write to TR_CMD.START will not start the counter<p></p>
until the trigger selected by COUNT_SEL asserts. The next<p></p>
trigger will increment the counter since the counter is now<p></p>
running. This goes for all TR_CMD fields.</p>
</td>
</tr>
<tr><td><p>[23:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_reload_sel">reload_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a reload trigger.<p></p>
In QUAD mode, this is the index or revolution pulse. In these<p></p>
modes, it will update the counter with 0x8000 (counter<p></p>
midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</p>
</td>
</tr>
<tr><td><p>[31:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_stop_sel">stop_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a stop trigger.<p></p>
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In<p></p>
these modes, the kill trigger is used to either temporarily<p></p>
block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the<p></p>
functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT<p></p>
modes, the blocking of the output signals can be asynchronous<p></p>
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is<p></p>
as long as the trigger is '1' or synchronous (STOP_EDGE should<p></p>
be RISING_EDGE) in which case it extends till the next terminal<p></p>
count event.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1">TCPWM_group02_TRIN_CTRL1</a></p>
</td>
<td><p>32'h00000110</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_sel">start_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a start trigger. In<p></p>
QUAD mode, this is the second phase (phi B).</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_sel">capture1_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture0_inv">capture0_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture0 will be inverted before counter usage.</p>
</td>
</tr>
<tr><td><p>[17:17]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_count_inv">count_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger count will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_reload_inv">reload_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger reload will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_stop_inv">stop_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger stop will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[20:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_inv">start_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger start will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[21:21]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_inv">capture1_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture1 will be inverted before counter usage</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL">TCPWM_group02_TRIN_EDGE_SEL</a></p>
</td>
<td><p>32'h00000114</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture0_edge">capture0_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_count_edge">count_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_reload_edge">reload_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_stop_edge">stop_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_start_edge">start_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[11:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture1_edge">capture1_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL">TCPWM_group02_TROUT_SEL</a></p>
</td>
<td><p>32'h00000118</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out0">out0</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 0. Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH: Compare match 0 event<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7: Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_3">reserved_3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out1">out1</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 1. Default setting selects the compare match 0 event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event<p></p>
0x3 : CC0_MATCH: Compare match 0 event (default selection)<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7 : Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_7">reserved_7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD">TCPWM_group02_TR_CMD</a></p>
</td>
<td><p>32'h0000011C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture0">capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture 0 trigger. When written with '1', a capture 0 trigger<p></p>
is generated and the HW sets the field to '0' when the SW<p></p>
trigger has taken effect. It should be noted that the HW<p></p>
operates on the counter frequency. If the counter is disabled<p></p>
through CTRL.ENABLED, the field is immediately set to '0'.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reserved_1">reserved_1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reload">reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW reload trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_stop">stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW stop trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW start trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture1">capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture1 trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(WOC-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA">TCPWM_group02_INTR_STA</a></p>
</td>
<td><p>32'h00000120</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when a terminal count or DSHOT done is detected, write<p></p>
‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare0 (CC0)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare1 (CC1)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(W-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET">TCPWM_group02_INTR_SET</a></p>
</td>
<td><p>32'h00000124</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK">TCPWM_group02_INTR_MASK</a></p>
</td>
<td><p>32'h00000128</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.tc, when it is set, the counter interrupt<p></p>
will ignore the status of INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc0_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc1_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED">TCPWM_group02_INTR_MASKED</a></p>
</td>
<td><p>32'h0000012C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.tc and INTR_MASK.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc0_match and INTR_MASK.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc1_match and INTR_MASK.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME">TCPWM_group02_DEADTIME</a></p>
</td>
<td><p>32'h00000130</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_out">dt_line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In PWM_DT mode, this field is used to determine dead time before<p></p>
activating the PWM line output signal "line_out": amount of dead<p></p>
time cycles in the counter clock domain.<p></p>
In all other modes, the lower 3 bits of this field determine<p></p>
pre-scaling of the selected counter clock.<p></p>
0x0 : DIVBY1 : Divide by 1 (other-than-PWM_DT mode)<p></p>
0x1 : DIVBY2 : Divide by 2 (other-than-PWM_DT mode)<p></p>
0x2 : DIVBY4 : Divide by 4 (other-than-PWM_DT mode)<p></p>
0x3 : DIVBY8 : Divide by 8 (other-than-PWM_DT mode)<p></p>
0x4 : DIVBY16 : Divide by 16 (other-than-PWM_DT mode)<p></p>
0x5 : DIVBY32 : Divide by 32 (other-than-PWM_DT mode)<p></p>
0x6 : DIVBY64 : Divide by 64 (other-than-PWM_DT mode)<p></p>
0x7 : DIVBY128 : Divide by 128 (other-than-PWM_DT mode)</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_compl_out">dt_line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>in PWM_DT mode, this field is used to determine the dead time<p></p>
before activating the complementary PWM line output signal<p></p>
"line_compl_out": amount of dead time cycles in the counter<p></p>
clock domain.<p></p>
In all other modes, this field has no effect.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL">TCPWM_group02_SEMA_CTRL</a></p>
</td>
<td><p>32'h00000134</p>
</td>
<td><p>there are two semaphores (sema#0 and sema#1) per counter, they<p></p>
are used to synchronize counter operation and descriptor master<p></p>
cfg automation, selected counter signal will be used to set the<p></p>
corresponding semaphore, descriptor SYN command header info<p></p>
SYN.op, SYN.msk_grp and SYN.msk will choose how to unset<p></p>
(clear) semaphore.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema0_sel">sema0_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to set sema#0.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema1_sel">sema1_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to set sema#1.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b7">reserved_b7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS">TCPWM_group02_SEMA_STS</a></p>
</td>
<td><p>32'h00000138</p>
</td>
<td><p>used to indicate two semaphores bit status, both Hardware and<p></p>
Software can access: counter will set semaphore status when the<p></p>
event defined by SEMA_CTRL occurs, SYN descriptor execution with<p></p>
OP code 4’b10 also set semaphore status; semaphore status is<p></p>
cleared when SYN descriptor with OP code 4’b11 is performed;<p></p>
Software can set semaphore status when an early SYN descriptor<p></p>
termination is required, this is useful during debug process.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema0_val">sema0_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#0 status</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema1_val">sema1_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#1 status</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME">TCPWM_group02_DSHOT_FRAME</a></p>
</td>
<td><p>32'h0000013C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME_frame">frame</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT frame 16-bit value<p></p>
[10:0] 11-bit value for throttle command (0~2047)<p></p>
[11] 1-bit flag: 1 telemetry is requested from the drone ESC<p></p>
(Electronic Speed Controller); 0 otherwise<p></p>
[15:12] 4-bit checksum for error detection</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY">TCPWM_group02_DSHOT_DUTY</a></p>
</td>
<td><p>32'h00000140</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_high">high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 1 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “1”</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_low">low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 0 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “0”</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL">TCPWM_group03_CLK_CTRL</a></p>
</td>
<td><p>32'h00000144</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL_clkdiv_sel">clkdiv_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>All TCPWM counter clock (the counter clock before active event<p></p>
and prescaling) (including otrigClk used for counter output<p></p>
triggers) are generated by a group of clock dividers, the<p></p>
number of clock divider is controlled by design parameter<p></p>
CDIVNUM (which is set to 6 by default in design), the clock<p></p>
source for all clock dividers is periClk from SoC.<p></p>
This 4-bit field is used to select the one out of CDIVNUM clock<p></p>
dividers to provide the clock enable signal which is combined<p></p>
with active event and prescaling together to generate the<p></p>
counter’s operation clock in each of TCPWM counter. (otrigClk<p></p>
is only derived from clock divider)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL">TCPWM_group03_CTRL</a></p>
</td>
<td><p>32'h00000148</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc0">auto_reload_cc0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC0 and buffered CC0 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 0 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc1">auto_reload_cc1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC1 and buffered CC1 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 1 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_period">auto_reload_period</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the PERIOD and buffered PERIOD values.<p></p>
This field has a function in PWM and PWM_DT modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.<p></p>
In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to<p></p>
select the index / wrap-around capture function.<p></p>
'0': Captures on index (reload) event. The counter value is<p></p>
copied to the PERIOD register on an index (reload) event.<p></p>
'1': Captures when COUNTER equals 0 or 0xffff. The counter value<p></p>
is copied to the PERIOD register when COUNTER equals 0 or<p></p>
0xffff.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_line_sel">auto_reload_line_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values.<p></p>
This field has a function in PWM and PWM_PR modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_up_en">cc0_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting up<p></p>
'1': compare match 0 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_down_en">cc0_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 0 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_up_en">cc1_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting up<p></p>
'1': compare match 1 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_down_en">cc1_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 1 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_imm_kill">pwm_imm_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the kill event immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals or with the next module<p></p>
clock ("active count" pre-scaled counter clock).<p></p>
'0': synchronous kill activation. Deactivates the "line_out" and<p></p>
"line_compl_out" signals with the next module clock ("active<p></p>
count" pre-scaled counter clock).<p></p>
'1': immediate kill activation. Immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_stop_on_kill">pwm_stop_on_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the counter stops on a kill events:<p></p>
'0': kill event does NOT stop counter.<p></p>
'1': kill event stops counter.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_sync_kill">pwm_sync_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies asynchronous/synchronous kill release behavior:<p></p>
'1': synchronous kill mode: the kill event disables the<p></p>
"line_out" and "line_compl_out" signals till the next terminal<p></p>
count event (synchronous kill). In synchronous kill mode,<p></p>
STOP_EDGE should be NO_EDGE_DET.<p></p>
'0': asynchronous kill mode: the kill event only disables the<p></p>
"line_out" and "line_compl_out" signals when present. In<p></p>
asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET.<p></p>
This field has a function in PWM and PWM_DT modes only. This<p></p>
field is only used when PWM_STOP_ON_KILL is '0'.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b11">reserved_b11</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[13:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_disable_mode">pwm_disable_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the behavior of the PWM outputs "line_out" and<p></p>
"line_compl_out" while the TCPWM counter is disabled<p></p>
(CTL.ENABLED='0') or stopped.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the immediate kill logic and line_out polarity<p></p>
settings (CTRL.QUAD_ENCODING_MODE).<p></p>
0x0 : Z : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are NOT driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the TCPWM output "line_out_en"<p></p>
to 0.<p></p>
When the counter is stopped upon a stop event the PWM outputs<p></p>
are deactivated (to the polarity defined by<p></p>
CTRL.QUAD_ENCODING_MODE).<p></p>
0x1 : RETAIN : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM outputs are retained (keep their previous levels).<p></p>
While the counter is disabled or stopped the PWM outputs can be<p></p>
changed via LINE_SEL.<p></p>
0x2 : L : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '0' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '1'.<p></p>
0x3 : H : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '1' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '0'.</p>
</td>
</tr>
<tr><td><p>[15:14]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b14to15">reserved_b14to15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[17:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_up_down_mode">up_down_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Determines counter direction.<p></p>
In QUAD mode this field acts as QUAD_RANGE_MODE field selecting<p></p>
between different counter range, reload value and compare /<p></p>
capture behavior.<p></p>
0x0 : COUNT_UP : Count up (to PERIOD). An overflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals PERIOD. A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals PERIOD.<p></p>
0x0 : QUAD_RANGE0 : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0 mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- on reload / index event:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- tc and cc0_match events are generated<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- cc0_match event is generated<p></p>
0x1 : COUNT_DOWN : Count down (to "0"). An underflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x1 : QUAD_RANGE0_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0_CMP mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- the capture0 event acts as 2nd reload / index event<p></p>
- on reload / index event:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on index' is selected (AUTO_RELOAD_PERIOD=0):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER is copied to PERIOD<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on wrap-around' is selected<p></p>
(AUTO_RELOAD_PERIOD=1):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to PERIOD<p></p>
- 1 or 2 compare functions (depending on CC1_PRESENT) available<p></p>
Because of that the PERIOD/PERIOD_BUFF registers are used<p></p>
instead of CC0/CC_BUFF registers to capture COUNTER at reload /<p></p>
index event or wrap-around.<p></p>
0x2 : COUNT_UPDN1 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x2 : QUAD_RANGE1_CAPT : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CAPT mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and PERIOD<p></p>
- on reload / index event:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- when COUNTER is 0x0000 and decrementing:<p></p>
- COUNTER is set to PERIOD<p></p>
- tc event is generated<p></p>
- when COUNTER equals PERIOD and is incrementing:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- 1 or 2 capture functions (depending on CC1_PRESENT) available<p></p>
- on capture0 / capture1 event:<p></p>
- CC0 / CC1 is copied to CC0_BUFF / CC1_BUFF<p></p>
- COUNTER value is copied to CC0<p></p>
It allows that the COUNTER register reflects the current angle<p></p>
position of the rotary encoder, i.e. no MOD or SUB calculations<p></p>
need to be done in SW on the COUNTER value to get the current<p></p>
angle position. This allows a DMA copy of the angle position<p></p>
from the COUNTER register. However, a disadvantage of this mode<p></p>
is that fast sequences of tc interrupts can occur (when encoder<p></p>
moves back and forth around start position). It is recommended<p></p>
to not use the tc interrupt in this mode.<p></p>
0x3 : COUNT_UPDN2 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0"<p></p>
AND when the counter changes from a state in which COUNTER<p></p>
equals PERIOD (this counter direction can be used for PWM<p></p>
functionality with asymmetrical updates).<p></p>
0x3 : QUAD_RANGE1_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CMP mode.<p></p>
The behavior is the same as for QUAD_RANGE1_CAPT mode described<p></p>
above with the only difference that 1 or 2 compare functions<p></p>
(depending on CC1_PRESENT) are available instead of 1 or 2<p></p>
capture functions.</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_one_shot">one_shot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter runs continuous. When '1', counter is turned<p></p>
off by hardware when a terminal count event is generated.</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b19">reserved_b19</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[21:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_quad_encoding_mode">quad_encoding_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In QUAD mode this field selects the quadrature encoding mode<p></p>
(X1/X2/X4) or the Up / Down rotary counting mode.<p></p>
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to<p></p>
invert "line_out" and "line_compl_out". Inversion is the last<p></p>
step in generation of "line_out" and "line_compl_out"; i.e. a<p></p>
disabled output line "line_out" has the value<p></p>
QUAD_ENCODING_MODE[0] and a disabled output line<p></p>
"line_compl_out" has the value QUAD_ENCODING_MODE[1].<p></p>
0x0 : X1 : X1 encoding (QUAD mode)<p></p>
This encoding is identical with an up / down counting<p></p>
functionality of the following way: Rising edges of input phiA<p></p>
increment or decrement the counter depending on the state of<p></p>
input phiB (direction input).<p></p>
0x1 : X2 : X2 encoding (QUAD mode)<p></p>
0x1 : INV_OUT : When bit 0 is '1', QUADRATURE_ENCODING_MODE[0]<p></p>
inverts "line_out" (PWM/PWM_DT modes)<p></p>
0x2 : X4 : X4 encoding (QUAD mode)<p></p>
0x2 : INV_COMPL_OUT : When bit 1 is '1',<p></p>
QUADRATURE_ENCODING_MODE[1] inverts "line_compl_out"<p></p>
(PWM/PWM_DT modes)<p></p>
0x3 : UP_DOWN : Up / Down rotary counting mode. Input phiA<p></p>
increments the counter, input phiB decrements the counter. The<p></p>
trigger edge detection settings apply.</p>
</td>
</tr>
<tr><td><p>[23:22]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b22tob23">reserved_b22tob23</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_mode">mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter mode.<p></p>
0x0 : TIMER : Timer mode<p></p>
0x1 : EXT : Extension mode, which is defined in ext_mode[2:0]<p></p>
0x2 : CAPTURE : Capture mode<p></p>
0x3 : QUAD : Quadrature mode<p></p>
Different encoding modes can be selected by QUAD_ENCODING_MODE<p></p>
including up/down count functionality.<p></p>
Different counter range, reload value and capture behavior can<p></p>
be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).<p></p>
0x4 : PWM : Pulse width modulation (PWM) mode<p></p>
0x5 : PWM_DT : PWM with deadtime insertion mode<p></p>
0x6 : PWM_PR : Pseudo random pulse width modulation<p></p>
0x7 : SR : Shift register mode.</p>
</td>
</tr>
<tr><td><p>[29:27]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_ext_mode">ext_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>counter extension mode when mode[2:0] = 0x1<p></p>
0x0: DSHOT mode<p></p>
0x1~0x7: reserved</p>
</td>
</tr>
<tr><td><p>[30:30]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_dbg_freeze_en">dbg_freeze_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the counter behavior in debug mode.<p></p>
'0': The counter operation continues in debug mode.<p></p>
'1': The counter operation freezes in debug mode.</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_enabled">enabled</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter enable.<p></p>
'0': counter disabled.<p></p>
'1': counter enabled.<p></p>
Counter static configuration information (e.g. CTRL.mode, all<p></p>
TRIN_CTRL0/1, TRIN_EDGE_SEL, PWM_CTRL and TROUT_SEL register<p></p>
fields) should only be modified when the counter is disabled.<p></p>
When a counter is disabled, command and status information<p></p>
associated to the counter is cleared by HW, this includes:<p></p>
- the associated counter triggers in the CMD register are set to<p></p>
'0'.<p></p>
- the counter's interrupt cause fields in counter's INTR<p></p>
register.<p></p>
- the counter's status fields in counter's STATUS register..<p></p>
- the counter's trigger outputs ("tr_out0" and tr_out1").<p></p>
- the counter's line outputs ("line_out" and "line_compl_out").</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS">TCPWM_group03_STATUS</a></p>
</td>
<td><p>32'h0000014C</p>
</td>
<td><p>When the counter is disabled (CTRL.enabled = 0), then the<p></p>
STATUS.tr_* bit fields are typically reset to their default<p></p>
values. However, there are exceptions possible in the following<p></p>
cases, based on the selected input trigger via TRIN_SEL*.*_sel:<p></p>
- If a constant '0' is selected, then a '0' is read.<p></p>
- If a constant '1' is selected, then a '1' is read.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_down">down</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter is counting up. When '1', counter is counting<p></p>
down. In QUAD mode, this field indicates the direction of the<p></p>
latest counter change: '0' when last incremented and '1' when<p></p>
last decremented.</p>
</td>
</tr>
<tr><td><p>[3:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b1tob3">reserved_b1tob3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture0">tr_capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 0 trigger.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_count">tr_count</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Indicates the actual level of the selected count trigger.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_reload">tr_reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected reload trigger.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_stop">tr_stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected stop trigger.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_start">tr_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected start trigger.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture1">tr_capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_out">line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the PWM line output signal.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_compl_out">line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the complementary PWM line output<p></p>
signal</p>
</td>
</tr>
<tr><td><p>[14:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b12tob14">reserved_b12tob14</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_running">running</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', the counter is NOT running. When '1', the counter is<p></p>
running.<p></p>
This field is used to indicate that the counter is running after<p></p>
a start/reload event and that the counter is stopped after a<p></p>
stop event.<p></p>
When a running counter operation is paused in debug state (see<p></p>
CTRL.dbg_pause) then the RUNNING bit is still '1'.</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_dt_cnt">dt_cnt</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Generic 16-bit counter field. In PWM_DT mode, this counter is<p></p>
used for dead time insertion on PWM line_out<p></p>
In all other modes, this counter is used for pre-scaling the<p></p>
selected counter clock. PWM_DT mode can NOT use prescaled clock<p></p>
functionality.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0">TCPWM_group03_CC0</a></p>
</td>
<td><p>32'h00000150</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_cc0">cc0</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
1. SW reads this register when the counter is enabled<p></p>
(CTRL.enabled = 1) already; or<p></p>
2. SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1">TCPWM_group03_CC1</a></p>
</td>
<td><p>32'h00000154</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_cc1">cc1</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD">TCPWM_group03_PERIOD</a></p>
</td>
<td><p>32'h00000158</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_period">period</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>The maximum value the counter can reach. When the counter is<p></p>
designed to count for n cycles, this field should be set to<p></p>
n-1.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER">TCPWM_group03_COUNTER</a></p>
</td>
<td><p>32'h0000015C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER_val">val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>32-bit counter value. It is advised to not write to the this<p></p>
field when the counter is running.<p></p>
TCPWM counter can only be initialized by software in PWM_PR and<p></p>
SR mode.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL">TCPWM_group03_PWM_CTRL</a></p>
</td>
<td><p>32'h00000160</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc0_match_mode">cc0_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 0 event (COUNTER equals<p></p>
CC0 register) on the "line" output signals. Note that INVERT is<p></p>
especially useful for center aligned pulse width modulation.<p></p>
To generate a duty cycle of 0%, the counter CC0 register should<p></p>
be set to "0". For a 100% duty cycle, the counter CC0 register<p></p>
should be set to larger than the counter PERIOD register.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_overflow_mode">overflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter overflow event (COUNTER<p></p>
reaches PERIOD) on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_underflow_mode">underflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter underflow event (COUNTER<p></p>
reaches "0") on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc1_match_mode">cc1_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 1 event (COUNTER equals<p></p>
CC1 register) on the "line_out" output signals.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL">TCPWM_group03_LINE_SEL</a></p>
</td>
<td><p>32'h00000164</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects the source for the output signal "line_out". Default<p></p>
setting is the PWM signal "line". Other settings are useful for<p></p>
Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_out polarity setting<p></p>
(CTRL.quad_encoding_mode[0]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_out" is not driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the output "line_out_en" to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects the source for the output signal "line_compl_out".<p></p>
Default setting is the inverted PWM signal "line". Other<p></p>
settings are useful for Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_compl_out polarity<p></p>
setting (CTRL.quad_encoding_mode[1]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_compl_out" is not driven by the<p></p>
TCPWM. Instead the port default level configuration applies,<p></p>
e.g. "Z" (high impedance).<p></p>
Note: This is realized by driving the output "line_compl_out_en"<p></p>
to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF">TCPWM_group03_CC0_BUFF</a></p>
</td>
<td><p>32'h00000168</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF_cc0_buff">cc0_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC0 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF">TCPWM_group03_CC1_BUFF</a></p>
</td>
<td><p>32'h0000016C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF_cc1_buff">cc1_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC1 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF">TCPWM_group03_PERIOD_BUFF</a></p>
</td>
<td><p>32'h00000170</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF_period_buff">period_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter PERIOD register.<p></p>
In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit<p></p>
represents a tap of the shift register which can be feed back<p></p>
to the MSB of counter via an XOR tree.<p></p>
Examples for CNTWIDTH = 16:<p></p>
- Maximum length 16bit LFSR<p></p>
- polynomial x^16 + x^14 + x^13 + x^11 + 1<p></p>
- taps 0,2,3,5 - > PERIOD_BUFF = 0x002d<p></p>
- period is 2^16-1 = 65535 cycles<p></p>
- Maximum length 8bit LFSR:<p></p>
- polynomial x^8 + x^6 + x^5 + x^4 + 1<p></p>
- taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)<p></p>
- period is 2^8-1 = 255 cycles<p></p>
In SR mode PERIOD_BUFF defines which tap of the shift register<p></p>
generates the PWM output signals. For a delay of n cycles (from<p></p>
capture event to PWM output) the bit CNT_WIDTH-n should be set<p></p>
to '1'. For a shift register function only one tap should be<p></p>
use, i.e. a one-hot value must be written to PERIOD_BUFF. If<p></p>
multiple bits in PERIOD_BUFF are set then the taps are XOR<p></p>
combined.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF">TCPWM_group03_LINE_SEL_BUFF</a></p>
</td>
<td><p>32'h00000174</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Buffer for LINE_SEL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.out_sel on a terminal count event<p></p>
with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Buffer for LINE_SEL.COMPL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.compl_out_sel on a terminal count<p></p>
event with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0">TCPWM_group03_TRIN_CTRL0</a></p>
</td>
<td><p>32'h00000178</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_capture0_sel">capture0_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the up to 256 input triggers as a capture0<p></p>
trigger. Input trigger 0 is always '0' and input trigger 1 is<p></p>
always '1'.<p></p>
In the PWM, PWM_DT and PWM_PR modes this trigger is used to<p></p>
switch the values of the compare and period registers with<p></p>
their buffer counterparts.</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_count_sel">count_sel</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Selects one of the 256 input triggers as a count trigger.<p></p>
In QUAD mode, this is the first phase (phi A). Default setting<p></p>
selects input trigger 1, which is always '1'.<p></p>
Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the<p></p>
counter is externally triggered ( COUNT_SEL > 1), an external<p></p>
trigger will be required for each TR_CMD to execute. For<p></p>
example, a write to TR_CMD.START will not start the counter<p></p>
until the trigger selected by COUNT_SEL asserts. The next<p></p>
trigger will increment the counter since the counter is now<p></p>
running. This goes for all TR_CMD fields.</p>
</td>
</tr>
<tr><td><p>[23:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_reload_sel">reload_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a reload trigger.<p></p>
In QUAD mode, this is the index or revolution pulse. In these<p></p>
modes, it will update the counter with 0x8000 (counter<p></p>
midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</p>
</td>
</tr>
<tr><td><p>[31:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_stop_sel">stop_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a stop trigger.<p></p>
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In<p></p>
these modes, the kill trigger is used to either temporarily<p></p>
block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the<p></p>
functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT<p></p>
modes, the blocking of the output signals can be asynchronous<p></p>
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is<p></p>
as long as the trigger is '1' or synchronous (STOP_EDGE should<p></p>
be RISING_EDGE) in which case it extends till the next terminal<p></p>
count event.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1">TCPWM_group03_TRIN_CTRL1</a></p>
</td>
<td><p>32'h0000017C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_sel">start_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a start trigger. In<p></p>
QUAD mode, this is the second phase (phi B).</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_sel">capture1_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture0_inv">capture0_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture0 will be inverted before counter usage.</p>
</td>
</tr>
<tr><td><p>[17:17]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_count_inv">count_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger count will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_reload_inv">reload_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger reload will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_stop_inv">stop_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger stop will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[20:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_inv">start_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger start will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[21:21]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_inv">capture1_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture1 will be inverted before counter usage</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL">TCPWM_group03_TRIN_EDGE_SEL</a></p>
</td>
<td><p>32'h00000180</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture0_edge">capture0_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_count_edge">count_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_reload_edge">reload_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_stop_edge">stop_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_start_edge">start_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[11:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture1_edge">capture1_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL">TCPWM_group03_TROUT_SEL</a></p>
</td>
<td><p>32'h00000184</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out0">out0</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 0. Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH: Compare match 0 event<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7: Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_3">reserved_3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out1">out1</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 1. Default setting selects the compare match 0 event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event<p></p>
0x3 : CC0_MATCH: Compare match 0 event (default selection)<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7 : Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_7">reserved_7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD">TCPWM_group03_TR_CMD</a></p>
</td>
<td><p>32'h00000188</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture0">capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture 0 trigger. When written with '1', a capture 0 trigger<p></p>
is generated and the HW sets the field to '0' when the SW<p></p>
trigger has taken effect. It should be noted that the HW<p></p>
operates on the counter frequency. If the counter is disabled<p></p>
through CTRL.ENABLED, the field is immediately set to '0'.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reserved_1">reserved_1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reload">reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW reload trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_stop">stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW stop trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW start trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture1">capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture1 trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(WOC-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA">TCPWM_group03_INTR_STA</a></p>
</td>
<td><p>32'h0000018C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when a terminal count or DSHOT done is detected, write<p></p>
‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare0 (CC0)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare1 (CC1)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(W-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET">TCPWM_group03_INTR_SET</a></p>
</td>
<td><p>32'h00000190</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK">TCPWM_group03_INTR_MASK</a></p>
</td>
<td><p>32'h00000194</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.tc, when it is set, the counter interrupt<p></p>
will ignore the status of INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc0_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc1_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED">TCPWM_group03_INTR_MASKED</a></p>
</td>
<td><p>32'h00000198</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.tc and INTR_MASK.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc0_match and INTR_MASK.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc1_match and INTR_MASK.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME">TCPWM_group03_DEADTIME</a></p>
</td>
<td><p>32'h0000019C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_out">dt_line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In PWM_DT mode, this field is used to determine dead time before<p></p>
activating the PWM line output signal "line_out": amount of dead<p></p>
time cycles in the counter clock domain.<p></p>
In all other modes, the lower 3 bits of this field determine<p></p>
pre-scaling of the selected counter clock.<p></p>
0x0 : DIVBY1 : Divide by 1 (other-than-PWM_DT mode)<p></p>
0x1 : DIVBY2 : Divide by 2 (other-than-PWM_DT mode)<p></p>
0x2 : DIVBY4 : Divide by 4 (other-than-PWM_DT mode)<p></p>
0x3 : DIVBY8 : Divide by 8 (other-than-PWM_DT mode)<p></p>
0x4 : DIVBY16 : Divide by 16 (other-than-PWM_DT mode)<p></p>
0x5 : DIVBY32 : Divide by 32 (other-than-PWM_DT mode)<p></p>
0x6 : DIVBY64 : Divide by 64 (other-than-PWM_DT mode)<p></p>
0x7 : DIVBY128 : Divide by 128 (other-than-PWM_DT mode)</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_compl_out">dt_line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>in PWM_DT mode, this field is used to determine the dead time<p></p>
before activating the complementary PWM line output signal<p></p>
"line_compl_out": amount of dead time cycles in the counter<p></p>
clock domain.<p></p>
In all other modes, this field has no effect.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL">TCPWM_group03_SEMA_CTRL</a></p>
</td>
<td><p>32'h000001A0</p>
</td>
<td><p>there are two semaphores (sema#0 and sema#1) per counter, they<p></p>
are used to synchronize counter operation and descriptor master<p></p>
cfg automation, selected counter signal will be used to set the<p></p>
corresponding semaphore, descriptor SYN command header info<p></p>
SYN.op, SYN.msk_grp and SYN.msk will choose how to unset<p></p>
(clear) semaphore.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema0_sel">sema0_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to set sema#0.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema1_sel">sema1_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to set sema#1.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b7">reserved_b7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS">TCPWM_group03_SEMA_STS</a></p>
</td>
<td><p>32'h000001A4</p>
</td>
<td><p>used to indicate two semaphores bit status, both Hardware and<p></p>
Software can access: counter will set semaphore status when the<p></p>
event defined by SEMA_CTRL occurs, SYN descriptor execution with<p></p>
OP code 4’b10 also set semaphore status; semaphore status is<p></p>
cleared when SYN descriptor with OP code 4’b11 is performed;<p></p>
Software can set semaphore status when an early SYN descriptor<p></p>
termination is required, this is useful during debug process.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema0_val">sema0_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#0 status</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema1_val">sema1_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#1 status</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME">TCPWM_group03_DSHOT_FRAME</a></p>
</td>
<td><p>32'h000001A8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME_frame">frame</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT frame 16-bit value<p></p>
[10:0] 11-bit value for throttle command (0~2047)<p></p>
[11] 1-bit flag: 1 telemetry is requested from the drone ESC<p></p>
(Electronic Speed Controller); 0 otherwise<p></p>
[15:12] 4-bit checksum for error detection</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY">TCPWM_group03_DSHOT_DUTY</a></p>
</td>
<td><p>32'h000001AC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_high">high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 1 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “1”</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_low">low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 0 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “0”</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL">TCPWM_group04_CLK_CTRL</a></p>
</td>
<td><p>32'h000001B0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL_clkdiv_sel">clkdiv_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>All TCPWM counter clock (the counter clock before active event<p></p>
and prescaling) (including otrigClk used for counter output<p></p>
triggers) are generated by a group of clock dividers, the<p></p>
number of clock divider is controlled by design parameter<p></p>
CDIVNUM (which is set to 6 by default in design), the clock<p></p>
source for all clock dividers is periClk from SoC.<p></p>
This 4-bit field is used to select the one out of CDIVNUM clock<p></p>
dividers to provide the clock enable signal which is combined<p></p>
with active event and prescaling together to generate the<p></p>
counter’s operation clock in each of TCPWM counter. (otrigClk<p></p>
is only derived from clock divider)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL">TCPWM_group04_CTRL</a></p>
</td>
<td><p>32'h000001B4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc0">auto_reload_cc0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC0 and buffered CC0 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 0 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc1">auto_reload_cc1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC1 and buffered CC1 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 1 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_period">auto_reload_period</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the PERIOD and buffered PERIOD values.<p></p>
This field has a function in PWM and PWM_DT modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.<p></p>
In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to<p></p>
select the index / wrap-around capture function.<p></p>
'0': Captures on index (reload) event. The counter value is<p></p>
copied to the PERIOD register on an index (reload) event.<p></p>
'1': Captures when COUNTER equals 0 or 0xffff. The counter value<p></p>
is copied to the PERIOD register when COUNTER equals 0 or<p></p>
0xffff.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_line_sel">auto_reload_line_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values.<p></p>
This field has a function in PWM and PWM_PR modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_up_en">cc0_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting up<p></p>
'1': compare match 0 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_down_en">cc0_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 0 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_up_en">cc1_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting up<p></p>
'1': compare match 1 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_down_en">cc1_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 1 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_imm_kill">pwm_imm_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the kill event immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals or with the next module<p></p>
clock ("active count" pre-scaled counter clock).<p></p>
'0': synchronous kill activation. Deactivates the "line_out" and<p></p>
"line_compl_out" signals with the next module clock ("active<p></p>
count" pre-scaled counter clock).<p></p>
'1': immediate kill activation. Immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_stop_on_kill">pwm_stop_on_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the counter stops on a kill events:<p></p>
'0': kill event does NOT stop counter.<p></p>
'1': kill event stops counter.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_sync_kill">pwm_sync_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies asynchronous/synchronous kill release behavior:<p></p>
'1': synchronous kill mode: the kill event disables the<p></p>
"line_out" and "line_compl_out" signals till the next terminal<p></p>
count event (synchronous kill). In synchronous kill mode,<p></p>
STOP_EDGE should be NO_EDGE_DET.<p></p>
'0': asynchronous kill mode: the kill event only disables the<p></p>
"line_out" and "line_compl_out" signals when present. In<p></p>
asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET.<p></p>
This field has a function in PWM and PWM_DT modes only. This<p></p>
field is only used when PWM_STOP_ON_KILL is '0'.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b11">reserved_b11</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[13:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_disable_mode">pwm_disable_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the behavior of the PWM outputs "line_out" and<p></p>
"line_compl_out" while the TCPWM counter is disabled<p></p>
(CTL.ENABLED='0') or stopped.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the immediate kill logic and line_out polarity<p></p>
settings (CTRL.QUAD_ENCODING_MODE).<p></p>
0x0 : Z : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are NOT driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the TCPWM output "line_out_en"<p></p>
to 0.<p></p>
When the counter is stopped upon a stop event the PWM outputs<p></p>
are deactivated (to the polarity defined by<p></p>
CTRL.QUAD_ENCODING_MODE).<p></p>
0x1 : RETAIN : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM outputs are retained (keep their previous levels).<p></p>
While the counter is disabled or stopped the PWM outputs can be<p></p>
changed via LINE_SEL.<p></p>
0x2 : L : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '0' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '1'.<p></p>
0x3 : H : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '1' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '0'.</p>
</td>
</tr>
<tr><td><p>[15:14]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b14to15">reserved_b14to15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[17:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_up_down_mode">up_down_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Determines counter direction.<p></p>
In QUAD mode this field acts as QUAD_RANGE_MODE field selecting<p></p>
between different counter range, reload value and compare /<p></p>
capture behavior.<p></p>
0x0 : COUNT_UP : Count up (to PERIOD). An overflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals PERIOD. A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals PERIOD.<p></p>
0x0 : QUAD_RANGE0 : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0 mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- on reload / index event:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- tc and cc0_match events are generated<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- cc0_match event is generated<p></p>
0x1 : COUNT_DOWN : Count down (to "0"). An underflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x1 : QUAD_RANGE0_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0_CMP mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- the capture0 event acts as 2nd reload / index event<p></p>
- on reload / index event:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on index' is selected (AUTO_RELOAD_PERIOD=0):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER is copied to PERIOD<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on wrap-around' is selected<p></p>
(AUTO_RELOAD_PERIOD=1):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to PERIOD<p></p>
- 1 or 2 compare functions (depending on CC1_PRESENT) available<p></p>
Because of that the PERIOD/PERIOD_BUFF registers are used<p></p>
instead of CC0/CC_BUFF registers to capture COUNTER at reload /<p></p>
index event or wrap-around.<p></p>
0x2 : COUNT_UPDN1 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x2 : QUAD_RANGE1_CAPT : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CAPT mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and PERIOD<p></p>
- on reload / index event:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- when COUNTER is 0x0000 and decrementing:<p></p>
- COUNTER is set to PERIOD<p></p>
- tc event is generated<p></p>
- when COUNTER equals PERIOD and is incrementing:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- 1 or 2 capture functions (depending on CC1_PRESENT) available<p></p>
- on capture0 / capture1 event:<p></p>
- CC0 / CC1 is copied to CC0_BUFF / CC1_BUFF<p></p>
- COUNTER value is copied to CC0<p></p>
It allows that the COUNTER register reflects the current angle<p></p>
position of the rotary encoder, i.e. no MOD or SUB calculations<p></p>
need to be done in SW on the COUNTER value to get the current<p></p>
angle position. This allows a DMA copy of the angle position<p></p>
from the COUNTER register. However, a disadvantage of this mode<p></p>
is that fast sequences of tc interrupts can occur (when encoder<p></p>
moves back and forth around start position). It is recommended<p></p>
to not use the tc interrupt in this mode.<p></p>
0x3 : COUNT_UPDN2 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0"<p></p>
AND when the counter changes from a state in which COUNTER<p></p>
equals PERIOD (this counter direction can be used for PWM<p></p>
functionality with asymmetrical updates).<p></p>
0x3 : QUAD_RANGE1_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CMP mode.<p></p>
The behavior is the same as for QUAD_RANGE1_CAPT mode described<p></p>
above with the only difference that 1 or 2 compare functions<p></p>
(depending on CC1_PRESENT) are available instead of 1 or 2<p></p>
capture functions.</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_one_shot">one_shot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter runs continuous. When '1', counter is turned<p></p>
off by hardware when a terminal count event is generated.</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b19">reserved_b19</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[21:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_quad_encoding_mode">quad_encoding_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In QUAD mode this field selects the quadrature encoding mode<p></p>
(X1/X2/X4) or the Up / Down rotary counting mode.<p></p>
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to<p></p>
invert "line_out" and "line_compl_out". Inversion is the last<p></p>
step in generation of "line_out" and "line_compl_out"; i.e. a<p></p>
disabled output line "line_out" has the value<p></p>
QUAD_ENCODING_MODE[0] and a disabled output line<p></p>
"line_compl_out" has the value QUAD_ENCODING_MODE[1].<p></p>
0x0 : X1 : X1 encoding (QUAD mode)<p></p>
This encoding is identical with an up / down counting<p></p>
functionality of the following way: Rising edges of input phiA<p></p>
increment or decrement the counter depending on the state of<p></p>
input phiB (direction input).<p></p>
0x1 : X2 : X2 encoding (QUAD mode)<p></p>
0x1 : INV_OUT : When bit 0 is '1', QUADRATURE_ENCODING_MODE[0]<p></p>
inverts "line_out" (PWM/PWM_DT modes)<p></p>
0x2 : X4 : X4 encoding (QUAD mode)<p></p>
0x2 : INV_COMPL_OUT : When bit 1 is '1',<p></p>
QUADRATURE_ENCODING_MODE[1] inverts "line_compl_out"<p></p>
(PWM/PWM_DT modes)<p></p>
0x3 : UP_DOWN : Up / Down rotary counting mode. Input phiA<p></p>
increments the counter, input phiB decrements the counter. The<p></p>
trigger edge detection settings apply.</p>
</td>
</tr>
<tr><td><p>[23:22]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b22tob23">reserved_b22tob23</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_mode">mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter mode.<p></p>
0x0 : TIMER : Timer mode<p></p>
0x1 : EXT : Extension mode, which is defined in ext_mode[2:0]<p></p>
0x2 : CAPTURE : Capture mode<p></p>
0x3 : QUAD : Quadrature mode<p></p>
Different encoding modes can be selected by QUAD_ENCODING_MODE<p></p>
including up/down count functionality.<p></p>
Different counter range, reload value and capture behavior can<p></p>
be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).<p></p>
0x4 : PWM : Pulse width modulation (PWM) mode<p></p>
0x5 : PWM_DT : PWM with deadtime insertion mode<p></p>
0x6 : PWM_PR : Pseudo random pulse width modulation<p></p>
0x7 : SR : Shift register mode.</p>
</td>
</tr>
<tr><td><p>[29:27]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_ext_mode">ext_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>counter extension mode when mode[2:0] = 0x1<p></p>
0x0: DSHOT mode<p></p>
0x1~0x7: reserved</p>
</td>
</tr>
<tr><td><p>[30:30]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_dbg_freeze_en">dbg_freeze_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the counter behavior in debug mode.<p></p>
'0': The counter operation continues in debug mode.<p></p>
'1': The counter operation freezes in debug mode.</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_enabled">enabled</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter enable.<p></p>
'0': counter disabled.<p></p>
'1': counter enabled.<p></p>
Counter static configuration information (e.g. CTRL.mode, all<p></p>
TRIN_CTRL0/1, TRIN_EDGE_SEL, PWM_CTRL and TROUT_SEL register<p></p>
fields) should only be modified when the counter is disabled.<p></p>
When a counter is disabled, command and status information<p></p>
associated to the counter is cleared by HW, this includes:<p></p>
- the associated counter triggers in the CMD register are set to<p></p>
'0'.<p></p>
- the counter's interrupt cause fields in counter's INTR<p></p>
register.<p></p>
- the counter's status fields in counter's STATUS register..<p></p>
- the counter's trigger outputs ("tr_out0" and tr_out1").<p></p>
- the counter's line outputs ("line_out" and "line_compl_out").</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS">TCPWM_group04_STATUS</a></p>
</td>
<td><p>32'h000001B8</p>
</td>
<td><p>When the counter is disabled (CTRL.enabled = 0), then the<p></p>
STATUS.tr_* bit fields are typically reset to their default<p></p>
values. However, there are exceptions possible in the following<p></p>
cases, based on the selected input trigger via TRIN_SEL*.*_sel:<p></p>
- If a constant '0' is selected, then a '0' is read.<p></p>
- If a constant '1' is selected, then a '1' is read.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_down">down</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter is counting up. When '1', counter is counting<p></p>
down. In QUAD mode, this field indicates the direction of the<p></p>
latest counter change: '0' when last incremented and '1' when<p></p>
last decremented.</p>
</td>
</tr>
<tr><td><p>[3:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b1tob3">reserved_b1tob3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture0">tr_capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 0 trigger.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_count">tr_count</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Indicates the actual level of the selected count trigger.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_reload">tr_reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected reload trigger.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_stop">tr_stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected stop trigger.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_start">tr_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected start trigger.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture1">tr_capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_out">line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the PWM line output signal.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_compl_out">line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the complementary PWM line output<p></p>
signal</p>
</td>
</tr>
<tr><td><p>[14:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b12tob14">reserved_b12tob14</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_running">running</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', the counter is NOT running. When '1', the counter is<p></p>
running.<p></p>
This field is used to indicate that the counter is running after<p></p>
a start/reload event and that the counter is stopped after a<p></p>
stop event.<p></p>
When a running counter operation is paused in debug state (see<p></p>
CTRL.dbg_pause) then the RUNNING bit is still '1'.</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_dt_cnt">dt_cnt</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Generic 16-bit counter field. In PWM_DT mode, this counter is<p></p>
used for dead time insertion on PWM line_out<p></p>
In all other modes, this counter is used for pre-scaling the<p></p>
selected counter clock. PWM_DT mode can NOT use prescaled clock<p></p>
functionality.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0">TCPWM_group04_CC0</a></p>
</td>
<td><p>32'h000001BC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_cc0">cc0</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
1. SW reads this register when the counter is enabled<p></p>
(CTRL.enabled = 1) already; or<p></p>
2. SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1">TCPWM_group04_CC1</a></p>
</td>
<td><p>32'h000001C0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_cc1">cc1</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD">TCPWM_group04_PERIOD</a></p>
</td>
<td><p>32'h000001C4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_period">period</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>The maximum value the counter can reach. When the counter is<p></p>
designed to count for n cycles, this field should be set to<p></p>
n-1.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER">TCPWM_group04_COUNTER</a></p>
</td>
<td><p>32'h000001C8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER_val">val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>32-bit counter value. It is advised to not write to the this<p></p>
field when the counter is running.<p></p>
TCPWM counter can only be initialized by software in PWM_PR and<p></p>
SR mode.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL">TCPWM_group04_PWM_CTRL</a></p>
</td>
<td><p>32'h000001CC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc0_match_mode">cc0_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 0 event (COUNTER equals<p></p>
CC0 register) on the "line" output signals. Note that INVERT is<p></p>
especially useful for center aligned pulse width modulation.<p></p>
To generate a duty cycle of 0%, the counter CC0 register should<p></p>
be set to "0". For a 100% duty cycle, the counter CC0 register<p></p>
should be set to larger than the counter PERIOD register.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_overflow_mode">overflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter overflow event (COUNTER<p></p>
reaches PERIOD) on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_underflow_mode">underflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter underflow event (COUNTER<p></p>
reaches "0") on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc1_match_mode">cc1_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 1 event (COUNTER equals<p></p>
CC1 register) on the "line_out" output signals.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL">TCPWM_group04_LINE_SEL</a></p>
</td>
<td><p>32'h000001D0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects the source for the output signal "line_out". Default<p></p>
setting is the PWM signal "line". Other settings are useful for<p></p>
Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_out polarity setting<p></p>
(CTRL.quad_encoding_mode[0]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_out" is not driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the output "line_out_en" to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects the source for the output signal "line_compl_out".<p></p>
Default setting is the inverted PWM signal "line". Other<p></p>
settings are useful for Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_compl_out polarity<p></p>
setting (CTRL.quad_encoding_mode[1]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_compl_out" is not driven by the<p></p>
TCPWM. Instead the port default level configuration applies,<p></p>
e.g. "Z" (high impedance).<p></p>
Note: This is realized by driving the output "line_compl_out_en"<p></p>
to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF">TCPWM_group04_CC0_BUFF</a></p>
</td>
<td><p>32'h000001D4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF_cc0_buff">cc0_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC0 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF">TCPWM_group04_CC1_BUFF</a></p>
</td>
<td><p>32'h000001D8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF_cc1_buff">cc1_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC1 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF">TCPWM_group04_PERIOD_BUFF</a></p>
</td>
<td><p>32'h000001DC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF_period_buff">period_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter PERIOD register.<p></p>
In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit<p></p>
represents a tap of the shift register which can be feed back<p></p>
to the MSB of counter via an XOR tree.<p></p>
Examples for CNTWIDTH = 16:<p></p>
- Maximum length 16bit LFSR<p></p>
- polynomial x^16 + x^14 + x^13 + x^11 + 1<p></p>
- taps 0,2,3,5 - > PERIOD_BUFF = 0x002d<p></p>
- period is 2^16-1 = 65535 cycles<p></p>
- Maximum length 8bit LFSR:<p></p>
- polynomial x^8 + x^6 + x^5 + x^4 + 1<p></p>
- taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)<p></p>
- period is 2^8-1 = 255 cycles<p></p>
In SR mode PERIOD_BUFF defines which tap of the shift register<p></p>
generates the PWM output signals. For a delay of n cycles (from<p></p>
capture event to PWM output) the bit CNT_WIDTH-n should be set<p></p>
to '1'. For a shift register function only one tap should be<p></p>
use, i.e. a one-hot value must be written to PERIOD_BUFF. If<p></p>
multiple bits in PERIOD_BUFF are set then the taps are XOR<p></p>
combined.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF">TCPWM_group04_LINE_SEL_BUFF</a></p>
</td>
<td><p>32'h000001E0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Buffer for LINE_SEL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.out_sel on a terminal count event<p></p>
with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Buffer for LINE_SEL.COMPL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.compl_out_sel on a terminal count<p></p>
event with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0">TCPWM_group04_TRIN_CTRL0</a></p>
</td>
<td><p>32'h000001E4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_capture0_sel">capture0_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the up to 256 input triggers as a capture0<p></p>
trigger. Input trigger 0 is always '0' and input trigger 1 is<p></p>
always '1'.<p></p>
In the PWM, PWM_DT and PWM_PR modes this trigger is used to<p></p>
switch the values of the compare and period registers with<p></p>
their buffer counterparts.</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_count_sel">count_sel</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Selects one of the 256 input triggers as a count trigger.<p></p>
In QUAD mode, this is the first phase (phi A). Default setting<p></p>
selects input trigger 1, which is always '1'.<p></p>
Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the<p></p>
counter is externally triggered ( COUNT_SEL > 1), an external<p></p>
trigger will be required for each TR_CMD to execute. For<p></p>
example, a write to TR_CMD.START will not start the counter<p></p>
until the trigger selected by COUNT_SEL asserts. The next<p></p>
trigger will increment the counter since the counter is now<p></p>
running. This goes for all TR_CMD fields.</p>
</td>
</tr>
<tr><td><p>[23:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_reload_sel">reload_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a reload trigger.<p></p>
In QUAD mode, this is the index or revolution pulse. In these<p></p>
modes, it will update the counter with 0x8000 (counter<p></p>
midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</p>
</td>
</tr>
<tr><td><p>[31:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_stop_sel">stop_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a stop trigger.<p></p>
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In<p></p>
these modes, the kill trigger is used to either temporarily<p></p>
block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the<p></p>
functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT<p></p>
modes, the blocking of the output signals can be asynchronous<p></p>
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is<p></p>
as long as the trigger is '1' or synchronous (STOP_EDGE should<p></p>
be RISING_EDGE) in which case it extends till the next terminal<p></p>
count event.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1">TCPWM_group04_TRIN_CTRL1</a></p>
</td>
<td><p>32'h000001E8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_sel">start_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a start trigger. In<p></p>
QUAD mode, this is the second phase (phi B).</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_sel">capture1_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture0_inv">capture0_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture0 will be inverted before counter usage.</p>
</td>
</tr>
<tr><td><p>[17:17]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_count_inv">count_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger count will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_reload_inv">reload_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger reload will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_stop_inv">stop_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger stop will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[20:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_inv">start_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger start will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[21:21]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_inv">capture1_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture1 will be inverted before counter usage</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL">TCPWM_group04_TRIN_EDGE_SEL</a></p>
</td>
<td><p>32'h000001EC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture0_edge">capture0_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_count_edge">count_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_reload_edge">reload_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_stop_edge">stop_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_start_edge">start_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[11:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture1_edge">capture1_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL">TCPWM_group04_TROUT_SEL</a></p>
</td>
<td><p>32'h000001F0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out0">out0</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 0. Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH: Compare match 0 event<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7: Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_3">reserved_3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out1">out1</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 1. Default setting selects the compare match 0 event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event<p></p>
0x3 : CC0_MATCH: Compare match 0 event (default selection)<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7 : Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_7">reserved_7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD">TCPWM_group04_TR_CMD</a></p>
</td>
<td><p>32'h000001F4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture0">capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture 0 trigger. When written with '1', a capture 0 trigger<p></p>
is generated and the HW sets the field to '0' when the SW<p></p>
trigger has taken effect. It should be noted that the HW<p></p>
operates on the counter frequency. If the counter is disabled<p></p>
through CTRL.ENABLED, the field is immediately set to '0'.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reserved_1">reserved_1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reload">reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW reload trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_stop">stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW stop trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW start trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture1">capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture1 trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(WOC-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA">TCPWM_group04_INTR_STA</a></p>
</td>
<td><p>32'h000001F8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when a terminal count or DSHOT done is detected, write<p></p>
‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare0 (CC0)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare1 (CC1)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(W-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET">TCPWM_group04_INTR_SET</a></p>
</td>
<td><p>32'h000001FC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK">TCPWM_group04_INTR_MASK</a></p>
</td>
<td><p>32'h00000200</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.tc, when it is set, the counter interrupt<p></p>
will ignore the status of INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc0_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc1_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED">TCPWM_group04_INTR_MASKED</a></p>
</td>
<td><p>32'h00000204</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.tc and INTR_MASK.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc0_match and INTR_MASK.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc1_match and INTR_MASK.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME">TCPWM_group04_DEADTIME</a></p>
</td>
<td><p>32'h00000208</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_out">dt_line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In PWM_DT mode, this field is used to determine dead time before<p></p>
activating the PWM line output signal "line_out": amount of dead<p></p>
time cycles in the counter clock domain.<p></p>
In all other modes, the lower 3 bits of this field determine<p></p>
pre-scaling of the selected counter clock.<p></p>
0x0 : DIVBY1 : Divide by 1 (other-than-PWM_DT mode)<p></p>
0x1 : DIVBY2 : Divide by 2 (other-than-PWM_DT mode)<p></p>
0x2 : DIVBY4 : Divide by 4 (other-than-PWM_DT mode)<p></p>
0x3 : DIVBY8 : Divide by 8 (other-than-PWM_DT mode)<p></p>
0x4 : DIVBY16 : Divide by 16 (other-than-PWM_DT mode)<p></p>
0x5 : DIVBY32 : Divide by 32 (other-than-PWM_DT mode)<p></p>
0x6 : DIVBY64 : Divide by 64 (other-than-PWM_DT mode)<p></p>
0x7 : DIVBY128 : Divide by 128 (other-than-PWM_DT mode)</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_compl_out">dt_line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>in PWM_DT mode, this field is used to determine the dead time<p></p>
before activating the complementary PWM line output signal<p></p>
"line_compl_out": amount of dead time cycles in the counter<p></p>
clock domain.<p></p>
In all other modes, this field has no effect.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL">TCPWM_group04_SEMA_CTRL</a></p>
</td>
<td><p>32'h0000020C</p>
</td>
<td><p>there are two semaphores (sema#0 and sema#1) per counter, they<p></p>
are used to synchronize counter operation and descriptor master<p></p>
cfg automation, selected counter signal will be used to set the<p></p>
corresponding semaphore, descriptor SYN command header info<p></p>
SYN.op, SYN.msk_grp and SYN.msk will choose how to unset<p></p>
(clear) semaphore.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema0_sel">sema0_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to set sema#0.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema1_sel">sema1_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to set sema#1.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b7">reserved_b7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS">TCPWM_group04_SEMA_STS</a></p>
</td>
<td><p>32'h00000210</p>
</td>
<td><p>used to indicate two semaphores bit status, both Hardware and<p></p>
Software can access: counter will set semaphore status when the<p></p>
event defined by SEMA_CTRL occurs, SYN descriptor execution with<p></p>
OP code 4’b10 also set semaphore status; semaphore status is<p></p>
cleared when SYN descriptor with OP code 4’b11 is performed;<p></p>
Software can set semaphore status when an early SYN descriptor<p></p>
termination is required, this is useful during debug process.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema0_val">sema0_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#0 status</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema1_val">sema1_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#1 status</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME">TCPWM_group04_DSHOT_FRAME</a></p>
</td>
<td><p>32'h00000214</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME_frame">frame</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT frame 16-bit value<p></p>
[10:0] 11-bit value for throttle command (0~2047)<p></p>
[11] 1-bit flag: 1 telemetry is requested from the drone ESC<p></p>
(Electronic Speed Controller); 0 otherwise<p></p>
[15:12] 4-bit checksum for error detection</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY">TCPWM_group04_DSHOT_DUTY</a></p>
</td>
<td><p>32'h00000218</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_high">high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 1 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “1”</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_low">low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 0 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “0”</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL">TCPWM_group05_CLK_CTRL</a></p>
</td>
<td><p>32'h0000021C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL_clkdiv_sel">clkdiv_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>All TCPWM counter clock (the counter clock before active event<p></p>
and prescaling) (including otrigClk used for counter output<p></p>
triggers) are generated by a group of clock dividers, the<p></p>
number of clock divider is controlled by design parameter<p></p>
CDIVNUM (which is set to 6 by default in design), the clock<p></p>
source for all clock dividers is periClk from SoC.<p></p>
This 4-bit field is used to select the one out of CDIVNUM clock<p></p>
dividers to provide the clock enable signal which is combined<p></p>
with active event and prescaling together to generate the<p></p>
counter’s operation clock in each of TCPWM counter. (otrigClk<p></p>
is only derived from clock divider)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL">TCPWM_group05_CTRL</a></p>
</td>
<td><p>32'h00000220</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc0">auto_reload_cc0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC0 and buffered CC0 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 0 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc1">auto_reload_cc1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC1 and buffered CC1 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 1 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_period">auto_reload_period</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the PERIOD and buffered PERIOD values.<p></p>
This field has a function in PWM and PWM_DT modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.<p></p>
In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to<p></p>
select the index / wrap-around capture function.<p></p>
'0': Captures on index (reload) event. The counter value is<p></p>
copied to the PERIOD register on an index (reload) event.<p></p>
'1': Captures when COUNTER equals 0 or 0xffff. The counter value<p></p>
is copied to the PERIOD register when COUNTER equals 0 or<p></p>
0xffff.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_line_sel">auto_reload_line_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values.<p></p>
This field has a function in PWM and PWM_PR modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_up_en">cc0_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting up<p></p>
'1': compare match 0 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_down_en">cc0_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 0 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_up_en">cc1_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting up<p></p>
'1': compare match 1 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_down_en">cc1_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 1 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_imm_kill">pwm_imm_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the kill event immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals or with the next module<p></p>
clock ("active count" pre-scaled counter clock).<p></p>
'0': synchronous kill activation. Deactivates the "line_out" and<p></p>
"line_compl_out" signals with the next module clock ("active<p></p>
count" pre-scaled counter clock).<p></p>
'1': immediate kill activation. Immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_stop_on_kill">pwm_stop_on_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the counter stops on a kill events:<p></p>
'0': kill event does NOT stop counter.<p></p>
'1': kill event stops counter.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_sync_kill">pwm_sync_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies asynchronous/synchronous kill release behavior:<p></p>
'1': synchronous kill mode: the kill event disables the<p></p>
"line_out" and "line_compl_out" signals till the next terminal<p></p>
count event (synchronous kill). In synchronous kill mode,<p></p>
STOP_EDGE should be NO_EDGE_DET.<p></p>
'0': asynchronous kill mode: the kill event only disables the<p></p>
"line_out" and "line_compl_out" signals when present. In<p></p>
asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET.<p></p>
This field has a function in PWM and PWM_DT modes only. This<p></p>
field is only used when PWM_STOP_ON_KILL is '0'.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b11">reserved_b11</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[13:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_disable_mode">pwm_disable_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the behavior of the PWM outputs "line_out" and<p></p>
"line_compl_out" while the TCPWM counter is disabled<p></p>
(CTL.ENABLED='0') or stopped.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the immediate kill logic and line_out polarity<p></p>
settings (CTRL.QUAD_ENCODING_MODE).<p></p>
0x0 : Z : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are NOT driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the TCPWM output "line_out_en"<p></p>
to 0.<p></p>
When the counter is stopped upon a stop event the PWM outputs<p></p>
are deactivated (to the polarity defined by<p></p>
CTRL.QUAD_ENCODING_MODE).<p></p>
0x1 : RETAIN : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM outputs are retained (keep their previous levels).<p></p>
While the counter is disabled or stopped the PWM outputs can be<p></p>
changed via LINE_SEL.<p></p>
0x2 : L : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '0' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '1'.<p></p>
0x3 : H : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '1' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '0'.</p>
</td>
</tr>
<tr><td><p>[15:14]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b14to15">reserved_b14to15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[17:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_up_down_mode">up_down_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Determines counter direction.<p></p>
In QUAD mode this field acts as QUAD_RANGE_MODE field selecting<p></p>
between different counter range, reload value and compare /<p></p>
capture behavior.<p></p>
0x0 : COUNT_UP : Count up (to PERIOD). An overflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals PERIOD. A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals PERIOD.<p></p>
0x0 : QUAD_RANGE0 : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0 mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- on reload / index event:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- tc and cc0_match events are generated<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- cc0_match event is generated<p></p>
0x1 : COUNT_DOWN : Count down (to "0"). An underflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x1 : QUAD_RANGE0_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0_CMP mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- the capture0 event acts as 2nd reload / index event<p></p>
- on reload / index event:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on index' is selected (AUTO_RELOAD_PERIOD=0):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER is copied to PERIOD<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on wrap-around' is selected<p></p>
(AUTO_RELOAD_PERIOD=1):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to PERIOD<p></p>
- 1 or 2 compare functions (depending on CC1_PRESENT) available<p></p>
Because of that the PERIOD/PERIOD_BUFF registers are used<p></p>
instead of CC0/CC_BUFF registers to capture COUNTER at reload /<p></p>
index event or wrap-around.<p></p>
0x2 : COUNT_UPDN1 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x2 : QUAD_RANGE1_CAPT : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CAPT mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and PERIOD<p></p>
- on reload / index event:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- when COUNTER is 0x0000 and decrementing:<p></p>
- COUNTER is set to PERIOD<p></p>
- tc event is generated<p></p>
- when COUNTER equals PERIOD and is incrementing:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- 1 or 2 capture functions (depending on CC1_PRESENT) available<p></p>
- on capture0 / capture1 event:<p></p>
- CC0 / CC1 is copied to CC0_BUFF / CC1_BUFF<p></p>
- COUNTER value is copied to CC0<p></p>
It allows that the COUNTER register reflects the current angle<p></p>
position of the rotary encoder, i.e. no MOD or SUB calculations<p></p>
need to be done in SW on the COUNTER value to get the current<p></p>
angle position. This allows a DMA copy of the angle position<p></p>
from the COUNTER register. However, a disadvantage of this mode<p></p>
is that fast sequences of tc interrupts can occur (when encoder<p></p>
moves back and forth around start position). It is recommended<p></p>
to not use the tc interrupt in this mode.<p></p>
0x3 : COUNT_UPDN2 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0"<p></p>
AND when the counter changes from a state in which COUNTER<p></p>
equals PERIOD (this counter direction can be used for PWM<p></p>
functionality with asymmetrical updates).<p></p>
0x3 : QUAD_RANGE1_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CMP mode.<p></p>
The behavior is the same as for QUAD_RANGE1_CAPT mode described<p></p>
above with the only difference that 1 or 2 compare functions<p></p>
(depending on CC1_PRESENT) are available instead of 1 or 2<p></p>
capture functions.</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_one_shot">one_shot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter runs continuous. When '1', counter is turned<p></p>
off by hardware when a terminal count event is generated.</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b19">reserved_b19</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[21:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_quad_encoding_mode">quad_encoding_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In QUAD mode this field selects the quadrature encoding mode<p></p>
(X1/X2/X4) or the Up / Down rotary counting mode.<p></p>
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to<p></p>
invert "line_out" and "line_compl_out". Inversion is the last<p></p>
step in generation of "line_out" and "line_compl_out"; i.e. a<p></p>
disabled output line "line_out" has the value<p></p>
QUAD_ENCODING_MODE[0] and a disabled output line<p></p>
"line_compl_out" has the value QUAD_ENCODING_MODE[1].<p></p>
0x0 : X1 : X1 encoding (QUAD mode)<p></p>
This encoding is identical with an up / down counting<p></p>
functionality of the following way: Rising edges of input phiA<p></p>
increment or decrement the counter depending on the state of<p></p>
input phiB (direction input).<p></p>
0x1 : X2 : X2 encoding (QUAD mode)<p></p>
0x1 : INV_OUT : When bit 0 is '1', QUADRATURE_ENCODING_MODE[0]<p></p>
inverts "line_out" (PWM/PWM_DT modes)<p></p>
0x2 : X4 : X4 encoding (QUAD mode)<p></p>
0x2 : INV_COMPL_OUT : When bit 1 is '1',<p></p>
QUADRATURE_ENCODING_MODE[1] inverts "line_compl_out"<p></p>
(PWM/PWM_DT modes)<p></p>
0x3 : UP_DOWN : Up / Down rotary counting mode. Input phiA<p></p>
increments the counter, input phiB decrements the counter. The<p></p>
trigger edge detection settings apply.</p>
</td>
</tr>
<tr><td><p>[23:22]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b22tob23">reserved_b22tob23</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_mode">mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter mode.<p></p>
0x0 : TIMER : Timer mode<p></p>
0x1 : EXT : Extension mode, which is defined in ext_mode[2:0]<p></p>
0x2 : CAPTURE : Capture mode<p></p>
0x3 : QUAD : Quadrature mode<p></p>
Different encoding modes can be selected by QUAD_ENCODING_MODE<p></p>
including up/down count functionality.<p></p>
Different counter range, reload value and capture behavior can<p></p>
be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).<p></p>
0x4 : PWM : Pulse width modulation (PWM) mode<p></p>
0x5 : PWM_DT : PWM with deadtime insertion mode<p></p>
0x6 : PWM_PR : Pseudo random pulse width modulation<p></p>
0x7 : SR : Shift register mode.</p>
</td>
</tr>
<tr><td><p>[29:27]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_ext_mode">ext_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>counter extension mode when mode[2:0] = 0x1<p></p>
0x0: DSHOT mode<p></p>
0x1~0x7: reserved</p>
</td>
</tr>
<tr><td><p>[30:30]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_dbg_freeze_en">dbg_freeze_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the counter behavior in debug mode.<p></p>
'0': The counter operation continues in debug mode.<p></p>
'1': The counter operation freezes in debug mode.</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_enabled">enabled</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter enable.<p></p>
'0': counter disabled.<p></p>
'1': counter enabled.<p></p>
Counter static configuration information (e.g. CTRL.mode, all<p></p>
TRIN_CTRL0/1, TRIN_EDGE_SEL, PWM_CTRL and TROUT_SEL register<p></p>
fields) should only be modified when the counter is disabled.<p></p>
When a counter is disabled, command and status information<p></p>
associated to the counter is cleared by HW, this includes:<p></p>
- the associated counter triggers in the CMD register are set to<p></p>
'0'.<p></p>
- the counter's interrupt cause fields in counter's INTR<p></p>
register.<p></p>
- the counter's status fields in counter's STATUS register..<p></p>
- the counter's trigger outputs ("tr_out0" and tr_out1").<p></p>
- the counter's line outputs ("line_out" and "line_compl_out").</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS">TCPWM_group05_STATUS</a></p>
</td>
<td><p>32'h00000224</p>
</td>
<td><p>When the counter is disabled (CTRL.enabled = 0), then the<p></p>
STATUS.tr_* bit fields are typically reset to their default<p></p>
values. However, there are exceptions possible in the following<p></p>
cases, based on the selected input trigger via TRIN_SEL*.*_sel:<p></p>
- If a constant '0' is selected, then a '0' is read.<p></p>
- If a constant '1' is selected, then a '1' is read.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_down">down</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter is counting up. When '1', counter is counting<p></p>
down. In QUAD mode, this field indicates the direction of the<p></p>
latest counter change: '0' when last incremented and '1' when<p></p>
last decremented.</p>
</td>
</tr>
<tr><td><p>[3:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b1tob3">reserved_b1tob3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture0">tr_capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 0 trigger.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_count">tr_count</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Indicates the actual level of the selected count trigger.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_reload">tr_reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected reload trigger.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_stop">tr_stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected stop trigger.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_start">tr_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected start trigger.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture1">tr_capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_out">line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the PWM line output signal.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_compl_out">line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the complementary PWM line output<p></p>
signal</p>
</td>
</tr>
<tr><td><p>[14:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b12tob14">reserved_b12tob14</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_running">running</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', the counter is NOT running. When '1', the counter is<p></p>
running.<p></p>
This field is used to indicate that the counter is running after<p></p>
a start/reload event and that the counter is stopped after a<p></p>
stop event.<p></p>
When a running counter operation is paused in debug state (see<p></p>
CTRL.dbg_pause) then the RUNNING bit is still '1'.</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_dt_cnt">dt_cnt</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Generic 16-bit counter field. In PWM_DT mode, this counter is<p></p>
used for dead time insertion on PWM line_out<p></p>
In all other modes, this counter is used for pre-scaling the<p></p>
selected counter clock. PWM_DT mode can NOT use prescaled clock<p></p>
functionality.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0">TCPWM_group05_CC0</a></p>
</td>
<td><p>32'h00000228</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_cc0">cc0</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
1. SW reads this register when the counter is enabled<p></p>
(CTRL.enabled = 1) already; or<p></p>
2. SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1">TCPWM_group05_CC1</a></p>
</td>
<td><p>32'h0000022C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_cc1">cc1</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD">TCPWM_group05_PERIOD</a></p>
</td>
<td><p>32'h00000230</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_period">period</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>The maximum value the counter can reach. When the counter is<p></p>
designed to count for n cycles, this field should be set to<p></p>
n-1.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER">TCPWM_group05_COUNTER</a></p>
</td>
<td><p>32'h00000234</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER_val">val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>32-bit counter value. It is advised to not write to the this<p></p>
field when the counter is running.<p></p>
TCPWM counter can only be initialized by software in PWM_PR and<p></p>
SR mode.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL">TCPWM_group05_PWM_CTRL</a></p>
</td>
<td><p>32'h00000238</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc0_match_mode">cc0_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 0 event (COUNTER equals<p></p>
CC0 register) on the "line" output signals. Note that INVERT is<p></p>
especially useful for center aligned pulse width modulation.<p></p>
To generate a duty cycle of 0%, the counter CC0 register should<p></p>
be set to "0". For a 100% duty cycle, the counter CC0 register<p></p>
should be set to larger than the counter PERIOD register.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_overflow_mode">overflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter overflow event (COUNTER<p></p>
reaches PERIOD) on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_underflow_mode">underflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter underflow event (COUNTER<p></p>
reaches "0") on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc1_match_mode">cc1_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 1 event (COUNTER equals<p></p>
CC1 register) on the "line_out" output signals.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL">TCPWM_group05_LINE_SEL</a></p>
</td>
<td><p>32'h0000023C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects the source for the output signal "line_out". Default<p></p>
setting is the PWM signal "line". Other settings are useful for<p></p>
Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_out polarity setting<p></p>
(CTRL.quad_encoding_mode[0]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_out" is not driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the output "line_out_en" to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects the source for the output signal "line_compl_out".<p></p>
Default setting is the inverted PWM signal "line". Other<p></p>
settings are useful for Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_compl_out polarity<p></p>
setting (CTRL.quad_encoding_mode[1]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_compl_out" is not driven by the<p></p>
TCPWM. Instead the port default level configuration applies,<p></p>
e.g. "Z" (high impedance).<p></p>
Note: This is realized by driving the output "line_compl_out_en"<p></p>
to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF">TCPWM_group05_CC0_BUFF</a></p>
</td>
<td><p>32'h00000240</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF_cc0_buff">cc0_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC0 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF">TCPWM_group05_CC1_BUFF</a></p>
</td>
<td><p>32'h00000244</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF_cc1_buff">cc1_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC1 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF">TCPWM_group05_PERIOD_BUFF</a></p>
</td>
<td><p>32'h00000248</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF_period_buff">period_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter PERIOD register.<p></p>
In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit<p></p>
represents a tap of the shift register which can be feed back<p></p>
to the MSB of counter via an XOR tree.<p></p>
Examples for CNTWIDTH = 16:<p></p>
- Maximum length 16bit LFSR<p></p>
- polynomial x^16 + x^14 + x^13 + x^11 + 1<p></p>
- taps 0,2,3,5 - > PERIOD_BUFF = 0x002d<p></p>
- period is 2^16-1 = 65535 cycles<p></p>
- Maximum length 8bit LFSR:<p></p>
- polynomial x^8 + x^6 + x^5 + x^4 + 1<p></p>
- taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)<p></p>
- period is 2^8-1 = 255 cycles<p></p>
In SR mode PERIOD_BUFF defines which tap of the shift register<p></p>
generates the PWM output signals. For a delay of n cycles (from<p></p>
capture event to PWM output) the bit CNT_WIDTH-n should be set<p></p>
to '1'. For a shift register function only one tap should be<p></p>
use, i.e. a one-hot value must be written to PERIOD_BUFF. If<p></p>
multiple bits in PERIOD_BUFF are set then the taps are XOR<p></p>
combined.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF">TCPWM_group05_LINE_SEL_BUFF</a></p>
</td>
<td><p>32'h0000024C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Buffer for LINE_SEL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.out_sel on a terminal count event<p></p>
with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Buffer for LINE_SEL.COMPL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.compl_out_sel on a terminal count<p></p>
event with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0">TCPWM_group05_TRIN_CTRL0</a></p>
</td>
<td><p>32'h00000250</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_capture0_sel">capture0_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the up to 256 input triggers as a capture0<p></p>
trigger. Input trigger 0 is always '0' and input trigger 1 is<p></p>
always '1'.<p></p>
In the PWM, PWM_DT and PWM_PR modes this trigger is used to<p></p>
switch the values of the compare and period registers with<p></p>
their buffer counterparts.</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_count_sel">count_sel</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Selects one of the 256 input triggers as a count trigger.<p></p>
In QUAD mode, this is the first phase (phi A). Default setting<p></p>
selects input trigger 1, which is always '1'.<p></p>
Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the<p></p>
counter is externally triggered ( COUNT_SEL > 1), an external<p></p>
trigger will be required for each TR_CMD to execute. For<p></p>
example, a write to TR_CMD.START will not start the counter<p></p>
until the trigger selected by COUNT_SEL asserts. The next<p></p>
trigger will increment the counter since the counter is now<p></p>
running. This goes for all TR_CMD fields.</p>
</td>
</tr>
<tr><td><p>[23:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_reload_sel">reload_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a reload trigger.<p></p>
In QUAD mode, this is the index or revolution pulse. In these<p></p>
modes, it will update the counter with 0x8000 (counter<p></p>
midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</p>
</td>
</tr>
<tr><td><p>[31:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_stop_sel">stop_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a stop trigger.<p></p>
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In<p></p>
these modes, the kill trigger is used to either temporarily<p></p>
block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the<p></p>
functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT<p></p>
modes, the blocking of the output signals can be asynchronous<p></p>
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is<p></p>
as long as the trigger is '1' or synchronous (STOP_EDGE should<p></p>
be RISING_EDGE) in which case it extends till the next terminal<p></p>
count event.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1">TCPWM_group05_TRIN_CTRL1</a></p>
</td>
<td><p>32'h00000254</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_sel">start_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a start trigger. In<p></p>
QUAD mode, this is the second phase (phi B).</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_sel">capture1_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture0_inv">capture0_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture0 will be inverted before counter usage.</p>
</td>
</tr>
<tr><td><p>[17:17]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_count_inv">count_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger count will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_reload_inv">reload_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger reload will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_stop_inv">stop_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger stop will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[20:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_inv">start_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger start will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[21:21]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_inv">capture1_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture1 will be inverted before counter usage</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL">TCPWM_group05_TRIN_EDGE_SEL</a></p>
</td>
<td><p>32'h00000258</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture0_edge">capture0_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_count_edge">count_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_reload_edge">reload_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_stop_edge">stop_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_start_edge">start_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[11:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture1_edge">capture1_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL">TCPWM_group05_TROUT_SEL</a></p>
</td>
<td><p>32'h0000025C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out0">out0</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 0. Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH: Compare match 0 event<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7: Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_3">reserved_3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out1">out1</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 1. Default setting selects the compare match 0 event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event<p></p>
0x3 : CC0_MATCH: Compare match 0 event (default selection)<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7 : Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_7">reserved_7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD">TCPWM_group05_TR_CMD</a></p>
</td>
<td><p>32'h00000260</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture0">capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture 0 trigger. When written with '1', a capture 0 trigger<p></p>
is generated and the HW sets the field to '0' when the SW<p></p>
trigger has taken effect. It should be noted that the HW<p></p>
operates on the counter frequency. If the counter is disabled<p></p>
through CTRL.ENABLED, the field is immediately set to '0'.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reserved_1">reserved_1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reload">reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW reload trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_stop">stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW stop trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW start trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture1">capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture1 trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(WOC-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA">TCPWM_group05_INTR_STA</a></p>
</td>
<td><p>32'h00000264</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when a terminal count or DSHOT done is detected, write<p></p>
‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare0 (CC0)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare1 (CC1)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(W-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET">TCPWM_group05_INTR_SET</a></p>
</td>
<td><p>32'h00000268</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK">TCPWM_group05_INTR_MASK</a></p>
</td>
<td><p>32'h0000026C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.tc, when it is set, the counter interrupt<p></p>
will ignore the status of INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc0_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc1_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED">TCPWM_group05_INTR_MASKED</a></p>
</td>
<td><p>32'h00000270</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.tc and INTR_MASK.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc0_match and INTR_MASK.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc1_match and INTR_MASK.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME">TCPWM_group05_DEADTIME</a></p>
</td>
<td><p>32'h00000274</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_out">dt_line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In PWM_DT mode, this field is used to determine dead time before<p></p>
activating the PWM line output signal "line_out": amount of dead<p></p>
time cycles in the counter clock domain.<p></p>
In all other modes, the lower 3 bits of this field determine<p></p>
pre-scaling of the selected counter clock.<p></p>
0x0 : DIVBY1 : Divide by 1 (other-than-PWM_DT mode)<p></p>
0x1 : DIVBY2 : Divide by 2 (other-than-PWM_DT mode)<p></p>
0x2 : DIVBY4 : Divide by 4 (other-than-PWM_DT mode)<p></p>
0x3 : DIVBY8 : Divide by 8 (other-than-PWM_DT mode)<p></p>
0x4 : DIVBY16 : Divide by 16 (other-than-PWM_DT mode)<p></p>
0x5 : DIVBY32 : Divide by 32 (other-than-PWM_DT mode)<p></p>
0x6 : DIVBY64 : Divide by 64 (other-than-PWM_DT mode)<p></p>
0x7 : DIVBY128 : Divide by 128 (other-than-PWM_DT mode)</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_compl_out">dt_line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>in PWM_DT mode, this field is used to determine the dead time<p></p>
before activating the complementary PWM line output signal<p></p>
"line_compl_out": amount of dead time cycles in the counter<p></p>
clock domain.<p></p>
In all other modes, this field has no effect.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL">TCPWM_group05_SEMA_CTRL</a></p>
</td>
<td><p>32'h00000278</p>
</td>
<td><p>there are two semaphores (sema#0 and sema#1) per counter, they<p></p>
are used to synchronize counter operation and descriptor master<p></p>
cfg automation, selected counter signal will be used to set the<p></p>
corresponding semaphore, descriptor SYN command header info<p></p>
SYN.op, SYN.msk_grp and SYN.msk will choose how to unset<p></p>
(clear) semaphore.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema0_sel">sema0_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to set sema#0.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema1_sel">sema1_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to set sema#1.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b7">reserved_b7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS">TCPWM_group05_SEMA_STS</a></p>
</td>
<td><p>32'h0000027C</p>
</td>
<td><p>used to indicate two semaphores bit status, both Hardware and<p></p>
Software can access: counter will set semaphore status when the<p></p>
event defined by SEMA_CTRL occurs, SYN descriptor execution with<p></p>
OP code 4’b10 also set semaphore status; semaphore status is<p></p>
cleared when SYN descriptor with OP code 4’b11 is performed;<p></p>
Software can set semaphore status when an early SYN descriptor<p></p>
termination is required, this is useful during debug process.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema0_val">sema0_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#0 status</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema1_val">sema1_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#1 status</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME">TCPWM_group05_DSHOT_FRAME</a></p>
</td>
<td><p>32'h00000280</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME_frame">frame</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT frame 16-bit value<p></p>
[10:0] 11-bit value for throttle command (0~2047)<p></p>
[11] 1-bit flag: 1 telemetry is requested from the drone ESC<p></p>
(Electronic Speed Controller); 0 otherwise<p></p>
[15:12] 4-bit checksum for error detection</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY">TCPWM_group05_DSHOT_DUTY</a></p>
</td>
<td><p>32'h00000284</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_high">high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 1 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “1”</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_low">low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 0 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “0”</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL">TCPWM_group06_CLK_CTRL</a></p>
</td>
<td><p>32'h00000288</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL_clkdiv_sel">clkdiv_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>All TCPWM counter clock (the counter clock before active event<p></p>
and prescaling) (including otrigClk used for counter output<p></p>
triggers) are generated by a group of clock dividers, the<p></p>
number of clock divider is controlled by design parameter<p></p>
CDIVNUM (which is set to 6 by default in design), the clock<p></p>
source for all clock dividers is periClk from SoC.<p></p>
This 4-bit field is used to select the one out of CDIVNUM clock<p></p>
dividers to provide the clock enable signal which is combined<p></p>
with active event and prescaling together to generate the<p></p>
counter’s operation clock in each of TCPWM counter. (otrigClk<p></p>
is only derived from clock divider)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL">TCPWM_group06_CTRL</a></p>
</td>
<td><p>32'h0000028C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc0">auto_reload_cc0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC0 and buffered CC0 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 0 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc1">auto_reload_cc1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC1 and buffered CC1 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 1 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_period">auto_reload_period</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the PERIOD and buffered PERIOD values.<p></p>
This field has a function in PWM and PWM_DT modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.<p></p>
In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to<p></p>
select the index / wrap-around capture function.<p></p>
'0': Captures on index (reload) event. The counter value is<p></p>
copied to the PERIOD register on an index (reload) event.<p></p>
'1': Captures when COUNTER equals 0 or 0xffff. The counter value<p></p>
is copied to the PERIOD register when COUNTER equals 0 or<p></p>
0xffff.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_line_sel">auto_reload_line_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values.<p></p>
This field has a function in PWM and PWM_PR modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_up_en">cc0_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting up<p></p>
'1': compare match 0 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_down_en">cc0_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 0 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_up_en">cc1_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting up<p></p>
'1': compare match 1 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_down_en">cc1_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 1 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_imm_kill">pwm_imm_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the kill event immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals or with the next module<p></p>
clock ("active count" pre-scaled counter clock).<p></p>
'0': synchronous kill activation. Deactivates the "line_out" and<p></p>
"line_compl_out" signals with the next module clock ("active<p></p>
count" pre-scaled counter clock).<p></p>
'1': immediate kill activation. Immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_stop_on_kill">pwm_stop_on_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the counter stops on a kill events:<p></p>
'0': kill event does NOT stop counter.<p></p>
'1': kill event stops counter.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_sync_kill">pwm_sync_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies asynchronous/synchronous kill release behavior:<p></p>
'1': synchronous kill mode: the kill event disables the<p></p>
"line_out" and "line_compl_out" signals till the next terminal<p></p>
count event (synchronous kill). In synchronous kill mode,<p></p>
STOP_EDGE should be NO_EDGE_DET.<p></p>
'0': asynchronous kill mode: the kill event only disables the<p></p>
"line_out" and "line_compl_out" signals when present. In<p></p>
asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET.<p></p>
This field has a function in PWM and PWM_DT modes only. This<p></p>
field is only used when PWM_STOP_ON_KILL is '0'.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b11">reserved_b11</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[13:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_disable_mode">pwm_disable_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the behavior of the PWM outputs "line_out" and<p></p>
"line_compl_out" while the TCPWM counter is disabled<p></p>
(CTL.ENABLED='0') or stopped.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the immediate kill logic and line_out polarity<p></p>
settings (CTRL.QUAD_ENCODING_MODE).<p></p>
0x0 : Z : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are NOT driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the TCPWM output "line_out_en"<p></p>
to 0.<p></p>
When the counter is stopped upon a stop event the PWM outputs<p></p>
are deactivated (to the polarity defined by<p></p>
CTRL.QUAD_ENCODING_MODE).<p></p>
0x1 : RETAIN : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM outputs are retained (keep their previous levels).<p></p>
While the counter is disabled or stopped the PWM outputs can be<p></p>
changed via LINE_SEL.<p></p>
0x2 : L : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '0' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '1'.<p></p>
0x3 : H : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '1' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '0'.</p>
</td>
</tr>
<tr><td><p>[15:14]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b14to15">reserved_b14to15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[17:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_up_down_mode">up_down_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Determines counter direction.<p></p>
In QUAD mode this field acts as QUAD_RANGE_MODE field selecting<p></p>
between different counter range, reload value and compare /<p></p>
capture behavior.<p></p>
0x0 : COUNT_UP : Count up (to PERIOD). An overflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals PERIOD. A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals PERIOD.<p></p>
0x0 : QUAD_RANGE0 : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0 mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- on reload / index event:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- tc and cc0_match events are generated<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- cc0_match event is generated<p></p>
0x1 : COUNT_DOWN : Count down (to "0"). An underflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x1 : QUAD_RANGE0_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0_CMP mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- the capture0 event acts as 2nd reload / index event<p></p>
- on reload / index event:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on index' is selected (AUTO_RELOAD_PERIOD=0):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER is copied to PERIOD<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on wrap-around' is selected<p></p>
(AUTO_RELOAD_PERIOD=1):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to PERIOD<p></p>
- 1 or 2 compare functions (depending on CC1_PRESENT) available<p></p>
Because of that the PERIOD/PERIOD_BUFF registers are used<p></p>
instead of CC0/CC_BUFF registers to capture COUNTER at reload /<p></p>
index event or wrap-around.<p></p>
0x2 : COUNT_UPDN1 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x2 : QUAD_RANGE1_CAPT : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CAPT mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and PERIOD<p></p>
- on reload / index event:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- when COUNTER is 0x0000 and decrementing:<p></p>
- COUNTER is set to PERIOD<p></p>
- tc event is generated<p></p>
- when COUNTER equals PERIOD and is incrementing:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- 1 or 2 capture functions (depending on CC1_PRESENT) available<p></p>
- on capture0 / capture1 event:<p></p>
- CC0 / CC1 is copied to CC0_BUFF / CC1_BUFF<p></p>
- COUNTER value is copied to CC0<p></p>
It allows that the COUNTER register reflects the current angle<p></p>
position of the rotary encoder, i.e. no MOD or SUB calculations<p></p>
need to be done in SW on the COUNTER value to get the current<p></p>
angle position. This allows a DMA copy of the angle position<p></p>
from the COUNTER register. However, a disadvantage of this mode<p></p>
is that fast sequences of tc interrupts can occur (when encoder<p></p>
moves back and forth around start position). It is recommended<p></p>
to not use the tc interrupt in this mode.<p></p>
0x3 : COUNT_UPDN2 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0"<p></p>
AND when the counter changes from a state in which COUNTER<p></p>
equals PERIOD (this counter direction can be used for PWM<p></p>
functionality with asymmetrical updates).<p></p>
0x3 : QUAD_RANGE1_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CMP mode.<p></p>
The behavior is the same as for QUAD_RANGE1_CAPT mode described<p></p>
above with the only difference that 1 or 2 compare functions<p></p>
(depending on CC1_PRESENT) are available instead of 1 or 2<p></p>
capture functions.</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_one_shot">one_shot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter runs continuous. When '1', counter is turned<p></p>
off by hardware when a terminal count event is generated.</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b19">reserved_b19</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[21:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_quad_encoding_mode">quad_encoding_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In QUAD mode this field selects the quadrature encoding mode<p></p>
(X1/X2/X4) or the Up / Down rotary counting mode.<p></p>
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to<p></p>
invert "line_out" and "line_compl_out". Inversion is the last<p></p>
step in generation of "line_out" and "line_compl_out"; i.e. a<p></p>
disabled output line "line_out" has the value<p></p>
QUAD_ENCODING_MODE[0] and a disabled output line<p></p>
"line_compl_out" has the value QUAD_ENCODING_MODE[1].<p></p>
0x0 : X1 : X1 encoding (QUAD mode)<p></p>
This encoding is identical with an up / down counting<p></p>
functionality of the following way: Rising edges of input phiA<p></p>
increment or decrement the counter depending on the state of<p></p>
input phiB (direction input).<p></p>
0x1 : X2 : X2 encoding (QUAD mode)<p></p>
0x1 : INV_OUT : When bit 0 is '1', QUADRATURE_ENCODING_MODE[0]<p></p>
inverts "line_out" (PWM/PWM_DT modes)<p></p>
0x2 : X4 : X4 encoding (QUAD mode)<p></p>
0x2 : INV_COMPL_OUT : When bit 1 is '1',<p></p>
QUADRATURE_ENCODING_MODE[1] inverts "line_compl_out"<p></p>
(PWM/PWM_DT modes)<p></p>
0x3 : UP_DOWN : Up / Down rotary counting mode. Input phiA<p></p>
increments the counter, input phiB decrements the counter. The<p></p>
trigger edge detection settings apply.</p>
</td>
</tr>
<tr><td><p>[23:22]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b22tob23">reserved_b22tob23</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_mode">mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter mode.<p></p>
0x0 : TIMER : Timer mode<p></p>
0x1 : EXT : Extension mode, which is defined in ext_mode[2:0]<p></p>
0x2 : CAPTURE : Capture mode<p></p>
0x3 : QUAD : Quadrature mode<p></p>
Different encoding modes can be selected by QUAD_ENCODING_MODE<p></p>
including up/down count functionality.<p></p>
Different counter range, reload value and capture behavior can<p></p>
be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).<p></p>
0x4 : PWM : Pulse width modulation (PWM) mode<p></p>
0x5 : PWM_DT : PWM with deadtime insertion mode<p></p>
0x6 : PWM_PR : Pseudo random pulse width modulation<p></p>
0x7 : SR : Shift register mode.</p>
</td>
</tr>
<tr><td><p>[29:27]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_ext_mode">ext_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>counter extension mode when mode[2:0] = 0x1<p></p>
0x0: DSHOT mode<p></p>
0x1~0x7: reserved</p>
</td>
</tr>
<tr><td><p>[30:30]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_dbg_freeze_en">dbg_freeze_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the counter behavior in debug mode.<p></p>
'0': The counter operation continues in debug mode.<p></p>
'1': The counter operation freezes in debug mode.</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_enabled">enabled</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter enable.<p></p>
'0': counter disabled.<p></p>
'1': counter enabled.<p></p>
Counter static configuration information (e.g. CTRL.mode, all<p></p>
TRIN_CTRL0/1, TRIN_EDGE_SEL, PWM_CTRL and TROUT_SEL register<p></p>
fields) should only be modified when the counter is disabled.<p></p>
When a counter is disabled, command and status information<p></p>
associated to the counter is cleared by HW, this includes:<p></p>
- the associated counter triggers in the CMD register are set to<p></p>
'0'.<p></p>
- the counter's interrupt cause fields in counter's INTR<p></p>
register.<p></p>
- the counter's status fields in counter's STATUS register..<p></p>
- the counter's trigger outputs ("tr_out0" and tr_out1").<p></p>
- the counter's line outputs ("line_out" and "line_compl_out").</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS">TCPWM_group06_STATUS</a></p>
</td>
<td><p>32'h00000290</p>
</td>
<td><p>When the counter is disabled (CTRL.enabled = 0), then the<p></p>
STATUS.tr_* bit fields are typically reset to their default<p></p>
values. However, there are exceptions possible in the following<p></p>
cases, based on the selected input trigger via TRIN_SEL*.*_sel:<p></p>
- If a constant '0' is selected, then a '0' is read.<p></p>
- If a constant '1' is selected, then a '1' is read.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_down">down</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter is counting up. When '1', counter is counting<p></p>
down. In QUAD mode, this field indicates the direction of the<p></p>
latest counter change: '0' when last incremented and '1' when<p></p>
last decremented.</p>
</td>
</tr>
<tr><td><p>[3:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b1tob3">reserved_b1tob3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture0">tr_capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 0 trigger.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_count">tr_count</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Indicates the actual level of the selected count trigger.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_reload">tr_reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected reload trigger.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_stop">tr_stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected stop trigger.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_start">tr_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected start trigger.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture1">tr_capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_out">line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the PWM line output signal.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_compl_out">line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the complementary PWM line output<p></p>
signal</p>
</td>
</tr>
<tr><td><p>[14:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b12tob14">reserved_b12tob14</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_running">running</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', the counter is NOT running. When '1', the counter is<p></p>
running.<p></p>
This field is used to indicate that the counter is running after<p></p>
a start/reload event and that the counter is stopped after a<p></p>
stop event.<p></p>
When a running counter operation is paused in debug state (see<p></p>
CTRL.dbg_pause) then the RUNNING bit is still '1'.</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_dt_cnt">dt_cnt</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Generic 16-bit counter field. In PWM_DT mode, this counter is<p></p>
used for dead time insertion on PWM line_out<p></p>
In all other modes, this counter is used for pre-scaling the<p></p>
selected counter clock. PWM_DT mode can NOT use prescaled clock<p></p>
functionality.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0">TCPWM_group06_CC0</a></p>
</td>
<td><p>32'h00000294</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_cc0">cc0</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
1. SW reads this register when the counter is enabled<p></p>
(CTRL.enabled = 1) already; or<p></p>
2. SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1">TCPWM_group06_CC1</a></p>
</td>
<td><p>32'h00000298</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_cc1">cc1</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD">TCPWM_group06_PERIOD</a></p>
</td>
<td><p>32'h0000029C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_period">period</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>The maximum value the counter can reach. When the counter is<p></p>
designed to count for n cycles, this field should be set to<p></p>
n-1.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER">TCPWM_group06_COUNTER</a></p>
</td>
<td><p>32'h000002A0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER_val">val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>32-bit counter value. It is advised to not write to the this<p></p>
field when the counter is running.<p></p>
TCPWM counter can only be initialized by software in PWM_PR and<p></p>
SR mode.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL">TCPWM_group06_PWM_CTRL</a></p>
</td>
<td><p>32'h000002A4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc0_match_mode">cc0_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 0 event (COUNTER equals<p></p>
CC0 register) on the "line" output signals. Note that INVERT is<p></p>
especially useful for center aligned pulse width modulation.<p></p>
To generate a duty cycle of 0%, the counter CC0 register should<p></p>
be set to "0". For a 100% duty cycle, the counter CC0 register<p></p>
should be set to larger than the counter PERIOD register.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_overflow_mode">overflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter overflow event (COUNTER<p></p>
reaches PERIOD) on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_underflow_mode">underflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter underflow event (COUNTER<p></p>
reaches "0") on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc1_match_mode">cc1_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 1 event (COUNTER equals<p></p>
CC1 register) on the "line_out" output signals.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL">TCPWM_group06_LINE_SEL</a></p>
</td>
<td><p>32'h000002A8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects the source for the output signal "line_out". Default<p></p>
setting is the PWM signal "line". Other settings are useful for<p></p>
Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_out polarity setting<p></p>
(CTRL.quad_encoding_mode[0]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_out" is not driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the output "line_out_en" to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects the source for the output signal "line_compl_out".<p></p>
Default setting is the inverted PWM signal "line". Other<p></p>
settings are useful for Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_compl_out polarity<p></p>
setting (CTRL.quad_encoding_mode[1]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_compl_out" is not driven by the<p></p>
TCPWM. Instead the port default level configuration applies,<p></p>
e.g. "Z" (high impedance).<p></p>
Note: This is realized by driving the output "line_compl_out_en"<p></p>
to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF">TCPWM_group06_CC0_BUFF</a></p>
</td>
<td><p>32'h000002AC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF_cc0_buff">cc0_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC0 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF">TCPWM_group06_CC1_BUFF</a></p>
</td>
<td><p>32'h000002B0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF_cc1_buff">cc1_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC1 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF">TCPWM_group06_PERIOD_BUFF</a></p>
</td>
<td><p>32'h000002B4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF_period_buff">period_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter PERIOD register.<p></p>
In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit<p></p>
represents a tap of the shift register which can be feed back<p></p>
to the MSB of counter via an XOR tree.<p></p>
Examples for CNTWIDTH = 16:<p></p>
- Maximum length 16bit LFSR<p></p>
- polynomial x^16 + x^14 + x^13 + x^11 + 1<p></p>
- taps 0,2,3,5 - > PERIOD_BUFF = 0x002d<p></p>
- period is 2^16-1 = 65535 cycles<p></p>
- Maximum length 8bit LFSR:<p></p>
- polynomial x^8 + x^6 + x^5 + x^4 + 1<p></p>
- taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)<p></p>
- period is 2^8-1 = 255 cycles<p></p>
In SR mode PERIOD_BUFF defines which tap of the shift register<p></p>
generates the PWM output signals. For a delay of n cycles (from<p></p>
capture event to PWM output) the bit CNT_WIDTH-n should be set<p></p>
to '1'. For a shift register function only one tap should be<p></p>
use, i.e. a one-hot value must be written to PERIOD_BUFF. If<p></p>
multiple bits in PERIOD_BUFF are set then the taps are XOR<p></p>
combined.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF">TCPWM_group06_LINE_SEL_BUFF</a></p>
</td>
<td><p>32'h000002B8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Buffer for LINE_SEL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.out_sel on a terminal count event<p></p>
with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Buffer for LINE_SEL.COMPL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.compl_out_sel on a terminal count<p></p>
event with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0">TCPWM_group06_TRIN_CTRL0</a></p>
</td>
<td><p>32'h000002BC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_capture0_sel">capture0_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the up to 256 input triggers as a capture0<p></p>
trigger. Input trigger 0 is always '0' and input trigger 1 is<p></p>
always '1'.<p></p>
In the PWM, PWM_DT and PWM_PR modes this trigger is used to<p></p>
switch the values of the compare and period registers with<p></p>
their buffer counterparts.</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_count_sel">count_sel</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Selects one of the 256 input triggers as a count trigger.<p></p>
In QUAD mode, this is the first phase (phi A). Default setting<p></p>
selects input trigger 1, which is always '1'.<p></p>
Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the<p></p>
counter is externally triggered ( COUNT_SEL > 1), an external<p></p>
trigger will be required for each TR_CMD to execute. For<p></p>
example, a write to TR_CMD.START will not start the counter<p></p>
until the trigger selected by COUNT_SEL asserts. The next<p></p>
trigger will increment the counter since the counter is now<p></p>
running. This goes for all TR_CMD fields.</p>
</td>
</tr>
<tr><td><p>[23:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_reload_sel">reload_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a reload trigger.<p></p>
In QUAD mode, this is the index or revolution pulse. In these<p></p>
modes, it will update the counter with 0x8000 (counter<p></p>
midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</p>
</td>
</tr>
<tr><td><p>[31:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_stop_sel">stop_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a stop trigger.<p></p>
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In<p></p>
these modes, the kill trigger is used to either temporarily<p></p>
block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the<p></p>
functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT<p></p>
modes, the blocking of the output signals can be asynchronous<p></p>
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is<p></p>
as long as the trigger is '1' or synchronous (STOP_EDGE should<p></p>
be RISING_EDGE) in which case it extends till the next terminal<p></p>
count event.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1">TCPWM_group06_TRIN_CTRL1</a></p>
</td>
<td><p>32'h000002C0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_sel">start_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a start trigger. In<p></p>
QUAD mode, this is the second phase (phi B).</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_sel">capture1_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture0_inv">capture0_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture0 will be inverted before counter usage.</p>
</td>
</tr>
<tr><td><p>[17:17]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_count_inv">count_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger count will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_reload_inv">reload_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger reload will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_stop_inv">stop_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger stop will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[20:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_inv">start_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger start will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[21:21]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_inv">capture1_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture1 will be inverted before counter usage</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL">TCPWM_group06_TRIN_EDGE_SEL</a></p>
</td>
<td><p>32'h000002C4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture0_edge">capture0_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_count_edge">count_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_reload_edge">reload_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_stop_edge">stop_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_start_edge">start_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[11:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture1_edge">capture1_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL">TCPWM_group06_TROUT_SEL</a></p>
</td>
<td><p>32'h000002C8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out0">out0</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 0. Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH: Compare match 0 event<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7: Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_3">reserved_3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out1">out1</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 1. Default setting selects the compare match 0 event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event<p></p>
0x3 : CC0_MATCH: Compare match 0 event (default selection)<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7 : Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_7">reserved_7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD">TCPWM_group06_TR_CMD</a></p>
</td>
<td><p>32'h000002CC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture0">capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture 0 trigger. When written with '1', a capture 0 trigger<p></p>
is generated and the HW sets the field to '0' when the SW<p></p>
trigger has taken effect. It should be noted that the HW<p></p>
operates on the counter frequency. If the counter is disabled<p></p>
through CTRL.ENABLED, the field is immediately set to '0'.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reserved_1">reserved_1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reload">reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW reload trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_stop">stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW stop trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW start trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture1">capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture1 trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(WOC-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA">TCPWM_group06_INTR_STA</a></p>
</td>
<td><p>32'h000002D0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when a terminal count or DSHOT done is detected, write<p></p>
‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare0 (CC0)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare1 (CC1)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(W-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET">TCPWM_group06_INTR_SET</a></p>
</td>
<td><p>32'h000002D4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK">TCPWM_group06_INTR_MASK</a></p>
</td>
<td><p>32'h000002D8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.tc, when it is set, the counter interrupt<p></p>
will ignore the status of INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc0_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc1_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED">TCPWM_group06_INTR_MASKED</a></p>
</td>
<td><p>32'h000002DC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.tc and INTR_MASK.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc0_match and INTR_MASK.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc1_match and INTR_MASK.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME">TCPWM_group06_DEADTIME</a></p>
</td>
<td><p>32'h000002E0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_out">dt_line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In PWM_DT mode, this field is used to determine dead time before<p></p>
activating the PWM line output signal "line_out": amount of dead<p></p>
time cycles in the counter clock domain.<p></p>
In all other modes, the lower 3 bits of this field determine<p></p>
pre-scaling of the selected counter clock.<p></p>
0x0 : DIVBY1 : Divide by 1 (other-than-PWM_DT mode)<p></p>
0x1 : DIVBY2 : Divide by 2 (other-than-PWM_DT mode)<p></p>
0x2 : DIVBY4 : Divide by 4 (other-than-PWM_DT mode)<p></p>
0x3 : DIVBY8 : Divide by 8 (other-than-PWM_DT mode)<p></p>
0x4 : DIVBY16 : Divide by 16 (other-than-PWM_DT mode)<p></p>
0x5 : DIVBY32 : Divide by 32 (other-than-PWM_DT mode)<p></p>
0x6 : DIVBY64 : Divide by 64 (other-than-PWM_DT mode)<p></p>
0x7 : DIVBY128 : Divide by 128 (other-than-PWM_DT mode)</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_compl_out">dt_line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>in PWM_DT mode, this field is used to determine the dead time<p></p>
before activating the complementary PWM line output signal<p></p>
"line_compl_out": amount of dead time cycles in the counter<p></p>
clock domain.<p></p>
In all other modes, this field has no effect.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL">TCPWM_group06_SEMA_CTRL</a></p>
</td>
<td><p>32'h000002E4</p>
</td>
<td><p>there are two semaphores (sema#0 and sema#1) per counter, they<p></p>
are used to synchronize counter operation and descriptor master<p></p>
cfg automation, selected counter signal will be used to set the<p></p>
corresponding semaphore, descriptor SYN command header info<p></p>
SYN.op, SYN.msk_grp and SYN.msk will choose how to unset<p></p>
(clear) semaphore.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema0_sel">sema0_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to set sema#0.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema1_sel">sema1_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to set sema#1.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b7">reserved_b7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS">TCPWM_group06_SEMA_STS</a></p>
</td>
<td><p>32'h000002E8</p>
</td>
<td><p>used to indicate two semaphores bit status, both Hardware and<p></p>
Software can access: counter will set semaphore status when the<p></p>
event defined by SEMA_CTRL occurs, SYN descriptor execution with<p></p>
OP code 4’b10 also set semaphore status; semaphore status is<p></p>
cleared when SYN descriptor with OP code 4’b11 is performed;<p></p>
Software can set semaphore status when an early SYN descriptor<p></p>
termination is required, this is useful during debug process.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema0_val">sema0_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#0 status</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema1_val">sema1_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#1 status</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME">TCPWM_group06_DSHOT_FRAME</a></p>
</td>
<td><p>32'h000002EC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME_frame">frame</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT frame 16-bit value<p></p>
[10:0] 11-bit value for throttle command (0~2047)<p></p>
[11] 1-bit flag: 1 telemetry is requested from the drone ESC<p></p>
(Electronic Speed Controller); 0 otherwise<p></p>
[15:12] 4-bit checksum for error detection</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY">TCPWM_group06_DSHOT_DUTY</a></p>
</td>
<td><p>32'h000002F0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_high">high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 1 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “1”</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_low">low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 0 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “0”</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL">TCPWM_group07_CLK_CTRL</a></p>
</td>
<td><p>32'h000002F4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL_clkdiv_sel">clkdiv_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>All TCPWM counter clock (the counter clock before active event<p></p>
and prescaling) (including otrigClk used for counter output<p></p>
triggers) are generated by a group of clock dividers, the<p></p>
number of clock divider is controlled by design parameter<p></p>
CDIVNUM (which is set to 6 by default in design), the clock<p></p>
source for all clock dividers is periClk from SoC.<p></p>
This 4-bit field is used to select the one out of CDIVNUM clock<p></p>
dividers to provide the clock enable signal which is combined<p></p>
with active event and prescaling together to generate the<p></p>
counter’s operation clock in each of TCPWM counter. (otrigClk<p></p>
is only derived from clock divider)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL">TCPWM_group07_CTRL</a></p>
</td>
<td><p>32'h000002F8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc0">auto_reload_cc0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC0 and buffered CC0 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 0 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc1">auto_reload_cc1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC1 and buffered CC1 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 1 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_period">auto_reload_period</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the PERIOD and buffered PERIOD values.<p></p>
This field has a function in PWM and PWM_DT modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.<p></p>
In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to<p></p>
select the index / wrap-around capture function.<p></p>
'0': Captures on index (reload) event. The counter value is<p></p>
copied to the PERIOD register on an index (reload) event.<p></p>
'1': Captures when COUNTER equals 0 or 0xffff. The counter value<p></p>
is copied to the PERIOD register when COUNTER equals 0 or<p></p>
0xffff.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_line_sel">auto_reload_line_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values.<p></p>
This field has a function in PWM and PWM_PR modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_up_en">cc0_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting up<p></p>
'1': compare match 0 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_down_en">cc0_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 0 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_up_en">cc1_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting up<p></p>
'1': compare match 1 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_down_en">cc1_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 1 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_imm_kill">pwm_imm_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the kill event immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals or with the next module<p></p>
clock ("active count" pre-scaled counter clock).<p></p>
'0': synchronous kill activation. Deactivates the "line_out" and<p></p>
"line_compl_out" signals with the next module clock ("active<p></p>
count" pre-scaled counter clock).<p></p>
'1': immediate kill activation. Immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_stop_on_kill">pwm_stop_on_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the counter stops on a kill events:<p></p>
'0': kill event does NOT stop counter.<p></p>
'1': kill event stops counter.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_sync_kill">pwm_sync_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies asynchronous/synchronous kill release behavior:<p></p>
'1': synchronous kill mode: the kill event disables the<p></p>
"line_out" and "line_compl_out" signals till the next terminal<p></p>
count event (synchronous kill). In synchronous kill mode,<p></p>
STOP_EDGE should be NO_EDGE_DET.<p></p>
'0': asynchronous kill mode: the kill event only disables the<p></p>
"line_out" and "line_compl_out" signals when present. In<p></p>
asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET.<p></p>
This field has a function in PWM and PWM_DT modes only. This<p></p>
field is only used when PWM_STOP_ON_KILL is '0'.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b11">reserved_b11</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[13:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_disable_mode">pwm_disable_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the behavior of the PWM outputs "line_out" and<p></p>
"line_compl_out" while the TCPWM counter is disabled<p></p>
(CTL.ENABLED='0') or stopped.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the immediate kill logic and line_out polarity<p></p>
settings (CTRL.QUAD_ENCODING_MODE).<p></p>
0x0 : Z : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are NOT driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the TCPWM output "line_out_en"<p></p>
to 0.<p></p>
When the counter is stopped upon a stop event the PWM outputs<p></p>
are deactivated (to the polarity defined by<p></p>
CTRL.QUAD_ENCODING_MODE).<p></p>
0x1 : RETAIN : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM outputs are retained (keep their previous levels).<p></p>
While the counter is disabled or stopped the PWM outputs can be<p></p>
changed via LINE_SEL.<p></p>
0x2 : L : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '0' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '1'.<p></p>
0x3 : H : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '1' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '0'.</p>
</td>
</tr>
<tr><td><p>[15:14]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b14to15">reserved_b14to15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[17:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_up_down_mode">up_down_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Determines counter direction.<p></p>
In QUAD mode this field acts as QUAD_RANGE_MODE field selecting<p></p>
between different counter range, reload value and compare /<p></p>
capture behavior.<p></p>
0x0 : COUNT_UP : Count up (to PERIOD). An overflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals PERIOD. A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals PERIOD.<p></p>
0x0 : QUAD_RANGE0 : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0 mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- on reload / index event:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- tc and cc0_match events are generated<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- cc0_match event is generated<p></p>
0x1 : COUNT_DOWN : Count down (to "0"). An underflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x1 : QUAD_RANGE0_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0_CMP mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- the capture0 event acts as 2nd reload / index event<p></p>
- on reload / index event:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on index' is selected (AUTO_RELOAD_PERIOD=0):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER is copied to PERIOD<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on wrap-around' is selected<p></p>
(AUTO_RELOAD_PERIOD=1):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to PERIOD<p></p>
- 1 or 2 compare functions (depending on CC1_PRESENT) available<p></p>
Because of that the PERIOD/PERIOD_BUFF registers are used<p></p>
instead of CC0/CC_BUFF registers to capture COUNTER at reload /<p></p>
index event or wrap-around.<p></p>
0x2 : COUNT_UPDN1 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x2 : QUAD_RANGE1_CAPT : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CAPT mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and PERIOD<p></p>
- on reload / index event:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- when COUNTER is 0x0000 and decrementing:<p></p>
- COUNTER is set to PERIOD<p></p>
- tc event is generated<p></p>
- when COUNTER equals PERIOD and is incrementing:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- 1 or 2 capture functions (depending on CC1_PRESENT) available<p></p>
- on capture0 / capture1 event:<p></p>
- CC0 / CC1 is copied to CC0_BUFF / CC1_BUFF<p></p>
- COUNTER value is copied to CC0<p></p>
It allows that the COUNTER register reflects the current angle<p></p>
position of the rotary encoder, i.e. no MOD or SUB calculations<p></p>
need to be done in SW on the COUNTER value to get the current<p></p>
angle position. This allows a DMA copy of the angle position<p></p>
from the COUNTER register. However, a disadvantage of this mode<p></p>
is that fast sequences of tc interrupts can occur (when encoder<p></p>
moves back and forth around start position). It is recommended<p></p>
to not use the tc interrupt in this mode.<p></p>
0x3 : COUNT_UPDN2 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0"<p></p>
AND when the counter changes from a state in which COUNTER<p></p>
equals PERIOD (this counter direction can be used for PWM<p></p>
functionality with asymmetrical updates).<p></p>
0x3 : QUAD_RANGE1_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CMP mode.<p></p>
The behavior is the same as for QUAD_RANGE1_CAPT mode described<p></p>
above with the only difference that 1 or 2 compare functions<p></p>
(depending on CC1_PRESENT) are available instead of 1 or 2<p></p>
capture functions.</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_one_shot">one_shot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter runs continuous. When '1', counter is turned<p></p>
off by hardware when a terminal count event is generated.</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b19">reserved_b19</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[21:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_quad_encoding_mode">quad_encoding_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In QUAD mode this field selects the quadrature encoding mode<p></p>
(X1/X2/X4) or the Up / Down rotary counting mode.<p></p>
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to<p></p>
invert "line_out" and "line_compl_out". Inversion is the last<p></p>
step in generation of "line_out" and "line_compl_out"; i.e. a<p></p>
disabled output line "line_out" has the value<p></p>
QUAD_ENCODING_MODE[0] and a disabled output line<p></p>
"line_compl_out" has the value QUAD_ENCODING_MODE[1].<p></p>
0x0 : X1 : X1 encoding (QUAD mode)<p></p>
This encoding is identical with an up / down counting<p></p>
functionality of the following way: Rising edges of input phiA<p></p>
increment or decrement the counter depending on the state of<p></p>
input phiB (direction input).<p></p>
0x1 : X2 : X2 encoding (QUAD mode)<p></p>
0x1 : INV_OUT : When bit 0 is '1', QUADRATURE_ENCODING_MODE[0]<p></p>
inverts "line_out" (PWM/PWM_DT modes)<p></p>
0x2 : X4 : X4 encoding (QUAD mode)<p></p>
0x2 : INV_COMPL_OUT : When bit 1 is '1',<p></p>
QUADRATURE_ENCODING_MODE[1] inverts "line_compl_out"<p></p>
(PWM/PWM_DT modes)<p></p>
0x3 : UP_DOWN : Up / Down rotary counting mode. Input phiA<p></p>
increments the counter, input phiB decrements the counter. The<p></p>
trigger edge detection settings apply.</p>
</td>
</tr>
<tr><td><p>[23:22]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b22tob23">reserved_b22tob23</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_mode">mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter mode.<p></p>
0x0 : TIMER : Timer mode<p></p>
0x1 : EXT : Extension mode, which is defined in ext_mode[2:0]<p></p>
0x2 : CAPTURE : Capture mode<p></p>
0x3 : QUAD : Quadrature mode<p></p>
Different encoding modes can be selected by QUAD_ENCODING_MODE<p></p>
including up/down count functionality.<p></p>
Different counter range, reload value and capture behavior can<p></p>
be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).<p></p>
0x4 : PWM : Pulse width modulation (PWM) mode<p></p>
0x5 : PWM_DT : PWM with deadtime insertion mode<p></p>
0x6 : PWM_PR : Pseudo random pulse width modulation<p></p>
0x7 : SR : Shift register mode.</p>
</td>
</tr>
<tr><td><p>[29:27]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_ext_mode">ext_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>counter extension mode when mode[2:0] = 0x1<p></p>
0x0: DSHOT mode<p></p>
0x1~0x7: reserved</p>
</td>
</tr>
<tr><td><p>[30:30]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_dbg_freeze_en">dbg_freeze_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the counter behavior in debug mode.<p></p>
'0': The counter operation continues in debug mode.<p></p>
'1': The counter operation freezes in debug mode.</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_enabled">enabled</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter enable.<p></p>
'0': counter disabled.<p></p>
'1': counter enabled.<p></p>
Counter static configuration information (e.g. CTRL.mode, all<p></p>
TRIN_CTRL0/1, TRIN_EDGE_SEL, PWM_CTRL and TROUT_SEL register<p></p>
fields) should only be modified when the counter is disabled.<p></p>
When a counter is disabled, command and status information<p></p>
associated to the counter is cleared by HW, this includes:<p></p>
- the associated counter triggers in the CMD register are set to<p></p>
'0'.<p></p>
- the counter's interrupt cause fields in counter's INTR<p></p>
register.<p></p>
- the counter's status fields in counter's STATUS register..<p></p>
- the counter's trigger outputs ("tr_out0" and tr_out1").<p></p>
- the counter's line outputs ("line_out" and "line_compl_out").</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS">TCPWM_group07_STATUS</a></p>
</td>
<td><p>32'h000002FC</p>
</td>
<td><p>When the counter is disabled (CTRL.enabled = 0), then the<p></p>
STATUS.tr_* bit fields are typically reset to their default<p></p>
values. However, there are exceptions possible in the following<p></p>
cases, based on the selected input trigger via TRIN_SEL*.*_sel:<p></p>
- If a constant '0' is selected, then a '0' is read.<p></p>
- If a constant '1' is selected, then a '1' is read.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_down">down</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter is counting up. When '1', counter is counting<p></p>
down. In QUAD mode, this field indicates the direction of the<p></p>
latest counter change: '0' when last incremented and '1' when<p></p>
last decremented.</p>
</td>
</tr>
<tr><td><p>[3:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b1tob3">reserved_b1tob3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture0">tr_capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 0 trigger.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_count">tr_count</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Indicates the actual level of the selected count trigger.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_reload">tr_reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected reload trigger.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_stop">tr_stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected stop trigger.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_start">tr_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected start trigger.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture1">tr_capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_out">line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the PWM line output signal.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_compl_out">line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the complementary PWM line output<p></p>
signal</p>
</td>
</tr>
<tr><td><p>[14:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b12tob14">reserved_b12tob14</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_running">running</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', the counter is NOT running. When '1', the counter is<p></p>
running.<p></p>
This field is used to indicate that the counter is running after<p></p>
a start/reload event and that the counter is stopped after a<p></p>
stop event.<p></p>
When a running counter operation is paused in debug state (see<p></p>
CTRL.dbg_pause) then the RUNNING bit is still '1'.</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_dt_cnt">dt_cnt</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Generic 16-bit counter field. In PWM_DT mode, this counter is<p></p>
used for dead time insertion on PWM line_out<p></p>
In all other modes, this counter is used for pre-scaling the<p></p>
selected counter clock. PWM_DT mode can NOT use prescaled clock<p></p>
functionality.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0">TCPWM_group07_CC0</a></p>
</td>
<td><p>32'h00000300</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_cc0">cc0</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
1. SW reads this register when the counter is enabled<p></p>
(CTRL.enabled = 1) already; or<p></p>
2. SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1">TCPWM_group07_CC1</a></p>
</td>
<td><p>32'h00000304</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_cc1">cc1</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD">TCPWM_group07_PERIOD</a></p>
</td>
<td><p>32'h00000308</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_period">period</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>The maximum value the counter can reach. When the counter is<p></p>
designed to count for n cycles, this field should be set to<p></p>
n-1.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER">TCPWM_group07_COUNTER</a></p>
</td>
<td><p>32'h0000030C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER_val">val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>32-bit counter value. It is advised to not write to the this<p></p>
field when the counter is running.<p></p>
TCPWM counter can only be initialized by software in PWM_PR and<p></p>
SR mode.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL">TCPWM_group07_PWM_CTRL</a></p>
</td>
<td><p>32'h00000310</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc0_match_mode">cc0_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 0 event (COUNTER equals<p></p>
CC0 register) on the "line" output signals. Note that INVERT is<p></p>
especially useful for center aligned pulse width modulation.<p></p>
To generate a duty cycle of 0%, the counter CC0 register should<p></p>
be set to "0". For a 100% duty cycle, the counter CC0 register<p></p>
should be set to larger than the counter PERIOD register.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_overflow_mode">overflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter overflow event (COUNTER<p></p>
reaches PERIOD) on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_underflow_mode">underflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter underflow event (COUNTER<p></p>
reaches "0") on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc1_match_mode">cc1_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 1 event (COUNTER equals<p></p>
CC1 register) on the "line_out" output signals.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL">TCPWM_group07_LINE_SEL</a></p>
</td>
<td><p>32'h00000314</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects the source for the output signal "line_out". Default<p></p>
setting is the PWM signal "line". Other settings are useful for<p></p>
Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_out polarity setting<p></p>
(CTRL.quad_encoding_mode[0]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_out" is not driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the output "line_out_en" to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects the source for the output signal "line_compl_out".<p></p>
Default setting is the inverted PWM signal "line". Other<p></p>
settings are useful for Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_compl_out polarity<p></p>
setting (CTRL.quad_encoding_mode[1]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_compl_out" is not driven by the<p></p>
TCPWM. Instead the port default level configuration applies,<p></p>
e.g. "Z" (high impedance).<p></p>
Note: This is realized by driving the output "line_compl_out_en"<p></p>
to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF">TCPWM_group07_CC0_BUFF</a></p>
</td>
<td><p>32'h00000318</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF_cc0_buff">cc0_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC0 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF">TCPWM_group07_CC1_BUFF</a></p>
</td>
<td><p>32'h0000031C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF_cc1_buff">cc1_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC1 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF">TCPWM_group07_PERIOD_BUFF</a></p>
</td>
<td><p>32'h00000320</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF_period_buff">period_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter PERIOD register.<p></p>
In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit<p></p>
represents a tap of the shift register which can be feed back<p></p>
to the MSB of counter via an XOR tree.<p></p>
Examples for CNTWIDTH = 16:<p></p>
- Maximum length 16bit LFSR<p></p>
- polynomial x^16 + x^14 + x^13 + x^11 + 1<p></p>
- taps 0,2,3,5 - > PERIOD_BUFF = 0x002d<p></p>
- period is 2^16-1 = 65535 cycles<p></p>
- Maximum length 8bit LFSR:<p></p>
- polynomial x^8 + x^6 + x^5 + x^4 + 1<p></p>
- taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)<p></p>
- period is 2^8-1 = 255 cycles<p></p>
In SR mode PERIOD_BUFF defines which tap of the shift register<p></p>
generates the PWM output signals. For a delay of n cycles (from<p></p>
capture event to PWM output) the bit CNT_WIDTH-n should be set<p></p>
to '1'. For a shift register function only one tap should be<p></p>
use, i.e. a one-hot value must be written to PERIOD_BUFF. If<p></p>
multiple bits in PERIOD_BUFF are set then the taps are XOR<p></p>
combined.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF">TCPWM_group07_LINE_SEL_BUFF</a></p>
</td>
<td><p>32'h00000324</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Buffer for LINE_SEL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.out_sel on a terminal count event<p></p>
with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Buffer for LINE_SEL.COMPL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.compl_out_sel on a terminal count<p></p>
event with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0">TCPWM_group07_TRIN_CTRL0</a></p>
</td>
<td><p>32'h00000328</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_capture0_sel">capture0_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the up to 256 input triggers as a capture0<p></p>
trigger. Input trigger 0 is always '0' and input trigger 1 is<p></p>
always '1'.<p></p>
In the PWM, PWM_DT and PWM_PR modes this trigger is used to<p></p>
switch the values of the compare and period registers with<p></p>
their buffer counterparts.</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_count_sel">count_sel</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Selects one of the 256 input triggers as a count trigger.<p></p>
In QUAD mode, this is the first phase (phi A). Default setting<p></p>
selects input trigger 1, which is always '1'.<p></p>
Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the<p></p>
counter is externally triggered ( COUNT_SEL > 1), an external<p></p>
trigger will be required for each TR_CMD to execute. For<p></p>
example, a write to TR_CMD.START will not start the counter<p></p>
until the trigger selected by COUNT_SEL asserts. The next<p></p>
trigger will increment the counter since the counter is now<p></p>
running. This goes for all TR_CMD fields.</p>
</td>
</tr>
<tr><td><p>[23:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_reload_sel">reload_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a reload trigger.<p></p>
In QUAD mode, this is the index or revolution pulse. In these<p></p>
modes, it will update the counter with 0x8000 (counter<p></p>
midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</p>
</td>
</tr>
<tr><td><p>[31:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_stop_sel">stop_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a stop trigger.<p></p>
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In<p></p>
these modes, the kill trigger is used to either temporarily<p></p>
block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the<p></p>
functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT<p></p>
modes, the blocking of the output signals can be asynchronous<p></p>
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is<p></p>
as long as the trigger is '1' or synchronous (STOP_EDGE should<p></p>
be RISING_EDGE) in which case it extends till the next terminal<p></p>
count event.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1">TCPWM_group07_TRIN_CTRL1</a></p>
</td>
<td><p>32'h0000032C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_sel">start_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a start trigger. In<p></p>
QUAD mode, this is the second phase (phi B).</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_sel">capture1_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture0_inv">capture0_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture0 will be inverted before counter usage.</p>
</td>
</tr>
<tr><td><p>[17:17]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_count_inv">count_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger count will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_reload_inv">reload_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger reload will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_stop_inv">stop_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger stop will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[20:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_inv">start_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger start will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[21:21]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_inv">capture1_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture1 will be inverted before counter usage</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL">TCPWM_group07_TRIN_EDGE_SEL</a></p>
</td>
<td><p>32'h00000330</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture0_edge">capture0_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_count_edge">count_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_reload_edge">reload_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_stop_edge">stop_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_start_edge">start_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[11:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture1_edge">capture1_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL">TCPWM_group07_TROUT_SEL</a></p>
</td>
<td><p>32'h00000334</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out0">out0</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 0. Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH: Compare match 0 event<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7: Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_3">reserved_3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out1">out1</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 1. Default setting selects the compare match 0 event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event<p></p>
0x3 : CC0_MATCH: Compare match 0 event (default selection)<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7 : Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_7">reserved_7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD">TCPWM_group07_TR_CMD</a></p>
</td>
<td><p>32'h00000338</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture0">capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture 0 trigger. When written with '1', a capture 0 trigger<p></p>
is generated and the HW sets the field to '0' when the SW<p></p>
trigger has taken effect. It should be noted that the HW<p></p>
operates on the counter frequency. If the counter is disabled<p></p>
through CTRL.ENABLED, the field is immediately set to '0'.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reserved_1">reserved_1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reload">reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW reload trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_stop">stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW stop trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW start trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture1">capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture1 trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(WOC-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA">TCPWM_group07_INTR_STA</a></p>
</td>
<td><p>32'h0000033C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when a terminal count or DSHOT done is detected, write<p></p>
‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare0 (CC0)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare1 (CC1)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(W-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET">TCPWM_group07_INTR_SET</a></p>
</td>
<td><p>32'h00000340</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK">TCPWM_group07_INTR_MASK</a></p>
</td>
<td><p>32'h00000344</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.tc, when it is set, the counter interrupt<p></p>
will ignore the status of INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc0_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc1_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED">TCPWM_group07_INTR_MASKED</a></p>
</td>
<td><p>32'h00000348</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.tc and INTR_MASK.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc0_match and INTR_MASK.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc1_match and INTR_MASK.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME">TCPWM_group07_DEADTIME</a></p>
</td>
<td><p>32'h0000034C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_out">dt_line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In PWM_DT mode, this field is used to determine dead time before<p></p>
activating the PWM line output signal "line_out": amount of dead<p></p>
time cycles in the counter clock domain.<p></p>
In all other modes, the lower 3 bits of this field determine<p></p>
pre-scaling of the selected counter clock.<p></p>
0x0 : DIVBY1 : Divide by 1 (other-than-PWM_DT mode)<p></p>
0x1 : DIVBY2 : Divide by 2 (other-than-PWM_DT mode)<p></p>
0x2 : DIVBY4 : Divide by 4 (other-than-PWM_DT mode)<p></p>
0x3 : DIVBY8 : Divide by 8 (other-than-PWM_DT mode)<p></p>
0x4 : DIVBY16 : Divide by 16 (other-than-PWM_DT mode)<p></p>
0x5 : DIVBY32 : Divide by 32 (other-than-PWM_DT mode)<p></p>
0x6 : DIVBY64 : Divide by 64 (other-than-PWM_DT mode)<p></p>
0x7 : DIVBY128 : Divide by 128 (other-than-PWM_DT mode)</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_compl_out">dt_line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>in PWM_DT mode, this field is used to determine the dead time<p></p>
before activating the complementary PWM line output signal<p></p>
"line_compl_out": amount of dead time cycles in the counter<p></p>
clock domain.<p></p>
In all other modes, this field has no effect.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL">TCPWM_group07_SEMA_CTRL</a></p>
</td>
<td><p>32'h00000350</p>
</td>
<td><p>there are two semaphores (sema#0 and sema#1) per counter, they<p></p>
are used to synchronize counter operation and descriptor master<p></p>
cfg automation, selected counter signal will be used to set the<p></p>
corresponding semaphore, descriptor SYN command header info<p></p>
SYN.op, SYN.msk_grp and SYN.msk will choose how to unset<p></p>
(clear) semaphore.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema0_sel">sema0_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to set sema#0.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema1_sel">sema1_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to set sema#1.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b7">reserved_b7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS">TCPWM_group07_SEMA_STS</a></p>
</td>
<td><p>32'h00000354</p>
</td>
<td><p>used to indicate two semaphores bit status, both Hardware and<p></p>
Software can access: counter will set semaphore status when the<p></p>
event defined by SEMA_CTRL occurs, SYN descriptor execution with<p></p>
OP code 4’b10 also set semaphore status; semaphore status is<p></p>
cleared when SYN descriptor with OP code 4’b11 is performed;<p></p>
Software can set semaphore status when an early SYN descriptor<p></p>
termination is required, this is useful during debug process.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema0_val">sema0_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#0 status</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema1_val">sema1_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#1 status</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME">TCPWM_group07_DSHOT_FRAME</a></p>
</td>
<td><p>32'h00000358</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME_frame">frame</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT frame 16-bit value<p></p>
[10:0] 11-bit value for throttle command (0~2047)<p></p>
[11] 1-bit flag: 1 telemetry is requested from the drone ESC<p></p>
(Electronic Speed Controller); 0 otherwise<p></p>
[15:12] 4-bit checksum for error detection</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY">TCPWM_group07_DSHOT_DUTY</a></p>
</td>
<td><p>32'h0000035C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_high">high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 1 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “1”</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_low">low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 0 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “0”</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL">TCPWM_group08_CLK_CTRL</a></p>
</td>
<td><p>32'h00000360</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL_clkdiv_sel">clkdiv_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>All TCPWM counter clock (the counter clock before active event<p></p>
and prescaling) (including otrigClk used for counter output<p></p>
triggers) are generated by a group of clock dividers, the<p></p>
number of clock divider is controlled by design parameter<p></p>
CDIVNUM (which is set to 6 by default in design), the clock<p></p>
source for all clock dividers is periClk from SoC.<p></p>
This 4-bit field is used to select the one out of CDIVNUM clock<p></p>
dividers to provide the clock enable signal which is combined<p></p>
with active event and prescaling together to generate the<p></p>
counter’s operation clock in each of TCPWM counter. (otrigClk<p></p>
is only derived from clock divider)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL">TCPWM_group08_CTRL</a></p>
</td>
<td><p>32'h00000364</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc0">auto_reload_cc0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC0 and buffered CC0 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 0 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc1">auto_reload_cc1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC1 and buffered CC1 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 1 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_period">auto_reload_period</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the PERIOD and buffered PERIOD values.<p></p>
This field has a function in PWM and PWM_DT modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.<p></p>
In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to<p></p>
select the index / wrap-around capture function.<p></p>
'0': Captures on index (reload) event. The counter value is<p></p>
copied to the PERIOD register on an index (reload) event.<p></p>
'1': Captures when COUNTER equals 0 or 0xffff. The counter value<p></p>
is copied to the PERIOD register when COUNTER equals 0 or<p></p>
0xffff.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_line_sel">auto_reload_line_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values.<p></p>
This field has a function in PWM and PWM_PR modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_up_en">cc0_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting up<p></p>
'1': compare match 0 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_down_en">cc0_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 0 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_up_en">cc1_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting up<p></p>
'1': compare match 1 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_down_en">cc1_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 1 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_imm_kill">pwm_imm_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the kill event immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals or with the next module<p></p>
clock ("active count" pre-scaled counter clock).<p></p>
'0': synchronous kill activation. Deactivates the "line_out" and<p></p>
"line_compl_out" signals with the next module clock ("active<p></p>
count" pre-scaled counter clock).<p></p>
'1': immediate kill activation. Immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_stop_on_kill">pwm_stop_on_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the counter stops on a kill events:<p></p>
'0': kill event does NOT stop counter.<p></p>
'1': kill event stops counter.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_sync_kill">pwm_sync_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies asynchronous/synchronous kill release behavior:<p></p>
'1': synchronous kill mode: the kill event disables the<p></p>
"line_out" and "line_compl_out" signals till the next terminal<p></p>
count event (synchronous kill). In synchronous kill mode,<p></p>
STOP_EDGE should be NO_EDGE_DET.<p></p>
'0': asynchronous kill mode: the kill event only disables the<p></p>
"line_out" and "line_compl_out" signals when present. In<p></p>
asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET.<p></p>
This field has a function in PWM and PWM_DT modes only. This<p></p>
field is only used when PWM_STOP_ON_KILL is '0'.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b11">reserved_b11</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[13:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_disable_mode">pwm_disable_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the behavior of the PWM outputs "line_out" and<p></p>
"line_compl_out" while the TCPWM counter is disabled<p></p>
(CTL.ENABLED='0') or stopped.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the immediate kill logic and line_out polarity<p></p>
settings (CTRL.QUAD_ENCODING_MODE).<p></p>
0x0 : Z : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are NOT driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the TCPWM output "line_out_en"<p></p>
to 0.<p></p>
When the counter is stopped upon a stop event the PWM outputs<p></p>
are deactivated (to the polarity defined by<p></p>
CTRL.QUAD_ENCODING_MODE).<p></p>
0x1 : RETAIN : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM outputs are retained (keep their previous levels).<p></p>
While the counter is disabled or stopped the PWM outputs can be<p></p>
changed via LINE_SEL.<p></p>
0x2 : L : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '0' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '1'.<p></p>
0x3 : H : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '1' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '0'.</p>
</td>
</tr>
<tr><td><p>[15:14]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b14to15">reserved_b14to15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[17:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_up_down_mode">up_down_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Determines counter direction.<p></p>
In QUAD mode this field acts as QUAD_RANGE_MODE field selecting<p></p>
between different counter range, reload value and compare /<p></p>
capture behavior.<p></p>
0x0 : COUNT_UP : Count up (to PERIOD). An overflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals PERIOD. A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals PERIOD.<p></p>
0x0 : QUAD_RANGE0 : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0 mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- on reload / index event:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- tc and cc0_match events are generated<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- cc0_match event is generated<p></p>
0x1 : COUNT_DOWN : Count down (to "0"). An underflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x1 : QUAD_RANGE0_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0_CMP mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- the capture0 event acts as 2nd reload / index event<p></p>
- on reload / index event:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on index' is selected (AUTO_RELOAD_PERIOD=0):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER is copied to PERIOD<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on wrap-around' is selected<p></p>
(AUTO_RELOAD_PERIOD=1):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to PERIOD<p></p>
- 1 or 2 compare functions (depending on CC1_PRESENT) available<p></p>
Because of that the PERIOD/PERIOD_BUFF registers are used<p></p>
instead of CC0/CC_BUFF registers to capture COUNTER at reload /<p></p>
index event or wrap-around.<p></p>
0x2 : COUNT_UPDN1 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x2 : QUAD_RANGE1_CAPT : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CAPT mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and PERIOD<p></p>
- on reload / index event:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- when COUNTER is 0x0000 and decrementing:<p></p>
- COUNTER is set to PERIOD<p></p>
- tc event is generated<p></p>
- when COUNTER equals PERIOD and is incrementing:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- 1 or 2 capture functions (depending on CC1_PRESENT) available<p></p>
- on capture0 / capture1 event:<p></p>
- CC0 / CC1 is copied to CC0_BUFF / CC1_BUFF<p></p>
- COUNTER value is copied to CC0<p></p>
It allows that the COUNTER register reflects the current angle<p></p>
position of the rotary encoder, i.e. no MOD or SUB calculations<p></p>
need to be done in SW on the COUNTER value to get the current<p></p>
angle position. This allows a DMA copy of the angle position<p></p>
from the COUNTER register. However, a disadvantage of this mode<p></p>
is that fast sequences of tc interrupts can occur (when encoder<p></p>
moves back and forth around start position). It is recommended<p></p>
to not use the tc interrupt in this mode.<p></p>
0x3 : COUNT_UPDN2 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0"<p></p>
AND when the counter changes from a state in which COUNTER<p></p>
equals PERIOD (this counter direction can be used for PWM<p></p>
functionality with asymmetrical updates).<p></p>
0x3 : QUAD_RANGE1_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CMP mode.<p></p>
The behavior is the same as for QUAD_RANGE1_CAPT mode described<p></p>
above with the only difference that 1 or 2 compare functions<p></p>
(depending on CC1_PRESENT) are available instead of 1 or 2<p></p>
capture functions.</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_one_shot">one_shot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter runs continuous. When '1', counter is turned<p></p>
off by hardware when a terminal count event is generated.</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b19">reserved_b19</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[21:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_quad_encoding_mode">quad_encoding_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In QUAD mode this field selects the quadrature encoding mode<p></p>
(X1/X2/X4) or the Up / Down rotary counting mode.<p></p>
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to<p></p>
invert "line_out" and "line_compl_out". Inversion is the last<p></p>
step in generation of "line_out" and "line_compl_out"; i.e. a<p></p>
disabled output line "line_out" has the value<p></p>
QUAD_ENCODING_MODE[0] and a disabled output line<p></p>
"line_compl_out" has the value QUAD_ENCODING_MODE[1].<p></p>
0x0 : X1 : X1 encoding (QUAD mode)<p></p>
This encoding is identical with an up / down counting<p></p>
functionality of the following way: Rising edges of input phiA<p></p>
increment or decrement the counter depending on the state of<p></p>
input phiB (direction input).<p></p>
0x1 : X2 : X2 encoding (QUAD mode)<p></p>
0x1 : INV_OUT : When bit 0 is '1', QUADRATURE_ENCODING_MODE[0]<p></p>
inverts "line_out" (PWM/PWM_DT modes)<p></p>
0x2 : X4 : X4 encoding (QUAD mode)<p></p>
0x2 : INV_COMPL_OUT : When bit 1 is '1',<p></p>
QUADRATURE_ENCODING_MODE[1] inverts "line_compl_out"<p></p>
(PWM/PWM_DT modes)<p></p>
0x3 : UP_DOWN : Up / Down rotary counting mode. Input phiA<p></p>
increments the counter, input phiB decrements the counter. The<p></p>
trigger edge detection settings apply.</p>
</td>
</tr>
<tr><td><p>[23:22]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b22tob23">reserved_b22tob23</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_mode">mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter mode.<p></p>
0x0 : TIMER : Timer mode<p></p>
0x1 : EXT : Extension mode, which is defined in ext_mode[2:0]<p></p>
0x2 : CAPTURE : Capture mode<p></p>
0x3 : QUAD : Quadrature mode<p></p>
Different encoding modes can be selected by QUAD_ENCODING_MODE<p></p>
including up/down count functionality.<p></p>
Different counter range, reload value and capture behavior can<p></p>
be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).<p></p>
0x4 : PWM : Pulse width modulation (PWM) mode<p></p>
0x5 : PWM_DT : PWM with deadtime insertion mode<p></p>
0x6 : PWM_PR : Pseudo random pulse width modulation<p></p>
0x7 : SR : Shift register mode.</p>
</td>
</tr>
<tr><td><p>[29:27]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_ext_mode">ext_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>counter extension mode when mode[2:0] = 0x1<p></p>
0x0: DSHOT mode<p></p>
0x1~0x7: reserved</p>
</td>
</tr>
<tr><td><p>[30:30]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_dbg_freeze_en">dbg_freeze_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the counter behavior in debug mode.<p></p>
'0': The counter operation continues in debug mode.<p></p>
'1': The counter operation freezes in debug mode.</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_enabled">enabled</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter enable.<p></p>
'0': counter disabled.<p></p>
'1': counter enabled.<p></p>
Counter static configuration information (e.g. CTRL.mode, all<p></p>
TRIN_CTRL0/1, TRIN_EDGE_SEL, PWM_CTRL and TROUT_SEL register<p></p>
fields) should only be modified when the counter is disabled.<p></p>
When a counter is disabled, command and status information<p></p>
associated to the counter is cleared by HW, this includes:<p></p>
- the associated counter triggers in the CMD register are set to<p></p>
'0'.<p></p>
- the counter's interrupt cause fields in counter's INTR<p></p>
register.<p></p>
- the counter's status fields in counter's STATUS register..<p></p>
- the counter's trigger outputs ("tr_out0" and tr_out1").<p></p>
- the counter's line outputs ("line_out" and "line_compl_out").</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS">TCPWM_group08_STATUS</a></p>
</td>
<td><p>32'h00000368</p>
</td>
<td><p>When the counter is disabled (CTRL.enabled = 0), then the<p></p>
STATUS.tr_* bit fields are typically reset to their default<p></p>
values. However, there are exceptions possible in the following<p></p>
cases, based on the selected input trigger via TRIN_SEL*.*_sel:<p></p>
- If a constant '0' is selected, then a '0' is read.<p></p>
- If a constant '1' is selected, then a '1' is read.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_down">down</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter is counting up. When '1', counter is counting<p></p>
down. In QUAD mode, this field indicates the direction of the<p></p>
latest counter change: '0' when last incremented and '1' when<p></p>
last decremented.</p>
</td>
</tr>
<tr><td><p>[3:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b1tob3">reserved_b1tob3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture0">tr_capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 0 trigger.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_count">tr_count</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Indicates the actual level of the selected count trigger.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_reload">tr_reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected reload trigger.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_stop">tr_stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected stop trigger.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_start">tr_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected start trigger.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture1">tr_capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_out">line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the PWM line output signal.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_compl_out">line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the complementary PWM line output<p></p>
signal</p>
</td>
</tr>
<tr><td><p>[14:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b12tob14">reserved_b12tob14</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_running">running</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', the counter is NOT running. When '1', the counter is<p></p>
running.<p></p>
This field is used to indicate that the counter is running after<p></p>
a start/reload event and that the counter is stopped after a<p></p>
stop event.<p></p>
When a running counter operation is paused in debug state (see<p></p>
CTRL.dbg_pause) then the RUNNING bit is still '1'.</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_dt_cnt">dt_cnt</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Generic 16-bit counter field. In PWM_DT mode, this counter is<p></p>
used for dead time insertion on PWM line_out<p></p>
In all other modes, this counter is used for pre-scaling the<p></p>
selected counter clock. PWM_DT mode can NOT use prescaled clock<p></p>
functionality.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0">TCPWM_group08_CC0</a></p>
</td>
<td><p>32'h0000036C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_cc0">cc0</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
1. SW reads this register when the counter is enabled<p></p>
(CTRL.enabled = 1) already; or<p></p>
2. SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1">TCPWM_group08_CC1</a></p>
</td>
<td><p>32'h00000370</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_cc1">cc1</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD">TCPWM_group08_PERIOD</a></p>
</td>
<td><p>32'h00000374</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_period">period</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>The maximum value the counter can reach. When the counter is<p></p>
designed to count for n cycles, this field should be set to<p></p>
n-1.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER">TCPWM_group08_COUNTER</a></p>
</td>
<td><p>32'h00000378</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER_val">val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>32-bit counter value. It is advised to not write to the this<p></p>
field when the counter is running.<p></p>
TCPWM counter can only be initialized by software in PWM_PR and<p></p>
SR mode.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL">TCPWM_group08_PWM_CTRL</a></p>
</td>
<td><p>32'h0000037C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc0_match_mode">cc0_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 0 event (COUNTER equals<p></p>
CC0 register) on the "line" output signals. Note that INVERT is<p></p>
especially useful for center aligned pulse width modulation.<p></p>
To generate a duty cycle of 0%, the counter CC0 register should<p></p>
be set to "0". For a 100% duty cycle, the counter CC0 register<p></p>
should be set to larger than the counter PERIOD register.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_overflow_mode">overflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter overflow event (COUNTER<p></p>
reaches PERIOD) on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_underflow_mode">underflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter underflow event (COUNTER<p></p>
reaches "0") on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc1_match_mode">cc1_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 1 event (COUNTER equals<p></p>
CC1 register) on the "line_out" output signals.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL">TCPWM_group08_LINE_SEL</a></p>
</td>
<td><p>32'h00000380</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects the source for the output signal "line_out". Default<p></p>
setting is the PWM signal "line". Other settings are useful for<p></p>
Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_out polarity setting<p></p>
(CTRL.quad_encoding_mode[0]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_out" is not driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the output "line_out_en" to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects the source for the output signal "line_compl_out".<p></p>
Default setting is the inverted PWM signal "line". Other<p></p>
settings are useful for Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_compl_out polarity<p></p>
setting (CTRL.quad_encoding_mode[1]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_compl_out" is not driven by the<p></p>
TCPWM. Instead the port default level configuration applies,<p></p>
e.g. "Z" (high impedance).<p></p>
Note: This is realized by driving the output "line_compl_out_en"<p></p>
to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF">TCPWM_group08_CC0_BUFF</a></p>
</td>
<td><p>32'h00000384</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF_cc0_buff">cc0_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC0 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF">TCPWM_group08_CC1_BUFF</a></p>
</td>
<td><p>32'h00000388</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF_cc1_buff">cc1_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC1 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF">TCPWM_group08_PERIOD_BUFF</a></p>
</td>
<td><p>32'h0000038C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF_period_buff">period_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter PERIOD register.<p></p>
In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit<p></p>
represents a tap of the shift register which can be feed back<p></p>
to the MSB of counter via an XOR tree.<p></p>
Examples for CNTWIDTH = 16:<p></p>
- Maximum length 16bit LFSR<p></p>
- polynomial x^16 + x^14 + x^13 + x^11 + 1<p></p>
- taps 0,2,3,5 - > PERIOD_BUFF = 0x002d<p></p>
- period is 2^16-1 = 65535 cycles<p></p>
- Maximum length 8bit LFSR:<p></p>
- polynomial x^8 + x^6 + x^5 + x^4 + 1<p></p>
- taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)<p></p>
- period is 2^8-1 = 255 cycles<p></p>
In SR mode PERIOD_BUFF defines which tap of the shift register<p></p>
generates the PWM output signals. For a delay of n cycles (from<p></p>
capture event to PWM output) the bit CNT_WIDTH-n should be set<p></p>
to '1'. For a shift register function only one tap should be<p></p>
use, i.e. a one-hot value must be written to PERIOD_BUFF. If<p></p>
multiple bits in PERIOD_BUFF are set then the taps are XOR<p></p>
combined.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF">TCPWM_group08_LINE_SEL_BUFF</a></p>
</td>
<td><p>32'h00000390</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Buffer for LINE_SEL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.out_sel on a terminal count event<p></p>
with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Buffer for LINE_SEL.COMPL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.compl_out_sel on a terminal count<p></p>
event with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0">TCPWM_group08_TRIN_CTRL0</a></p>
</td>
<td><p>32'h00000394</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_capture0_sel">capture0_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the up to 256 input triggers as a capture0<p></p>
trigger. Input trigger 0 is always '0' and input trigger 1 is<p></p>
always '1'.<p></p>
In the PWM, PWM_DT and PWM_PR modes this trigger is used to<p></p>
switch the values of the compare and period registers with<p></p>
their buffer counterparts.</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_count_sel">count_sel</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Selects one of the 256 input triggers as a count trigger.<p></p>
In QUAD mode, this is the first phase (phi A). Default setting<p></p>
selects input trigger 1, which is always '1'.<p></p>
Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the<p></p>
counter is externally triggered ( COUNT_SEL > 1), an external<p></p>
trigger will be required for each TR_CMD to execute. For<p></p>
example, a write to TR_CMD.START will not start the counter<p></p>
until the trigger selected by COUNT_SEL asserts. The next<p></p>
trigger will increment the counter since the counter is now<p></p>
running. This goes for all TR_CMD fields.</p>
</td>
</tr>
<tr><td><p>[23:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_reload_sel">reload_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a reload trigger.<p></p>
In QUAD mode, this is the index or revolution pulse. In these<p></p>
modes, it will update the counter with 0x8000 (counter<p></p>
midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</p>
</td>
</tr>
<tr><td><p>[31:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_stop_sel">stop_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a stop trigger.<p></p>
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In<p></p>
these modes, the kill trigger is used to either temporarily<p></p>
block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the<p></p>
functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT<p></p>
modes, the blocking of the output signals can be asynchronous<p></p>
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is<p></p>
as long as the trigger is '1' or synchronous (STOP_EDGE should<p></p>
be RISING_EDGE) in which case it extends till the next terminal<p></p>
count event.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1">TCPWM_group08_TRIN_CTRL1</a></p>
</td>
<td><p>32'h00000398</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_sel">start_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a start trigger. In<p></p>
QUAD mode, this is the second phase (phi B).</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_sel">capture1_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture0_inv">capture0_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture0 will be inverted before counter usage.</p>
</td>
</tr>
<tr><td><p>[17:17]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_count_inv">count_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger count will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_reload_inv">reload_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger reload will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_stop_inv">stop_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger stop will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[20:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_inv">start_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger start will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[21:21]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_inv">capture1_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture1 will be inverted before counter usage</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL">TCPWM_group08_TRIN_EDGE_SEL</a></p>
</td>
<td><p>32'h0000039C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture0_edge">capture0_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_count_edge">count_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_reload_edge">reload_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_stop_edge">stop_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_start_edge">start_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[11:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture1_edge">capture1_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL">TCPWM_group08_TROUT_SEL</a></p>
</td>
<td><p>32'h000003A0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out0">out0</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 0. Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH: Compare match 0 event<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7: Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_3">reserved_3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out1">out1</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 1. Default setting selects the compare match 0 event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event<p></p>
0x3 : CC0_MATCH: Compare match 0 event (default selection)<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7 : Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_7">reserved_7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD">TCPWM_group08_TR_CMD</a></p>
</td>
<td><p>32'h000003A4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture0">capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture 0 trigger. When written with '1', a capture 0 trigger<p></p>
is generated and the HW sets the field to '0' when the SW<p></p>
trigger has taken effect. It should be noted that the HW<p></p>
operates on the counter frequency. If the counter is disabled<p></p>
through CTRL.ENABLED, the field is immediately set to '0'.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reserved_1">reserved_1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reload">reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW reload trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_stop">stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW stop trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW start trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture1">capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture1 trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(WOC-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA">TCPWM_group08_INTR_STA</a></p>
</td>
<td><p>32'h000003A8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when a terminal count or DSHOT done is detected, write<p></p>
‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare0 (CC0)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare1 (CC1)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(W-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET">TCPWM_group08_INTR_SET</a></p>
</td>
<td><p>32'h000003AC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK">TCPWM_group08_INTR_MASK</a></p>
</td>
<td><p>32'h000003B0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.tc, when it is set, the counter interrupt<p></p>
will ignore the status of INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc0_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc1_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED">TCPWM_group08_INTR_MASKED</a></p>
</td>
<td><p>32'h000003B4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.tc and INTR_MASK.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc0_match and INTR_MASK.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc1_match and INTR_MASK.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME">TCPWM_group08_DEADTIME</a></p>
</td>
<td><p>32'h000003B8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_out">dt_line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In PWM_DT mode, this field is used to determine dead time before<p></p>
activating the PWM line output signal "line_out": amount of dead<p></p>
time cycles in the counter clock domain.<p></p>
In all other modes, the lower 3 bits of this field determine<p></p>
pre-scaling of the selected counter clock.<p></p>
0x0 : DIVBY1 : Divide by 1 (other-than-PWM_DT mode)<p></p>
0x1 : DIVBY2 : Divide by 2 (other-than-PWM_DT mode)<p></p>
0x2 : DIVBY4 : Divide by 4 (other-than-PWM_DT mode)<p></p>
0x3 : DIVBY8 : Divide by 8 (other-than-PWM_DT mode)<p></p>
0x4 : DIVBY16 : Divide by 16 (other-than-PWM_DT mode)<p></p>
0x5 : DIVBY32 : Divide by 32 (other-than-PWM_DT mode)<p></p>
0x6 : DIVBY64 : Divide by 64 (other-than-PWM_DT mode)<p></p>
0x7 : DIVBY128 : Divide by 128 (other-than-PWM_DT mode)</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_compl_out">dt_line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>in PWM_DT mode, this field is used to determine the dead time<p></p>
before activating the complementary PWM line output signal<p></p>
"line_compl_out": amount of dead time cycles in the counter<p></p>
clock domain.<p></p>
In all other modes, this field has no effect.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL">TCPWM_group08_SEMA_CTRL</a></p>
</td>
<td><p>32'h000003BC</p>
</td>
<td><p>there are two semaphores (sema#0 and sema#1) per counter, they<p></p>
are used to synchronize counter operation and descriptor master<p></p>
cfg automation, selected counter signal will be used to set the<p></p>
corresponding semaphore, descriptor SYN command header info<p></p>
SYN.op, SYN.msk_grp and SYN.msk will choose how to unset<p></p>
(clear) semaphore.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema0_sel">sema0_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to set sema#0.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema1_sel">sema1_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to set sema#1.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b7">reserved_b7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS">TCPWM_group08_SEMA_STS</a></p>
</td>
<td><p>32'h000003C0</p>
</td>
<td><p>used to indicate two semaphores bit status, both Hardware and<p></p>
Software can access: counter will set semaphore status when the<p></p>
event defined by SEMA_CTRL occurs, SYN descriptor execution with<p></p>
OP code 4’b10 also set semaphore status; semaphore status is<p></p>
cleared when SYN descriptor with OP code 4’b11 is performed;<p></p>
Software can set semaphore status when an early SYN descriptor<p></p>
termination is required, this is useful during debug process.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema0_val">sema0_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#0 status</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema1_val">sema1_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#1 status</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME">TCPWM_group08_DSHOT_FRAME</a></p>
</td>
<td><p>32'h000003C4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME_frame">frame</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT frame 16-bit value<p></p>
[10:0] 11-bit value for throttle command (0~2047)<p></p>
[11] 1-bit flag: 1 telemetry is requested from the drone ESC<p></p>
(Electronic Speed Controller); 0 otherwise<p></p>
[15:12] 4-bit checksum for error detection</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY">TCPWM_group08_DSHOT_DUTY</a></p>
</td>
<td><p>32'h000003C8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_high">high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 1 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “1”</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_low">low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 0 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “0”</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL">TCPWM_group09_CLK_CTRL</a></p>
</td>
<td><p>32'h000003CC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL_clkdiv_sel">clkdiv_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>All TCPWM counter clock (the counter clock before active event<p></p>
and prescaling) (including otrigClk used for counter output<p></p>
triggers) are generated by a group of clock dividers, the<p></p>
number of clock divider is controlled by design parameter<p></p>
CDIVNUM (which is set to 6 by default in design), the clock<p></p>
source for all clock dividers is periClk from SoC.<p></p>
This 4-bit field is used to select the one out of CDIVNUM clock<p></p>
dividers to provide the clock enable signal which is combined<p></p>
with active event and prescaling together to generate the<p></p>
counter’s operation clock in each of TCPWM counter. (otrigClk<p></p>
is only derived from clock divider)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL">TCPWM_group09_CTRL</a></p>
</td>
<td><p>32'h000003D0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc0">auto_reload_cc0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC0 and buffered CC0 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 0 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc1">auto_reload_cc1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC1 and buffered CC1 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 1 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_period">auto_reload_period</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the PERIOD and buffered PERIOD values.<p></p>
This field has a function in PWM and PWM_DT modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.<p></p>
In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to<p></p>
select the index / wrap-around capture function.<p></p>
'0': Captures on index (reload) event. The counter value is<p></p>
copied to the PERIOD register on an index (reload) event.<p></p>
'1': Captures when COUNTER equals 0 or 0xffff. The counter value<p></p>
is copied to the PERIOD register when COUNTER equals 0 or<p></p>
0xffff.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_line_sel">auto_reload_line_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values.<p></p>
This field has a function in PWM and PWM_PR modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_up_en">cc0_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting up<p></p>
'1': compare match 0 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_down_en">cc0_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 0 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_up_en">cc1_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting up<p></p>
'1': compare match 1 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_down_en">cc1_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 1 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_imm_kill">pwm_imm_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the kill event immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals or with the next module<p></p>
clock ("active count" pre-scaled counter clock).<p></p>
'0': synchronous kill activation. Deactivates the "line_out" and<p></p>
"line_compl_out" signals with the next module clock ("active<p></p>
count" pre-scaled counter clock).<p></p>
'1': immediate kill activation. Immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_stop_on_kill">pwm_stop_on_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the counter stops on a kill events:<p></p>
'0': kill event does NOT stop counter.<p></p>
'1': kill event stops counter.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_sync_kill">pwm_sync_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies asynchronous/synchronous kill release behavior:<p></p>
'1': synchronous kill mode: the kill event disables the<p></p>
"line_out" and "line_compl_out" signals till the next terminal<p></p>
count event (synchronous kill). In synchronous kill mode,<p></p>
STOP_EDGE should be NO_EDGE_DET.<p></p>
'0': asynchronous kill mode: the kill event only disables the<p></p>
"line_out" and "line_compl_out" signals when present. In<p></p>
asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET.<p></p>
This field has a function in PWM and PWM_DT modes only. This<p></p>
field is only used when PWM_STOP_ON_KILL is '0'.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b11">reserved_b11</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[13:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_disable_mode">pwm_disable_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the behavior of the PWM outputs "line_out" and<p></p>
"line_compl_out" while the TCPWM counter is disabled<p></p>
(CTL.ENABLED='0') or stopped.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the immediate kill logic and line_out polarity<p></p>
settings (CTRL.QUAD_ENCODING_MODE).<p></p>
0x0 : Z : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are NOT driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the TCPWM output "line_out_en"<p></p>
to 0.<p></p>
When the counter is stopped upon a stop event the PWM outputs<p></p>
are deactivated (to the polarity defined by<p></p>
CTRL.QUAD_ENCODING_MODE).<p></p>
0x1 : RETAIN : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM outputs are retained (keep their previous levels).<p></p>
While the counter is disabled or stopped the PWM outputs can be<p></p>
changed via LINE_SEL.<p></p>
0x2 : L : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '0' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '1'.<p></p>
0x3 : H : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '1' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '0'.</p>
</td>
</tr>
<tr><td><p>[15:14]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b14to15">reserved_b14to15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[17:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_up_down_mode">up_down_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Determines counter direction.<p></p>
In QUAD mode this field acts as QUAD_RANGE_MODE field selecting<p></p>
between different counter range, reload value and compare /<p></p>
capture behavior.<p></p>
0x0 : COUNT_UP : Count up (to PERIOD). An overflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals PERIOD. A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals PERIOD.<p></p>
0x0 : QUAD_RANGE0 : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0 mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- on reload / index event:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- tc and cc0_match events are generated<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- cc0_match event is generated<p></p>
0x1 : COUNT_DOWN : Count down (to "0"). An underflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x1 : QUAD_RANGE0_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0_CMP mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- the capture0 event acts as 2nd reload / index event<p></p>
- on reload / index event:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on index' is selected (AUTO_RELOAD_PERIOD=0):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER is copied to PERIOD<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on wrap-around' is selected<p></p>
(AUTO_RELOAD_PERIOD=1):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to PERIOD<p></p>
- 1 or 2 compare functions (depending on CC1_PRESENT) available<p></p>
Because of that the PERIOD/PERIOD_BUFF registers are used<p></p>
instead of CC0/CC_BUFF registers to capture COUNTER at reload /<p></p>
index event or wrap-around.<p></p>
0x2 : COUNT_UPDN1 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x2 : QUAD_RANGE1_CAPT : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CAPT mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and PERIOD<p></p>
- on reload / index event:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- when COUNTER is 0x0000 and decrementing:<p></p>
- COUNTER is set to PERIOD<p></p>
- tc event is generated<p></p>
- when COUNTER equals PERIOD and is incrementing:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- 1 or 2 capture functions (depending on CC1_PRESENT) available<p></p>
- on capture0 / capture1 event:<p></p>
- CC0 / CC1 is copied to CC0_BUFF / CC1_BUFF<p></p>
- COUNTER value is copied to CC0<p></p>
It allows that the COUNTER register reflects the current angle<p></p>
position of the rotary encoder, i.e. no MOD or SUB calculations<p></p>
need to be done in SW on the COUNTER value to get the current<p></p>
angle position. This allows a DMA copy of the angle position<p></p>
from the COUNTER register. However, a disadvantage of this mode<p></p>
is that fast sequences of tc interrupts can occur (when encoder<p></p>
moves back and forth around start position). It is recommended<p></p>
to not use the tc interrupt in this mode.<p></p>
0x3 : COUNT_UPDN2 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0"<p></p>
AND when the counter changes from a state in which COUNTER<p></p>
equals PERIOD (this counter direction can be used for PWM<p></p>
functionality with asymmetrical updates).<p></p>
0x3 : QUAD_RANGE1_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CMP mode.<p></p>
The behavior is the same as for QUAD_RANGE1_CAPT mode described<p></p>
above with the only difference that 1 or 2 compare functions<p></p>
(depending on CC1_PRESENT) are available instead of 1 or 2<p></p>
capture functions.</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_one_shot">one_shot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter runs continuous. When '1', counter is turned<p></p>
off by hardware when a terminal count event is generated.</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b19">reserved_b19</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[21:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_quad_encoding_mode">quad_encoding_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In QUAD mode this field selects the quadrature encoding mode<p></p>
(X1/X2/X4) or the Up / Down rotary counting mode.<p></p>
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to<p></p>
invert "line_out" and "line_compl_out". Inversion is the last<p></p>
step in generation of "line_out" and "line_compl_out"; i.e. a<p></p>
disabled output line "line_out" has the value<p></p>
QUAD_ENCODING_MODE[0] and a disabled output line<p></p>
"line_compl_out" has the value QUAD_ENCODING_MODE[1].<p></p>
0x0 : X1 : X1 encoding (QUAD mode)<p></p>
This encoding is identical with an up / down counting<p></p>
functionality of the following way: Rising edges of input phiA<p></p>
increment or decrement the counter depending on the state of<p></p>
input phiB (direction input).<p></p>
0x1 : X2 : X2 encoding (QUAD mode)<p></p>
0x1 : INV_OUT : When bit 0 is '1', QUADRATURE_ENCODING_MODE[0]<p></p>
inverts "line_out" (PWM/PWM_DT modes)<p></p>
0x2 : X4 : X4 encoding (QUAD mode)<p></p>
0x2 : INV_COMPL_OUT : When bit 1 is '1',<p></p>
QUADRATURE_ENCODING_MODE[1] inverts "line_compl_out"<p></p>
(PWM/PWM_DT modes)<p></p>
0x3 : UP_DOWN : Up / Down rotary counting mode. Input phiA<p></p>
increments the counter, input phiB decrements the counter. The<p></p>
trigger edge detection settings apply.</p>
</td>
</tr>
<tr><td><p>[23:22]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b22tob23">reserved_b22tob23</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_mode">mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter mode.<p></p>
0x0 : TIMER : Timer mode<p></p>
0x1 : EXT : Extension mode, which is defined in ext_mode[2:0]<p></p>
0x2 : CAPTURE : Capture mode<p></p>
0x3 : QUAD : Quadrature mode<p></p>
Different encoding modes can be selected by QUAD_ENCODING_MODE<p></p>
including up/down count functionality.<p></p>
Different counter range, reload value and capture behavior can<p></p>
be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).<p></p>
0x4 : PWM : Pulse width modulation (PWM) mode<p></p>
0x5 : PWM_DT : PWM with deadtime insertion mode<p></p>
0x6 : PWM_PR : Pseudo random pulse width modulation<p></p>
0x7 : SR : Shift register mode.</p>
</td>
</tr>
<tr><td><p>[29:27]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_ext_mode">ext_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>counter extension mode when mode[2:0] = 0x1<p></p>
0x0: DSHOT mode<p></p>
0x1~0x7: reserved</p>
</td>
</tr>
<tr><td><p>[30:30]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_dbg_freeze_en">dbg_freeze_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the counter behavior in debug mode.<p></p>
'0': The counter operation continues in debug mode.<p></p>
'1': The counter operation freezes in debug mode.</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_enabled">enabled</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter enable.<p></p>
'0': counter disabled.<p></p>
'1': counter enabled.<p></p>
Counter static configuration information (e.g. CTRL.mode, all<p></p>
TRIN_CTRL0/1, TRIN_EDGE_SEL, PWM_CTRL and TROUT_SEL register<p></p>
fields) should only be modified when the counter is disabled.<p></p>
When a counter is disabled, command and status information<p></p>
associated to the counter is cleared by HW, this includes:<p></p>
- the associated counter triggers in the CMD register are set to<p></p>
'0'.<p></p>
- the counter's interrupt cause fields in counter's INTR<p></p>
register.<p></p>
- the counter's status fields in counter's STATUS register..<p></p>
- the counter's trigger outputs ("tr_out0" and tr_out1").<p></p>
- the counter's line outputs ("line_out" and "line_compl_out").</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS">TCPWM_group09_STATUS</a></p>
</td>
<td><p>32'h000003D4</p>
</td>
<td><p>When the counter is disabled (CTRL.enabled = 0), then the<p></p>
STATUS.tr_* bit fields are typically reset to their default<p></p>
values. However, there are exceptions possible in the following<p></p>
cases, based on the selected input trigger via TRIN_SEL*.*_sel:<p></p>
- If a constant '0' is selected, then a '0' is read.<p></p>
- If a constant '1' is selected, then a '1' is read.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_down">down</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter is counting up. When '1', counter is counting<p></p>
down. In QUAD mode, this field indicates the direction of the<p></p>
latest counter change: '0' when last incremented and '1' when<p></p>
last decremented.</p>
</td>
</tr>
<tr><td><p>[3:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b1tob3">reserved_b1tob3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture0">tr_capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 0 trigger.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_count">tr_count</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Indicates the actual level of the selected count trigger.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_reload">tr_reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected reload trigger.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_stop">tr_stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected stop trigger.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_start">tr_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected start trigger.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture1">tr_capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_out">line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the PWM line output signal.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_compl_out">line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the complementary PWM line output<p></p>
signal</p>
</td>
</tr>
<tr><td><p>[14:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b12tob14">reserved_b12tob14</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_running">running</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', the counter is NOT running. When '1', the counter is<p></p>
running.<p></p>
This field is used to indicate that the counter is running after<p></p>
a start/reload event and that the counter is stopped after a<p></p>
stop event.<p></p>
When a running counter operation is paused in debug state (see<p></p>
CTRL.dbg_pause) then the RUNNING bit is still '1'.</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_dt_cnt">dt_cnt</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Generic 16-bit counter field. In PWM_DT mode, this counter is<p></p>
used for dead time insertion on PWM line_out<p></p>
In all other modes, this counter is used for pre-scaling the<p></p>
selected counter clock. PWM_DT mode can NOT use prescaled clock<p></p>
functionality.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0">TCPWM_group09_CC0</a></p>
</td>
<td><p>32'h000003D8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_cc0">cc0</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
1. SW reads this register when the counter is enabled<p></p>
(CTRL.enabled = 1) already; or<p></p>
2. SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1">TCPWM_group09_CC1</a></p>
</td>
<td><p>32'h000003DC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_cc1">cc1</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD">TCPWM_group09_PERIOD</a></p>
</td>
<td><p>32'h000003E0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_period">period</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>The maximum value the counter can reach. When the counter is<p></p>
designed to count for n cycles, this field should be set to<p></p>
n-1.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER">TCPWM_group09_COUNTER</a></p>
</td>
<td><p>32'h000003E4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER_val">val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>32-bit counter value. It is advised to not write to the this<p></p>
field when the counter is running.<p></p>
TCPWM counter can only be initialized by software in PWM_PR and<p></p>
SR mode.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL">TCPWM_group09_PWM_CTRL</a></p>
</td>
<td><p>32'h000003E8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc0_match_mode">cc0_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 0 event (COUNTER equals<p></p>
CC0 register) on the "line" output signals. Note that INVERT is<p></p>
especially useful for center aligned pulse width modulation.<p></p>
To generate a duty cycle of 0%, the counter CC0 register should<p></p>
be set to "0". For a 100% duty cycle, the counter CC0 register<p></p>
should be set to larger than the counter PERIOD register.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_overflow_mode">overflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter overflow event (COUNTER<p></p>
reaches PERIOD) on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_underflow_mode">underflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter underflow event (COUNTER<p></p>
reaches "0") on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc1_match_mode">cc1_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 1 event (COUNTER equals<p></p>
CC1 register) on the "line_out" output signals.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL">TCPWM_group09_LINE_SEL</a></p>
</td>
<td><p>32'h000003EC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects the source for the output signal "line_out". Default<p></p>
setting is the PWM signal "line". Other settings are useful for<p></p>
Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_out polarity setting<p></p>
(CTRL.quad_encoding_mode[0]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_out" is not driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the output "line_out_en" to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects the source for the output signal "line_compl_out".<p></p>
Default setting is the inverted PWM signal "line". Other<p></p>
settings are useful for Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_compl_out polarity<p></p>
setting (CTRL.quad_encoding_mode[1]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_compl_out" is not driven by the<p></p>
TCPWM. Instead the port default level configuration applies,<p></p>
e.g. "Z" (high impedance).<p></p>
Note: This is realized by driving the output "line_compl_out_en"<p></p>
to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF">TCPWM_group09_CC0_BUFF</a></p>
</td>
<td><p>32'h000003F0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF_cc0_buff">cc0_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC0 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF">TCPWM_group09_CC1_BUFF</a></p>
</td>
<td><p>32'h000003F4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF_cc1_buff">cc1_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC1 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF">TCPWM_group09_PERIOD_BUFF</a></p>
</td>
<td><p>32'h000003F8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF_period_buff">period_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter PERIOD register.<p></p>
In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit<p></p>
represents a tap of the shift register which can be feed back<p></p>
to the MSB of counter via an XOR tree.<p></p>
Examples for CNTWIDTH = 16:<p></p>
- Maximum length 16bit LFSR<p></p>
- polynomial x^16 + x^14 + x^13 + x^11 + 1<p></p>
- taps 0,2,3,5 - > PERIOD_BUFF = 0x002d<p></p>
- period is 2^16-1 = 65535 cycles<p></p>
- Maximum length 8bit LFSR:<p></p>
- polynomial x^8 + x^6 + x^5 + x^4 + 1<p></p>
- taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)<p></p>
- period is 2^8-1 = 255 cycles<p></p>
In SR mode PERIOD_BUFF defines which tap of the shift register<p></p>
generates the PWM output signals. For a delay of n cycles (from<p></p>
capture event to PWM output) the bit CNT_WIDTH-n should be set<p></p>
to '1'. For a shift register function only one tap should be<p></p>
use, i.e. a one-hot value must be written to PERIOD_BUFF. If<p></p>
multiple bits in PERIOD_BUFF are set then the taps are XOR<p></p>
combined.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF">TCPWM_group09_LINE_SEL_BUFF</a></p>
</td>
<td><p>32'h000003FC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Buffer for LINE_SEL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.out_sel on a terminal count event<p></p>
with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Buffer for LINE_SEL.COMPL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.compl_out_sel on a terminal count<p></p>
event with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0">TCPWM_group09_TRIN_CTRL0</a></p>
</td>
<td><p>32'h00000400</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_capture0_sel">capture0_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the up to 256 input triggers as a capture0<p></p>
trigger. Input trigger 0 is always '0' and input trigger 1 is<p></p>
always '1'.<p></p>
In the PWM, PWM_DT and PWM_PR modes this trigger is used to<p></p>
switch the values of the compare and period registers with<p></p>
their buffer counterparts.</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_count_sel">count_sel</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Selects one of the 256 input triggers as a count trigger.<p></p>
In QUAD mode, this is the first phase (phi A). Default setting<p></p>
selects input trigger 1, which is always '1'.<p></p>
Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the<p></p>
counter is externally triggered ( COUNT_SEL > 1), an external<p></p>
trigger will be required for each TR_CMD to execute. For<p></p>
example, a write to TR_CMD.START will not start the counter<p></p>
until the trigger selected by COUNT_SEL asserts. The next<p></p>
trigger will increment the counter since the counter is now<p></p>
running. This goes for all TR_CMD fields.</p>
</td>
</tr>
<tr><td><p>[23:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_reload_sel">reload_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a reload trigger.<p></p>
In QUAD mode, this is the index or revolution pulse. In these<p></p>
modes, it will update the counter with 0x8000 (counter<p></p>
midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</p>
</td>
</tr>
<tr><td><p>[31:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_stop_sel">stop_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a stop trigger.<p></p>
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In<p></p>
these modes, the kill trigger is used to either temporarily<p></p>
block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the<p></p>
functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT<p></p>
modes, the blocking of the output signals can be asynchronous<p></p>
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is<p></p>
as long as the trigger is '1' or synchronous (STOP_EDGE should<p></p>
be RISING_EDGE) in which case it extends till the next terminal<p></p>
count event.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1">TCPWM_group09_TRIN_CTRL1</a></p>
</td>
<td><p>32'h00000404</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_sel">start_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a start trigger. In<p></p>
QUAD mode, this is the second phase (phi B).</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_sel">capture1_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture0_inv">capture0_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture0 will be inverted before counter usage.</p>
</td>
</tr>
<tr><td><p>[17:17]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_count_inv">count_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger count will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_reload_inv">reload_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger reload will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_stop_inv">stop_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger stop will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[20:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_inv">start_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger start will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[21:21]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_inv">capture1_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture1 will be inverted before counter usage</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL">TCPWM_group09_TRIN_EDGE_SEL</a></p>
</td>
<td><p>32'h00000408</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture0_edge">capture0_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_count_edge">count_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_reload_edge">reload_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_stop_edge">stop_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_start_edge">start_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[11:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture1_edge">capture1_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL">TCPWM_group09_TROUT_SEL</a></p>
</td>
<td><p>32'h0000040C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out0">out0</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 0. Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH: Compare match 0 event<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7: Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_3">reserved_3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out1">out1</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 1. Default setting selects the compare match 0 event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event<p></p>
0x3 : CC0_MATCH: Compare match 0 event (default selection)<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7 : Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_7">reserved_7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD">TCPWM_group09_TR_CMD</a></p>
</td>
<td><p>32'h00000410</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture0">capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture 0 trigger. When written with '1', a capture 0 trigger<p></p>
is generated and the HW sets the field to '0' when the SW<p></p>
trigger has taken effect. It should be noted that the HW<p></p>
operates on the counter frequency. If the counter is disabled<p></p>
through CTRL.ENABLED, the field is immediately set to '0'.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reserved_1">reserved_1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reload">reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW reload trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_stop">stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW stop trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW start trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture1">capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture1 trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(WOC-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA">TCPWM_group09_INTR_STA</a></p>
</td>
<td><p>32'h00000414</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when a terminal count or DSHOT done is detected, write<p></p>
‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare0 (CC0)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare1 (CC1)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(W-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET">TCPWM_group09_INTR_SET</a></p>
</td>
<td><p>32'h00000418</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK">TCPWM_group09_INTR_MASK</a></p>
</td>
<td><p>32'h0000041C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.tc, when it is set, the counter interrupt<p></p>
will ignore the status of INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc0_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc1_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED">TCPWM_group09_INTR_MASKED</a></p>
</td>
<td><p>32'h00000420</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.tc and INTR_MASK.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc0_match and INTR_MASK.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc1_match and INTR_MASK.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME">TCPWM_group09_DEADTIME</a></p>
</td>
<td><p>32'h00000424</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_out">dt_line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In PWM_DT mode, this field is used to determine dead time before<p></p>
activating the PWM line output signal "line_out": amount of dead<p></p>
time cycles in the counter clock domain.<p></p>
In all other modes, the lower 3 bits of this field determine<p></p>
pre-scaling of the selected counter clock.<p></p>
0x0 : DIVBY1 : Divide by 1 (other-than-PWM_DT mode)<p></p>
0x1 : DIVBY2 : Divide by 2 (other-than-PWM_DT mode)<p></p>
0x2 : DIVBY4 : Divide by 4 (other-than-PWM_DT mode)<p></p>
0x3 : DIVBY8 : Divide by 8 (other-than-PWM_DT mode)<p></p>
0x4 : DIVBY16 : Divide by 16 (other-than-PWM_DT mode)<p></p>
0x5 : DIVBY32 : Divide by 32 (other-than-PWM_DT mode)<p></p>
0x6 : DIVBY64 : Divide by 64 (other-than-PWM_DT mode)<p></p>
0x7 : DIVBY128 : Divide by 128 (other-than-PWM_DT mode)</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_compl_out">dt_line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>in PWM_DT mode, this field is used to determine the dead time<p></p>
before activating the complementary PWM line output signal<p></p>
"line_compl_out": amount of dead time cycles in the counter<p></p>
clock domain.<p></p>
In all other modes, this field has no effect.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL">TCPWM_group09_SEMA_CTRL</a></p>
</td>
<td><p>32'h00000428</p>
</td>
<td><p>there are two semaphores (sema#0 and sema#1) per counter, they<p></p>
are used to synchronize counter operation and descriptor master<p></p>
cfg automation, selected counter signal will be used to set the<p></p>
corresponding semaphore, descriptor SYN command header info<p></p>
SYN.op, SYN.msk_grp and SYN.msk will choose how to unset<p></p>
(clear) semaphore.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema0_sel">sema0_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to set sema#0.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema1_sel">sema1_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to set sema#1.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b7">reserved_b7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS">TCPWM_group09_SEMA_STS</a></p>
</td>
<td><p>32'h0000042C</p>
</td>
<td><p>used to indicate two semaphores bit status, both Hardware and<p></p>
Software can access: counter will set semaphore status when the<p></p>
event defined by SEMA_CTRL occurs, SYN descriptor execution with<p></p>
OP code 4’b10 also set semaphore status; semaphore status is<p></p>
cleared when SYN descriptor with OP code 4’b11 is performed;<p></p>
Software can set semaphore status when an early SYN descriptor<p></p>
termination is required, this is useful during debug process.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema0_val">sema0_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#0 status</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema1_val">sema1_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#1 status</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME">TCPWM_group09_DSHOT_FRAME</a></p>
</td>
<td><p>32'h00000430</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME_frame">frame</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT frame 16-bit value<p></p>
[10:0] 11-bit value for throttle command (0~2047)<p></p>
[11] 1-bit flag: 1 telemetry is requested from the drone ESC<p></p>
(Electronic Speed Controller); 0 otherwise<p></p>
[15:12] 4-bit checksum for error detection</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY">TCPWM_group09_DSHOT_DUTY</a></p>
</td>
<td><p>32'h00000434</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_high">high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 1 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “1”</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_low">low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 0 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “0”</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL">TCPWM_group010_CLK_CTRL</a></p>
</td>
<td><p>32'h00000438</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL_clkdiv_sel">clkdiv_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>All TCPWM counter clock (the counter clock before active event<p></p>
and prescaling) (including otrigClk used for counter output<p></p>
triggers) are generated by a group of clock dividers, the<p></p>
number of clock divider is controlled by design parameter<p></p>
CDIVNUM (which is set to 6 by default in design), the clock<p></p>
source for all clock dividers is periClk from SoC.<p></p>
This 4-bit field is used to select the one out of CDIVNUM clock<p></p>
dividers to provide the clock enable signal which is combined<p></p>
with active event and prescaling together to generate the<p></p>
counter’s operation clock in each of TCPWM counter. (otrigClk<p></p>
is only derived from clock divider)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL">TCPWM_group010_CTRL</a></p>
</td>
<td><p>32'h0000043C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc0">auto_reload_cc0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC0 and buffered CC0 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 0 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc1">auto_reload_cc1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC1 and buffered CC1 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 1 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_period">auto_reload_period</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the PERIOD and buffered PERIOD values.<p></p>
This field has a function in PWM and PWM_DT modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.<p></p>
In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to<p></p>
select the index / wrap-around capture function.<p></p>
'0': Captures on index (reload) event. The counter value is<p></p>
copied to the PERIOD register on an index (reload) event.<p></p>
'1': Captures when COUNTER equals 0 or 0xffff. The counter value<p></p>
is copied to the PERIOD register when COUNTER equals 0 or<p></p>
0xffff.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_line_sel">auto_reload_line_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values.<p></p>
This field has a function in PWM and PWM_PR modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_up_en">cc0_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting up<p></p>
'1': compare match 0 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_down_en">cc0_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 0 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_up_en">cc1_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting up<p></p>
'1': compare match 1 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_down_en">cc1_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 1 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_imm_kill">pwm_imm_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the kill event immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals or with the next module<p></p>
clock ("active count" pre-scaled counter clock).<p></p>
'0': synchronous kill activation. Deactivates the "line_out" and<p></p>
"line_compl_out" signals with the next module clock ("active<p></p>
count" pre-scaled counter clock).<p></p>
'1': immediate kill activation. Immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_stop_on_kill">pwm_stop_on_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the counter stops on a kill events:<p></p>
'0': kill event does NOT stop counter.<p></p>
'1': kill event stops counter.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_sync_kill">pwm_sync_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies asynchronous/synchronous kill release behavior:<p></p>
'1': synchronous kill mode: the kill event disables the<p></p>
"line_out" and "line_compl_out" signals till the next terminal<p></p>
count event (synchronous kill). In synchronous kill mode,<p></p>
STOP_EDGE should be NO_EDGE_DET.<p></p>
'0': asynchronous kill mode: the kill event only disables the<p></p>
"line_out" and "line_compl_out" signals when present. In<p></p>
asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET.<p></p>
This field has a function in PWM and PWM_DT modes only. This<p></p>
field is only used when PWM_STOP_ON_KILL is '0'.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b11">reserved_b11</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[13:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_disable_mode">pwm_disable_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the behavior of the PWM outputs "line_out" and<p></p>
"line_compl_out" while the TCPWM counter is disabled<p></p>
(CTL.ENABLED='0') or stopped.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the immediate kill logic and line_out polarity<p></p>
settings (CTRL.QUAD_ENCODING_MODE).<p></p>
0x0 : Z : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are NOT driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the TCPWM output "line_out_en"<p></p>
to 0.<p></p>
When the counter is stopped upon a stop event the PWM outputs<p></p>
are deactivated (to the polarity defined by<p></p>
CTRL.QUAD_ENCODING_MODE).<p></p>
0x1 : RETAIN : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM outputs are retained (keep their previous levels).<p></p>
While the counter is disabled or stopped the PWM outputs can be<p></p>
changed via LINE_SEL.<p></p>
0x2 : L : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '0' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '1'.<p></p>
0x3 : H : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '1' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '0'.</p>
</td>
</tr>
<tr><td><p>[15:14]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b14to15">reserved_b14to15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[17:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_up_down_mode">up_down_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Determines counter direction.<p></p>
In QUAD mode this field acts as QUAD_RANGE_MODE field selecting<p></p>
between different counter range, reload value and compare /<p></p>
capture behavior.<p></p>
0x0 : COUNT_UP : Count up (to PERIOD). An overflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals PERIOD. A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals PERIOD.<p></p>
0x0 : QUAD_RANGE0 : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0 mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- on reload / index event:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- tc and cc0_match events are generated<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- cc0_match event is generated<p></p>
0x1 : COUNT_DOWN : Count down (to "0"). An underflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x1 : QUAD_RANGE0_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0_CMP mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- the capture0 event acts as 2nd reload / index event<p></p>
- on reload / index event:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on index' is selected (AUTO_RELOAD_PERIOD=0):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER is copied to PERIOD<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on wrap-around' is selected<p></p>
(AUTO_RELOAD_PERIOD=1):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to PERIOD<p></p>
- 1 or 2 compare functions (depending on CC1_PRESENT) available<p></p>
Because of that the PERIOD/PERIOD_BUFF registers are used<p></p>
instead of CC0/CC_BUFF registers to capture COUNTER at reload /<p></p>
index event or wrap-around.<p></p>
0x2 : COUNT_UPDN1 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x2 : QUAD_RANGE1_CAPT : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CAPT mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and PERIOD<p></p>
- on reload / index event:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- when COUNTER is 0x0000 and decrementing:<p></p>
- COUNTER is set to PERIOD<p></p>
- tc event is generated<p></p>
- when COUNTER equals PERIOD and is incrementing:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- 1 or 2 capture functions (depending on CC1_PRESENT) available<p></p>
- on capture0 / capture1 event:<p></p>
- CC0 / CC1 is copied to CC0_BUFF / CC1_BUFF<p></p>
- COUNTER value is copied to CC0<p></p>
It allows that the COUNTER register reflects the current angle<p></p>
position of the rotary encoder, i.e. no MOD or SUB calculations<p></p>
need to be done in SW on the COUNTER value to get the current<p></p>
angle position. This allows a DMA copy of the angle position<p></p>
from the COUNTER register. However, a disadvantage of this mode<p></p>
is that fast sequences of tc interrupts can occur (when encoder<p></p>
moves back and forth around start position). It is recommended<p></p>
to not use the tc interrupt in this mode.<p></p>
0x3 : COUNT_UPDN2 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0"<p></p>
AND when the counter changes from a state in which COUNTER<p></p>
equals PERIOD (this counter direction can be used for PWM<p></p>
functionality with asymmetrical updates).<p></p>
0x3 : QUAD_RANGE1_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CMP mode.<p></p>
The behavior is the same as for QUAD_RANGE1_CAPT mode described<p></p>
above with the only difference that 1 or 2 compare functions<p></p>
(depending on CC1_PRESENT) are available instead of 1 or 2<p></p>
capture functions.</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_one_shot">one_shot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter runs continuous. When '1', counter is turned<p></p>
off by hardware when a terminal count event is generated.</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b19">reserved_b19</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[21:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_quad_encoding_mode">quad_encoding_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In QUAD mode this field selects the quadrature encoding mode<p></p>
(X1/X2/X4) or the Up / Down rotary counting mode.<p></p>
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to<p></p>
invert "line_out" and "line_compl_out". Inversion is the last<p></p>
step in generation of "line_out" and "line_compl_out"; i.e. a<p></p>
disabled output line "line_out" has the value<p></p>
QUAD_ENCODING_MODE[0] and a disabled output line<p></p>
"line_compl_out" has the value QUAD_ENCODING_MODE[1].<p></p>
0x0 : X1 : X1 encoding (QUAD mode)<p></p>
This encoding is identical with an up / down counting<p></p>
functionality of the following way: Rising edges of input phiA<p></p>
increment or decrement the counter depending on the state of<p></p>
input phiB (direction input).<p></p>
0x1 : X2 : X2 encoding (QUAD mode)<p></p>
0x1 : INV_OUT : When bit 0 is '1', QUADRATURE_ENCODING_MODE[0]<p></p>
inverts "line_out" (PWM/PWM_DT modes)<p></p>
0x2 : X4 : X4 encoding (QUAD mode)<p></p>
0x2 : INV_COMPL_OUT : When bit 1 is '1',<p></p>
QUADRATURE_ENCODING_MODE[1] inverts "line_compl_out"<p></p>
(PWM/PWM_DT modes)<p></p>
0x3 : UP_DOWN : Up / Down rotary counting mode. Input phiA<p></p>
increments the counter, input phiB decrements the counter. The<p></p>
trigger edge detection settings apply.</p>
</td>
</tr>
<tr><td><p>[23:22]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b22tob23">reserved_b22tob23</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_mode">mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter mode.<p></p>
0x0 : TIMER : Timer mode<p></p>
0x1 : EXT : Extension mode, which is defined in ext_mode[2:0]<p></p>
0x2 : CAPTURE : Capture mode<p></p>
0x3 : QUAD : Quadrature mode<p></p>
Different encoding modes can be selected by QUAD_ENCODING_MODE<p></p>
including up/down count functionality.<p></p>
Different counter range, reload value and capture behavior can<p></p>
be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).<p></p>
0x4 : PWM : Pulse width modulation (PWM) mode<p></p>
0x5 : PWM_DT : PWM with deadtime insertion mode<p></p>
0x6 : PWM_PR : Pseudo random pulse width modulation<p></p>
0x7 : SR : Shift register mode.</p>
</td>
</tr>
<tr><td><p>[29:27]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_ext_mode">ext_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>counter extension mode when mode[2:0] = 0x1<p></p>
0x0: DSHOT mode<p></p>
0x1~0x7: reserved</p>
</td>
</tr>
<tr><td><p>[30:30]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_dbg_freeze_en">dbg_freeze_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the counter behavior in debug mode.<p></p>
'0': The counter operation continues in debug mode.<p></p>
'1': The counter operation freezes in debug mode.</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_enabled">enabled</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter enable.<p></p>
'0': counter disabled.<p></p>
'1': counter enabled.<p></p>
Counter static configuration information (e.g. CTRL.mode, all<p></p>
TRIN_CTRL0/1, TRIN_EDGE_SEL, PWM_CTRL and TROUT_SEL register<p></p>
fields) should only be modified when the counter is disabled.<p></p>
When a counter is disabled, command and status information<p></p>
associated to the counter is cleared by HW, this includes:<p></p>
- the associated counter triggers in the CMD register are set to<p></p>
'0'.<p></p>
- the counter's interrupt cause fields in counter's INTR<p></p>
register.<p></p>
- the counter's status fields in counter's STATUS register..<p></p>
- the counter's trigger outputs ("tr_out0" and tr_out1").<p></p>
- the counter's line outputs ("line_out" and "line_compl_out").</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS">TCPWM_group010_STATUS</a></p>
</td>
<td><p>32'h00000440</p>
</td>
<td><p>When the counter is disabled (CTRL.enabled = 0), then the<p></p>
STATUS.tr_* bit fields are typically reset to their default<p></p>
values. However, there are exceptions possible in the following<p></p>
cases, based on the selected input trigger via TRIN_SEL*.*_sel:<p></p>
- If a constant '0' is selected, then a '0' is read.<p></p>
- If a constant '1' is selected, then a '1' is read.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_down">down</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter is counting up. When '1', counter is counting<p></p>
down. In QUAD mode, this field indicates the direction of the<p></p>
latest counter change: '0' when last incremented and '1' when<p></p>
last decremented.</p>
</td>
</tr>
<tr><td><p>[3:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b1tob3">reserved_b1tob3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture0">tr_capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 0 trigger.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_count">tr_count</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Indicates the actual level of the selected count trigger.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_reload">tr_reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected reload trigger.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_stop">tr_stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected stop trigger.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_start">tr_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected start trigger.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture1">tr_capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_out">line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the PWM line output signal.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_compl_out">line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the complementary PWM line output<p></p>
signal</p>
</td>
</tr>
<tr><td><p>[14:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b12tob14">reserved_b12tob14</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_running">running</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', the counter is NOT running. When '1', the counter is<p></p>
running.<p></p>
This field is used to indicate that the counter is running after<p></p>
a start/reload event and that the counter is stopped after a<p></p>
stop event.<p></p>
When a running counter operation is paused in debug state (see<p></p>
CTRL.dbg_pause) then the RUNNING bit is still '1'.</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_dt_cnt">dt_cnt</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Generic 16-bit counter field. In PWM_DT mode, this counter is<p></p>
used for dead time insertion on PWM line_out<p></p>
In all other modes, this counter is used for pre-scaling the<p></p>
selected counter clock. PWM_DT mode can NOT use prescaled clock<p></p>
functionality.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0">TCPWM_group010_CC0</a></p>
</td>
<td><p>32'h00000444</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_cc0">cc0</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
1. SW reads this register when the counter is enabled<p></p>
(CTRL.enabled = 1) already; or<p></p>
2. SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1">TCPWM_group010_CC1</a></p>
</td>
<td><p>32'h00000448</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_cc1">cc1</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD">TCPWM_group010_PERIOD</a></p>
</td>
<td><p>32'h0000044C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_period">period</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>The maximum value the counter can reach. When the counter is<p></p>
designed to count for n cycles, this field should be set to<p></p>
n-1.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER">TCPWM_group010_COUNTER</a></p>
</td>
<td><p>32'h00000450</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER_val">val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>32-bit counter value. It is advised to not write to the this<p></p>
field when the counter is running.<p></p>
TCPWM counter can only be initialized by software in PWM_PR and<p></p>
SR mode.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL">TCPWM_group010_PWM_CTRL</a></p>
</td>
<td><p>32'h00000454</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc0_match_mode">cc0_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 0 event (COUNTER equals<p></p>
CC0 register) on the "line" output signals. Note that INVERT is<p></p>
especially useful for center aligned pulse width modulation.<p></p>
To generate a duty cycle of 0%, the counter CC0 register should<p></p>
be set to "0". For a 100% duty cycle, the counter CC0 register<p></p>
should be set to larger than the counter PERIOD register.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_overflow_mode">overflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter overflow event (COUNTER<p></p>
reaches PERIOD) on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_underflow_mode">underflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter underflow event (COUNTER<p></p>
reaches "0") on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc1_match_mode">cc1_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 1 event (COUNTER equals<p></p>
CC1 register) on the "line_out" output signals.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL">TCPWM_group010_LINE_SEL</a></p>
</td>
<td><p>32'h00000458</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects the source for the output signal "line_out". Default<p></p>
setting is the PWM signal "line". Other settings are useful for<p></p>
Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_out polarity setting<p></p>
(CTRL.quad_encoding_mode[0]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_out" is not driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the output "line_out_en" to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects the source for the output signal "line_compl_out".<p></p>
Default setting is the inverted PWM signal "line". Other<p></p>
settings are useful for Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_compl_out polarity<p></p>
setting (CTRL.quad_encoding_mode[1]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_compl_out" is not driven by the<p></p>
TCPWM. Instead the port default level configuration applies,<p></p>
e.g. "Z" (high impedance).<p></p>
Note: This is realized by driving the output "line_compl_out_en"<p></p>
to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF">TCPWM_group010_CC0_BUFF</a></p>
</td>
<td><p>32'h0000045C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF_cc0_buff">cc0_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC0 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF">TCPWM_group010_CC1_BUFF</a></p>
</td>
<td><p>32'h00000460</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF_cc1_buff">cc1_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC1 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF">TCPWM_group010_PERIOD_BUFF</a></p>
</td>
<td><p>32'h00000464</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF_period_buff">period_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter PERIOD register.<p></p>
In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit<p></p>
represents a tap of the shift register which can be feed back<p></p>
to the MSB of counter via an XOR tree.<p></p>
Examples for CNTWIDTH = 16:<p></p>
- Maximum length 16bit LFSR<p></p>
- polynomial x^16 + x^14 + x^13 + x^11 + 1<p></p>
- taps 0,2,3,5 - > PERIOD_BUFF = 0x002d<p></p>
- period is 2^16-1 = 65535 cycles<p></p>
- Maximum length 8bit LFSR:<p></p>
- polynomial x^8 + x^6 + x^5 + x^4 + 1<p></p>
- taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)<p></p>
- period is 2^8-1 = 255 cycles<p></p>
In SR mode PERIOD_BUFF defines which tap of the shift register<p></p>
generates the PWM output signals. For a delay of n cycles (from<p></p>
capture event to PWM output) the bit CNT_WIDTH-n should be set<p></p>
to '1'. For a shift register function only one tap should be<p></p>
use, i.e. a one-hot value must be written to PERIOD_BUFF. If<p></p>
multiple bits in PERIOD_BUFF are set then the taps are XOR<p></p>
combined.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF">TCPWM_group010_LINE_SEL_BUFF</a></p>
</td>
<td><p>32'h00000468</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Buffer for LINE_SEL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.out_sel on a terminal count event<p></p>
with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Buffer for LINE_SEL.COMPL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.compl_out_sel on a terminal count<p></p>
event with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0">TCPWM_group010_TRIN_CTRL0</a></p>
</td>
<td><p>32'h0000046C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_capture0_sel">capture0_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the up to 256 input triggers as a capture0<p></p>
trigger. Input trigger 0 is always '0' and input trigger 1 is<p></p>
always '1'.<p></p>
In the PWM, PWM_DT and PWM_PR modes this trigger is used to<p></p>
switch the values of the compare and period registers with<p></p>
their buffer counterparts.</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_count_sel">count_sel</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Selects one of the 256 input triggers as a count trigger.<p></p>
In QUAD mode, this is the first phase (phi A). Default setting<p></p>
selects input trigger 1, which is always '1'.<p></p>
Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the<p></p>
counter is externally triggered ( COUNT_SEL > 1), an external<p></p>
trigger will be required for each TR_CMD to execute. For<p></p>
example, a write to TR_CMD.START will not start the counter<p></p>
until the trigger selected by COUNT_SEL asserts. The next<p></p>
trigger will increment the counter since the counter is now<p></p>
running. This goes for all TR_CMD fields.</p>
</td>
</tr>
<tr><td><p>[23:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_reload_sel">reload_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a reload trigger.<p></p>
In QUAD mode, this is the index or revolution pulse. In these<p></p>
modes, it will update the counter with 0x8000 (counter<p></p>
midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</p>
</td>
</tr>
<tr><td><p>[31:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_stop_sel">stop_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a stop trigger.<p></p>
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In<p></p>
these modes, the kill trigger is used to either temporarily<p></p>
block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the<p></p>
functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT<p></p>
modes, the blocking of the output signals can be asynchronous<p></p>
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is<p></p>
as long as the trigger is '1' or synchronous (STOP_EDGE should<p></p>
be RISING_EDGE) in which case it extends till the next terminal<p></p>
count event.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1">TCPWM_group010_TRIN_CTRL1</a></p>
</td>
<td><p>32'h00000470</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_sel">start_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a start trigger. In<p></p>
QUAD mode, this is the second phase (phi B).</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_sel">capture1_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture0_inv">capture0_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture0 will be inverted before counter usage.</p>
</td>
</tr>
<tr><td><p>[17:17]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_count_inv">count_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger count will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_reload_inv">reload_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger reload will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_stop_inv">stop_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger stop will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[20:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_inv">start_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger start will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[21:21]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_inv">capture1_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture1 will be inverted before counter usage</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL">TCPWM_group010_TRIN_EDGE_SEL</a></p>
</td>
<td><p>32'h00000474</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture0_edge">capture0_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_count_edge">count_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_reload_edge">reload_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_stop_edge">stop_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_start_edge">start_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[11:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture1_edge">capture1_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL">TCPWM_group010_TROUT_SEL</a></p>
</td>
<td><p>32'h00000478</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out0">out0</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 0. Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH: Compare match 0 event<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7: Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_3">reserved_3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out1">out1</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 1. Default setting selects the compare match 0 event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event<p></p>
0x3 : CC0_MATCH: Compare match 0 event (default selection)<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7 : Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_7">reserved_7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD">TCPWM_group010_TR_CMD</a></p>
</td>
<td><p>32'h0000047C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture0">capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture 0 trigger. When written with '1', a capture 0 trigger<p></p>
is generated and the HW sets the field to '0' when the SW<p></p>
trigger has taken effect. It should be noted that the HW<p></p>
operates on the counter frequency. If the counter is disabled<p></p>
through CTRL.ENABLED, the field is immediately set to '0'.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reserved_1">reserved_1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reload">reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW reload trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_stop">stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW stop trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW start trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture1">capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture1 trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(WOC-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA">TCPWM_group010_INTR_STA</a></p>
</td>
<td><p>32'h00000480</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when a terminal count or DSHOT done is detected, write<p></p>
‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare0 (CC0)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare1 (CC1)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(W-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET">TCPWM_group010_INTR_SET</a></p>
</td>
<td><p>32'h00000484</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK">TCPWM_group010_INTR_MASK</a></p>
</td>
<td><p>32'h00000488</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.tc, when it is set, the counter interrupt<p></p>
will ignore the status of INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc0_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc1_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED">TCPWM_group010_INTR_MASKED</a></p>
</td>
<td><p>32'h0000048C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.tc and INTR_MASK.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc0_match and INTR_MASK.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc1_match and INTR_MASK.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME">TCPWM_group010_DEADTIME</a></p>
</td>
<td><p>32'h00000490</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_out">dt_line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In PWM_DT mode, this field is used to determine dead time before<p></p>
activating the PWM line output signal "line_out": amount of dead<p></p>
time cycles in the counter clock domain.<p></p>
In all other modes, the lower 3 bits of this field determine<p></p>
pre-scaling of the selected counter clock.<p></p>
0x0 : DIVBY1 : Divide by 1 (other-than-PWM_DT mode)<p></p>
0x1 : DIVBY2 : Divide by 2 (other-than-PWM_DT mode)<p></p>
0x2 : DIVBY4 : Divide by 4 (other-than-PWM_DT mode)<p></p>
0x3 : DIVBY8 : Divide by 8 (other-than-PWM_DT mode)<p></p>
0x4 : DIVBY16 : Divide by 16 (other-than-PWM_DT mode)<p></p>
0x5 : DIVBY32 : Divide by 32 (other-than-PWM_DT mode)<p></p>
0x6 : DIVBY64 : Divide by 64 (other-than-PWM_DT mode)<p></p>
0x7 : DIVBY128 : Divide by 128 (other-than-PWM_DT mode)</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_compl_out">dt_line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>in PWM_DT mode, this field is used to determine the dead time<p></p>
before activating the complementary PWM line output signal<p></p>
"line_compl_out": amount of dead time cycles in the counter<p></p>
clock domain.<p></p>
In all other modes, this field has no effect.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL">TCPWM_group010_SEMA_CTRL</a></p>
</td>
<td><p>32'h00000494</p>
</td>
<td><p>there are two semaphores (sema#0 and sema#1) per counter, they<p></p>
are used to synchronize counter operation and descriptor master<p></p>
cfg automation, selected counter signal will be used to set the<p></p>
corresponding semaphore, descriptor SYN command header info<p></p>
SYN.op, SYN.msk_grp and SYN.msk will choose how to unset<p></p>
(clear) semaphore.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema0_sel">sema0_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to set sema#0.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema1_sel">sema1_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to set sema#1.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b7">reserved_b7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS">TCPWM_group010_SEMA_STS</a></p>
</td>
<td><p>32'h00000498</p>
</td>
<td><p>used to indicate two semaphores bit status, both Hardware and<p></p>
Software can access: counter will set semaphore status when the<p></p>
event defined by SEMA_CTRL occurs, SYN descriptor execution with<p></p>
OP code 4’b10 also set semaphore status; semaphore status is<p></p>
cleared when SYN descriptor with OP code 4’b11 is performed;<p></p>
Software can set semaphore status when an early SYN descriptor<p></p>
termination is required, this is useful during debug process.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema0_val">sema0_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#0 status</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema1_val">sema1_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#1 status</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME">TCPWM_group010_DSHOT_FRAME</a></p>
</td>
<td><p>32'h0000049C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME_frame">frame</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT frame 16-bit value<p></p>
[10:0] 11-bit value for throttle command (0~2047)<p></p>
[11] 1-bit flag: 1 telemetry is requested from the drone ESC<p></p>
(Electronic Speed Controller); 0 otherwise<p></p>
[15:12] 4-bit checksum for error detection</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY">TCPWM_group010_DSHOT_DUTY</a></p>
</td>
<td><p>32'h000004A0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_high">high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 1 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “1”</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_low">low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 0 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “0”</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL">TCPWM_group011_CLK_CTRL</a></p>
</td>
<td><p>32'h000004A4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CLK_CTRL_clkdiv_sel">clkdiv_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>All TCPWM counter clock (the counter clock before active event<p></p>
and prescaling) (including otrigClk used for counter output<p></p>
triggers) are generated by a group of clock dividers, the<p></p>
number of clock divider is controlled by design parameter<p></p>
CDIVNUM (which is set to 6 by default in design), the clock<p></p>
source for all clock dividers is periClk from SoC.<p></p>
This 4-bit field is used to select the one out of CDIVNUM clock<p></p>
dividers to provide the clock enable signal which is combined<p></p>
with active event and prescaling together to generate the<p></p>
counter’s operation clock in each of TCPWM counter. (otrigClk<p></p>
is only derived from clock divider)</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL">TCPWM_group011_CTRL</a></p>
</td>
<td><p>32'h000004A8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc0">auto_reload_cc0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC0 and buffered CC0 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 0 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_cc1">auto_reload_cc1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the CC1 and buffered CC1 values. This<p></p>
field has a function in TIMER, QUAD (QUAD_RANGE0_CMP,<p></p>
QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.<p></p>
Timer, QUAD, SR modes:<p></p>
'0': never switch.<p></p>
'1': switch on a compare match 1 event.<p></p>
PWM, PWM_DT, PWM_PR modes:<p></p>
'0: never switch.<p></p>
'1': switch on a terminal count event with an actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_period">auto_reload_period</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the PERIOD and buffered PERIOD values.<p></p>
This field has a function in PWM and PWM_DT modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.<p></p>
In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to<p></p>
select the index / wrap-around capture function.<p></p>
'0': Captures on index (reload) event. The counter value is<p></p>
copied to the PERIOD register on an index (reload) event.<p></p>
'1': Captures when COUNTER equals 0 or 0xffff. The counter value<p></p>
is copied to the PERIOD register when COUNTER equals 0 or<p></p>
0xffff.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_auto_reload_line_sel">auto_reload_line_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values.<p></p>
This field has a function in PWM and PWM_PR modes.<p></p>
'0': never switch.<p></p>
'1': switch on a terminal count event with and actively pending<p></p>
switch event.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_up_en">cc0_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting up<p></p>
'1': compare match 0 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc0_match_down_en">cc0_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 0 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 0 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 0 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_up_en">cc1_match_up_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting up (STATUS.DOWN = 0) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting up<p></p>
'1': compare match 1 event generation enabled when counting up<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_cc1_match_down_en">cc1_match_down_en</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Enables / disables the compare match 1 event generation (COUNTER<p></p>
equals CC0 register) when counting down (STATUS.DOWN = 1) in<p></p>
CNT_UPDN1/2 mode.<p></p>
'0': compare match 1 event generation disabled when counting<p></p>
down<p></p>
'1': compare match 1 event generation enabled when counting down<p></p>
This field has a function in PWM and PWM_DT modes only.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_imm_kill">pwm_imm_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the kill event immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals or with the next module<p></p>
clock ("active count" pre-scaled counter clock).<p></p>
'0': synchronous kill activation. Deactivates the "line_out" and<p></p>
"line_compl_out" signals with the next module clock ("active<p></p>
count" pre-scaled counter clock).<p></p>
'1': immediate kill activation. Immediately deactivates the<p></p>
"line_out" and "line_compl_out" signals.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_stop_on_kill">pwm_stop_on_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies whether the counter stops on a kill events:<p></p>
'0': kill event does NOT stop counter.<p></p>
'1': kill event stops counter.<p></p>
This field has a function in PWM, PWM_DT and PWM_PR modes only.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_sync_kill">pwm_sync_kill</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies asynchronous/synchronous kill release behavior:<p></p>
'1': synchronous kill mode: the kill event disables the<p></p>
"line_out" and "line_compl_out" signals till the next terminal<p></p>
count event (synchronous kill). In synchronous kill mode,<p></p>
STOP_EDGE should be NO_EDGE_DET.<p></p>
'0': asynchronous kill mode: the kill event only disables the<p></p>
"line_out" and "line_compl_out" signals when present. In<p></p>
asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET.<p></p>
This field has a function in PWM and PWM_DT modes only. This<p></p>
field is only used when PWM_STOP_ON_KILL is '0'.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b11">reserved_b11</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[13:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_pwm_disable_mode">pwm_disable_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the behavior of the PWM outputs "line_out" and<p></p>
"line_compl_out" while the TCPWM counter is disabled<p></p>
(CTL.ENABLED='0') or stopped.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the immediate kill logic and line_out polarity<p></p>
settings (CTRL.QUAD_ENCODING_MODE).<p></p>
0x0 : Z : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are NOT driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the TCPWM output "line_out_en"<p></p>
to 0.<p></p>
When the counter is stopped upon a stop event the PWM outputs<p></p>
are deactivated (to the polarity defined by<p></p>
CTRL.QUAD_ENCODING_MODE).<p></p>
0x1 : RETAIN : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM outputs are retained (keep their previous levels).<p></p>
While the counter is disabled or stopped the PWM outputs can be<p></p>
changed via LINE_SEL.<p></p>
0x2 : L : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '0' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '1'.<p></p>
0x3 : H : When the counter is disabled the PWM outputs<p></p>
"line_out" and "line_compl_out" are driven by the TCPWM.<p></p>
When the counter is disabled or stopped upon a stop event the<p></p>
PWM output "line_out" is driven as a fixed '1' and the PWM<p></p>
output "line_compl_out" is driven as a fixed '0'.</p>
</td>
</tr>
<tr><td><p>[15:14]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b14to15">reserved_b14to15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[17:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_up_down_mode">up_down_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Determines counter direction.<p></p>
In QUAD mode this field acts as QUAD_RANGE_MODE field selecting<p></p>
between different counter range, reload value and compare /<p></p>
capture behavior.<p></p>
0x0 : COUNT_UP : Count up (to PERIOD). An overflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals PERIOD. A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals PERIOD.<p></p>
0x0 : QUAD_RANGE0 : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0 mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- on reload / index event:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- tc and cc0_match events are generated<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- CC0 is copied to CC0_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to CC0<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- cc0_match event is generated<p></p>
0x1 : COUNT_DOWN : Count down (to "0"). An underflow event is<p></p>
generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x1 : QUAD_RANGE0_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE0_CMP mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and 0xFFFF / 0xFFFFFFFF (for<p></p>
CNTWIDTH = 16 / 32)<p></p>
- the capture0 event acts as 2nd reload / index event<p></p>
- on reload / index event:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on index' is selected (AUTO_RELOAD_PERIOD=0):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER is copied to PERIOD<p></p>
- when COUNTER is 0x0000 or 0xFFFF / 0xFFFFFFFF:<p></p>
- COUNTER is set to midpoint (0x8000 / 0x80000000)<p></p>
- when 'capture on wrap-around' is selected<p></p>
(AUTO_RELOAD_PERIOD=1):<p></p>
- tc event is generated<p></p>
- PERIOD is copied to PERIOD_BUFF<p></p>
- COUNTER (0x0000 or 0xFFFF / 0xFFFFFFFF) is copied to PERIOD<p></p>
- 1 or 2 compare functions (depending on CC1_PRESENT) available<p></p>
Because of that the PERIOD/PERIOD_BUFF registers are used<p></p>
instead of CC0/CC_BUFF registers to capture COUNTER at reload /<p></p>
index event or wrap-around.<p></p>
0x2 : COUNT_UPDN1 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0".<p></p>
0x2 : QUAD_RANGE1_CAPT : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CAPT mode with the following behavior:<p></p>
- COUNTER range is between 0x0000 and PERIOD<p></p>
- on reload / index event:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- when COUNTER is 0x0000 and decrementing:<p></p>
- COUNTER is set to PERIOD<p></p>
- tc event is generated<p></p>
- when COUNTER equals PERIOD and is incrementing:<p></p>
- COUNTER is set to 0x0000<p></p>
- tc event is generated<p></p>
- 1 or 2 capture functions (depending on CC1_PRESENT) available<p></p>
- on capture0 / capture1 event:<p></p>
- CC0 / CC1 is copied to CC0_BUFF / CC1_BUFF<p></p>
- COUNTER value is copied to CC0<p></p>
It allows that the COUNTER register reflects the current angle<p></p>
position of the rotary encoder, i.e. no MOD or SUB calculations<p></p>
need to be done in SW on the COUNTER value to get the current<p></p>
angle position. This allows a DMA copy of the angle position<p></p>
from the COUNTER register. However, a disadvantage of this mode<p></p>
is that fast sequences of tc interrupts can occur (when encoder<p></p>
moves back and forth around start position). It is recommended<p></p>
to not use the tc interrupt in this mode.<p></p>
0x3 : COUNT_UPDN2 : Count up (to PERIOD), then count down (to<p></p>
"0"). An overflow event is generated when the counter changes<p></p>
from a state in which COUNTER equals PERIOD. An underflow event<p></p>
is generated when the counter changes from a state in which<p></p>
COUNTER equals "0". A terminal count event is generated when<p></p>
the counter changes from a state in which COUNTER equals "0"<p></p>
AND when the counter changes from a state in which COUNTER<p></p>
equals PERIOD (this counter direction can be used for PWM<p></p>
functionality with asymmetrical updates).<p></p>
0x3 : QUAD_RANGE1_CMP : In QUAD mode this setting selects the<p></p>
QUAD_RANGE1_CMP mode.<p></p>
The behavior is the same as for QUAD_RANGE1_CAPT mode described<p></p>
above with the only difference that 1 or 2 compare functions<p></p>
(depending on CC1_PRESENT) are available instead of 1 or 2<p></p>
capture functions.</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_one_shot">one_shot</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter runs continuous. When '1', counter is turned<p></p>
off by hardware when a terminal count event is generated.</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b19">reserved_b19</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[21:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_quad_encoding_mode">quad_encoding_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In QUAD mode this field selects the quadrature encoding mode<p></p>
(X1/X2/X4) or the Up / Down rotary counting mode.<p></p>
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to<p></p>
invert "line_out" and "line_compl_out". Inversion is the last<p></p>
step in generation of "line_out" and "line_compl_out"; i.e. a<p></p>
disabled output line "line_out" has the value<p></p>
QUAD_ENCODING_MODE[0] and a disabled output line<p></p>
"line_compl_out" has the value QUAD_ENCODING_MODE[1].<p></p>
0x0 : X1 : X1 encoding (QUAD mode)<p></p>
This encoding is identical with an up / down counting<p></p>
functionality of the following way: Rising edges of input phiA<p></p>
increment or decrement the counter depending on the state of<p></p>
input phiB (direction input).<p></p>
0x1 : X2 : X2 encoding (QUAD mode)<p></p>
0x1 : INV_OUT : When bit 0 is '1', QUADRATURE_ENCODING_MODE[0]<p></p>
inverts "line_out" (PWM/PWM_DT modes)<p></p>
0x2 : X4 : X4 encoding (QUAD mode)<p></p>
0x2 : INV_COMPL_OUT : When bit 1 is '1',<p></p>
QUADRATURE_ENCODING_MODE[1] inverts "line_compl_out"<p></p>
(PWM/PWM_DT modes)<p></p>
0x3 : UP_DOWN : Up / Down rotary counting mode. Input phiA<p></p>
increments the counter, input phiB decrements the counter. The<p></p>
trigger edge detection settings apply.</p>
</td>
</tr>
<tr><td><p>[23:22]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_reserved_b22tob23">reserved_b22tob23</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_mode">mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter mode.<p></p>
0x0 : TIMER : Timer mode<p></p>
0x1 : EXT : Extension mode, which is defined in ext_mode[2:0]<p></p>
0x2 : CAPTURE : Capture mode<p></p>
0x3 : QUAD : Quadrature mode<p></p>
Different encoding modes can be selected by QUAD_ENCODING_MODE<p></p>
including up/down count functionality.<p></p>
Different counter range, reload value and capture behavior can<p></p>
be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).<p></p>
0x4 : PWM : Pulse width modulation (PWM) mode<p></p>
0x5 : PWM_DT : PWM with deadtime insertion mode<p></p>
0x6 : PWM_PR : Pseudo random pulse width modulation<p></p>
0x7 : SR : Shift register mode.</p>
</td>
</tr>
<tr><td><p>[29:27]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_ext_mode">ext_mode</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>counter extension mode when mode[2:0] = 0x1<p></p>
0x0: DSHOT mode<p></p>
0x1~0x7: reserved</p>
</td>
</tr>
<tr><td><p>[30:30]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_dbg_freeze_en">dbg_freeze_en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Specifies the counter behavior in debug mode.<p></p>
'0': The counter operation continues in debug mode.<p></p>
'1': The counter operation freezes in debug mode.</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CTRL_enabled">enabled</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Counter enable.<p></p>
'0': counter disabled.<p></p>
'1': counter enabled.<p></p>
Counter static configuration information (e.g. CTRL.mode, all<p></p>
TRIN_CTRL0/1, TRIN_EDGE_SEL, PWM_CTRL and TROUT_SEL register<p></p>
fields) should only be modified when the counter is disabled.<p></p>
When a counter is disabled, command and status information<p></p>
associated to the counter is cleared by HW, this includes:<p></p>
- the associated counter triggers in the CMD register are set to<p></p>
'0'.<p></p>
- the counter's interrupt cause fields in counter's INTR<p></p>
register.<p></p>
- the counter's status fields in counter's STATUS register..<p></p>
- the counter's trigger outputs ("tr_out0" and tr_out1").<p></p>
- the counter's line outputs ("line_out" and "line_compl_out").</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS">TCPWM_group011_STATUS</a></p>
</td>
<td><p>32'h000004AC</p>
</td>
<td><p>When the counter is disabled (CTRL.enabled = 0), then the<p></p>
STATUS.tr_* bit fields are typically reset to their default<p></p>
values. However, there are exceptions possible in the following<p></p>
cases, based on the selected input trigger via TRIN_SEL*.*_sel:<p></p>
- If a constant '0' is selected, then a '0' is read.<p></p>
- If a constant '1' is selected, then a '1' is read.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_down">down</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', counter is counting up. When '1', counter is counting<p></p>
down. In QUAD mode, this field indicates the direction of the<p></p>
latest counter change: '0' when last incremented and '1' when<p></p>
last decremented.</p>
</td>
</tr>
<tr><td><p>[3:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b1tob3">reserved_b1tob3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture0">tr_capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 0 trigger.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_count">tr_count</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Indicates the actual level of the selected count trigger.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_reload">tr_reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected reload trigger.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_stop">tr_stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected stop trigger.</p>
</td>
</tr>
<tr><td><p>[8:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_start">tr_start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected start trigger.</p>
</td>
</tr>
<tr><td><p>[9:9]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_tr_capture1">tr_capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the selected capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[10:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_out">line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the PWM line output signal.</p>
</td>
</tr>
<tr><td><p>[11:11]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_line_compl_out">line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicates the actual level of the complementary PWM line output<p></p>
signal</p>
</td>
</tr>
<tr><td><p>[14:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_reserved_b12tob14">reserved_b12tob14</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[15:15]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_running">running</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>When '0', the counter is NOT running. When '1', the counter is<p></p>
running.<p></p>
This field is used to indicate that the counter is running after<p></p>
a start/reload event and that the counter is stopped after a<p></p>
stop event.<p></p>
When a running counter operation is paused in debug state (see<p></p>
CTRL.dbg_pause) then the RUNNING bit is still '1'.</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_STATUS_dt_cnt">dt_cnt</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Generic 16-bit counter field. In PWM_DT mode, this counter is<p></p>
used for dead time insertion on PWM line_out<p></p>
In all other modes, this counter is used for pre-scaling the<p></p>
selected counter clock. PWM_DT mode can NOT use prescaled clock<p></p>
functionality.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0">TCPWM_group011_CC0</a></p>
</td>
<td><p>32'h000004B0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_cc0">cc0</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
1. SW reads this register when the counter is enabled<p></p>
(CTRL.enabled = 1) already; or<p></p>
2. SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1">TCPWM_group011_CC1</a></p>
</td>
<td><p>32'h000004B4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_cc1">cc1</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>In CAPTURE mode, captures the counter value. In other modes,<p></p>
compared to counter value.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD">TCPWM_group011_PERIOD</a></p>
</td>
<td><p>32'h000004B8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_period">period</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>The maximum value the counter can reach. When the counter is<p></p>
designed to count for n cycles, this field should be set to<p></p>
n-1.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER">TCPWM_group011_COUNTER</a></p>
</td>
<td><p>32'h000004BC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_COUNTER_val">val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>32-bit counter value. It is advised to not write to the this<p></p>
field when the counter is running.<p></p>
TCPWM counter can only be initialized by software in PWM_PR and<p></p>
SR mode.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL">TCPWM_group011_PWM_CTRL</a></p>
</td>
<td><p>32'h000004C0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc0_match_mode">cc0_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 0 event (COUNTER equals<p></p>
CC0 register) on the "line" output signals. Note that INVERT is<p></p>
especially useful for center aligned pulse width modulation.<p></p>
To generate a duty cycle of 0%, the counter CC0 register should<p></p>
be set to "0". For a 100% duty cycle, the counter CC0 register<p></p>
should be set to larger than the counter PERIOD register.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_overflow_mode">overflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter overflow event (COUNTER<p></p>
reaches PERIOD) on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_underflow_mode">underflow_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a counter underflow event (COUNTER<p></p>
reaches "0") on the "line_out" output signals.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PWM_CTRL_cc1_match_mode">cc1_match_mode</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Determines the effect of a compare match 1 event (COUNTER equals<p></p>
CC1 register) on the "line_out" output signals.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL">TCPWM_group011_LINE_SEL</a></p>
</td>
<td><p>32'h000004C4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects the source for the output signal "line_out". Default<p></p>
setting is the PWM signal "line". Other settings are useful for<p></p>
Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_out polarity setting<p></p>
(CTRL.quad_encoding_mode[0]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_out" is not driven by the TCPWM.<p></p>
Instead the port default level configuration applies, e.g. "Z"<p></p>
(high impedance).<p></p>
Note: This is realized by driving the output "line_out_en" to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects the source for the output signal "line_compl_out".<p></p>
Default setting is the inverted PWM signal "line". Other<p></p>
settings are useful for Stepper Motor Control.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: The output signal of this selection can be further<p></p>
modified by the stop / kill logic and line_compl_out polarity<p></p>
setting (CTRL.quad_encoding_mode[1]).<p></p>
0x0 : L : fixed '0'<p></p>
0x1 : H : fixed '1'<p></p>
0x2 : PWM : PWM signal "line"<p></p>
0x3 : PWM_INV : inverted PWM signal "line"<p></p>
0x4 : Z : The output "line_compl_out" is not driven by the<p></p>
TCPWM. Instead the port default level configuration applies,<p></p>
e.g. "Z" (high impedance).<p></p>
Note: This is realized by driving the output "line_compl_out_en"<p></p>
to 0.<p></p>
0x5 : Reserved5 : This setting is reserved. Do not use.<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7 : Reserved7 : This setting is reserved. Do not use.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF">TCPWM_group011_CC0_BUFF</a></p>
</td>
<td><p>32'h000004C8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC0_BUFF_cc0_buff">cc0_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC0 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF">TCPWM_group011_CC1_BUFF</a></p>
</td>
<td><p>32'h000004CC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_CC1_BUFF_cc1_buff">cc1_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter CC1 register<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF">TCPWM_group011_PERIOD_BUFF</a></p>
</td>
<td><p>32'h000004D0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_PERIOD_BUFF_period_buff">period_buff</a></p>
</td>
<td><p>0xFFFFFFFF</p>
</td>
<td><p>Additional buffer for counter PERIOD register.<p></p>
In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit<p></p>
represents a tap of the shift register which can be feed back<p></p>
to the MSB of counter via an XOR tree.<p></p>
Examples for CNTWIDTH = 16:<p></p>
- Maximum length 16bit LFSR<p></p>
- polynomial x^16 + x^14 + x^13 + x^11 + 1<p></p>
- taps 0,2,3,5 - > PERIOD_BUFF = 0x002d<p></p>
- period is 2^16-1 = 65535 cycles<p></p>
- Maximum length 8bit LFSR:<p></p>
- polynomial x^8 + x^6 + x^5 + x^4 + 1<p></p>
- taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)<p></p>
- period is 2^8-1 = 255 cycles<p></p>
In SR mode PERIOD_BUFF defines which tap of the shift register<p></p>
generates the PWM output signals. For a delay of n cycles (from<p></p>
capture event to PWM output) the bit CNT_WIDTH-n should be set<p></p>
to '1'. For a shift register function only one tap should be<p></p>
use, i.e. a one-hot value must be written to PERIOD_BUFF. If<p></p>
multiple bits in PERIOD_BUFF are set then the taps are XOR<p></p>
combined.<p></p>
Note1: TCPWM counter also updates (writes) this register with<p></p>
the internal real value used by counting operation for SW’s<p></p>
purpose under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;<p></p>
Note2: if TCPWM counter is configured as a 16-bit counter, this<p></p>
register has bit [15:0] valid only, bit [31:16] is not used.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF">TCPWM_group011_LINE_SEL_BUFF</a></p>
</td>
<td><p>32'h000004D4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_out_sel">out_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Buffer for LINE_SEL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.out_sel on a terminal count event<p></p>
with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_LINE_SEL_BUFF_compl_out_sel">compl_out_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Buffer for LINE_SEL.COMPL.OUT_SEL.<p></p>
Can be exchanged with LINE_SEL.compl_out_sel on a terminal count<p></p>
event with an actively pending switch event.<p></p>
This field has a function in PWM and PWM_PR modes only.<p></p>
Note: TCPWM counter also updates (writes) this register with the<p></p>
internal real value used by counting operation for SW’s purpose<p></p>
under any one of the following conditions:<p></p>
SW reads this register when the counter is enabled (CTRL.enabled<p></p>
= 1) already; or<p></p>
SW disables counter by setting CRTL.enable to 0 from 1;</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0">TCPWM_group011_TRIN_CTRL0</a></p>
</td>
<td><p>32'h000004D8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_capture0_sel">capture0_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the up to 256 input triggers as a capture0<p></p>
trigger. Input trigger 0 is always '0' and input trigger 1 is<p></p>
always '1'.<p></p>
In the PWM, PWM_DT and PWM_PR modes this trigger is used to<p></p>
switch the values of the compare and period registers with<p></p>
their buffer counterparts.</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_count_sel">count_sel</a></p>
</td>
<td><p>0x1</p>
</td>
<td><p>Selects one of the 256 input triggers as a count trigger.<p></p>
In QUAD mode, this is the first phase (phi A). Default setting<p></p>
selects input trigger 1, which is always '1'.<p></p>
Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the<p></p>
counter is externally triggered ( COUNT_SEL > 1), an external<p></p>
trigger will be required for each TR_CMD to execute. For<p></p>
example, a write to TR_CMD.START will not start the counter<p></p>
until the trigger selected by COUNT_SEL asserts. The next<p></p>
trigger will increment the counter since the counter is now<p></p>
running. This goes for all TR_CMD fields.</p>
</td>
</tr>
<tr><td><p>[23:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_reload_sel">reload_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a reload trigger.<p></p>
In QUAD mode, this is the index or revolution pulse. In these<p></p>
modes, it will update the counter with 0x8000 (counter<p></p>
midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</p>
</td>
</tr>
<tr><td><p>[31:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL0_stop_sel">stop_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a stop trigger.<p></p>
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In<p></p>
these modes, the kill trigger is used to either temporarily<p></p>
block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the<p></p>
functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT<p></p>
modes, the blocking of the output signals can be asynchronous<p></p>
(STOP_EDGE should be NO_EDGE_DET) in which case the blocking is<p></p>
as long as the trigger is '1' or synchronous (STOP_EDGE should<p></p>
be RISING_EDGE) in which case it extends till the next terminal<p></p>
count event.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1">TCPWM_group011_TRIN_CTRL1</a></p>
</td>
<td><p>32'h000004DC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[7:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_sel">start_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a start trigger. In<p></p>
QUAD mode, this is the second phase (phi B).</p>
</td>
</tr>
<tr><td><p>[15:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_sel">capture1_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Selects one of the 256 input triggers as a capture 1 trigger.</p>
</td>
</tr>
<tr><td><p>[16:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture0_inv">capture0_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture0 will be inverted before counter usage.</p>
</td>
</tr>
<tr><td><p>[17:17]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_count_inv">count_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger count will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[18:18]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_reload_inv">reload_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger reload will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[19:19]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_stop_inv">stop_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger stop will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[20:20]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_start_inv">start_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger start will be inverted before counter usage</p>
</td>
</tr>
<tr><td><p>[21:21]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_CTRL1_capture1_inv">capture1_inv</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Input trigger capture1 will be inverted before counter usage</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL">TCPWM_group011_TRIN_EDGE_SEL</a></p>
</td>
<td><p>32'h000004E0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[1:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture0_edge">capture0_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[3:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_count_edge">count_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[5:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_reload_edge">reload_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[7:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_stop_edge">stop_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[9:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_start_edge">start_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
<tr><td><p>[11:10]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TRIN_EDGE_SEL_capture1_edge">capture1_edge</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>0x0: RISING_EDGE, any rising edge generates an event.<p></p>
0x1: FALLING_EDGE, any falling edge generates an event.<p></p>
0x2: ANY_EDGE, any odd amount of edges generates an event.<p></p>
0x3: NO_EDGE_DET, no edge detection, use trigger as is.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL">TCPWM_group011_TROUT_SEL</a></p>
</td>
<td><p>32'h000004E4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out0">out0</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 0. Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH: Compare match 0 event<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7: Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_3">reserved_3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_out1">out1</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to generate the output<p></p>
trigger 1. Default setting selects the compare match 0 event.<p></p>
0x0 : OVERFLOW: Overflow event<p></p>
0x1 : UNDERFLOW: Underflow event<p></p>
0x2 : TC: Terminal count event<p></p>
0x3 : CC0_MATCH: Compare match 0 event (default selection)<p></p>
0x4 : CC1_MATCH: Compare match 1 event<p></p>
0x5 : LINE_OUT: PWM output signal "line_out"<p></p>
0x6 : Reserved6: This setting is reserved. Do not use.<p></p>
0x7 : Disabled: Output trigger disabled.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TROUT_SEL_reserved_7">reserved_7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD">TCPWM_group011_TR_CMD</a></p>
</td>
<td><p>32'h000004E8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture0">capture0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture 0 trigger. When written with '1', a capture 0 trigger<p></p>
is generated and the HW sets the field to '0' when the SW<p></p>
trigger has taken effect. It should be noted that the HW<p></p>
operates on the counter frequency. If the counter is disabled<p></p>
through CTRL.ENABLED, the field is immediately set to '0'.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reserved_1">reserved_1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_reload">reload</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW reload trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_stop">stop</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW stop trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_start">start</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW start trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_TR_CMD_capture1">capture1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW capture1 trigger. For HW behavior, see capture0 field.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(WOC-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA">TCPWM_group011_INTR_STA</a></p>
</td>
<td><p>32'h000004EC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when a terminal count or DSHOT done is detected, write<p></p>
‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare0 (CC0)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_STA_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Set to 1 when the counter value matches capture/compare1 (CC1)<p></p>
register value, write ‘1’ to clear this bit</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(W-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET">TCPWM_group011_INTR_SET</a></p>
</td>
<td><p>32'h000004F0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_SET_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Write with ‘1’ to set INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK">TCPWM_group011_INTR_MASK</a></p>
</td>
<td><p>32'h000004F4</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.tc, when it is set, the counter interrupt<p></p>
will ignore the status of INTR_STA.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc0_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASK_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for INTR_STA.cc1_match, when it is set, the counter<p></p>
interrupt will ignore the status of INTR_STA.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED">TCPWM_group011_INTR_MASKED</a></p>
</td>
<td><p>32'h000004F8</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_tc">tc</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.tc and INTR_MASK.tc</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc0_match">cc0_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc0_match and INTR_MASK.cc0_match</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_INTR_MASKED_cc1_match">cc1_match</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Logical AND of INTR_STA.cc1_match and INTR_MASK.cc1_match</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME">TCPWM_group011_DEADTIME</a></p>
</td>
<td><p>32'h000004FC</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_out">dt_line_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>In PWM_DT mode, this field is used to determine dead time before<p></p>
activating the PWM line output signal "line_out": amount of dead<p></p>
time cycles in the counter clock domain.<p></p>
In all other modes, the lower 3 bits of this field determine<p></p>
pre-scaling of the selected counter clock.<p></p>
0x0 : DIVBY1 : Divide by 1 (other-than-PWM_DT mode)<p></p>
0x1 : DIVBY2 : Divide by 2 (other-than-PWM_DT mode)<p></p>
0x2 : DIVBY4 : Divide by 4 (other-than-PWM_DT mode)<p></p>
0x3 : DIVBY8 : Divide by 8 (other-than-PWM_DT mode)<p></p>
0x4 : DIVBY16 : Divide by 16 (other-than-PWM_DT mode)<p></p>
0x5 : DIVBY32 : Divide by 32 (other-than-PWM_DT mode)<p></p>
0x6 : DIVBY64 : Divide by 64 (other-than-PWM_DT mode)<p></p>
0x7 : DIVBY128 : Divide by 128 (other-than-PWM_DT mode)</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DEADTIME_dt_line_compl_out">dt_line_compl_out</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>in PWM_DT mode, this field is used to determine the dead time<p></p>
before activating the complementary PWM line output signal<p></p>
"line_compl_out": amount of dead time cycles in the counter<p></p>
clock domain.<p></p>
In all other modes, this field has no effect.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL">TCPWM_group011_SEMA_CTRL</a></p>
</td>
<td><p>32'h00000500</p>
</td>
<td><p>there are two semaphores (sema#0 and sema#1) per counter, they<p></p>
are used to synchronize counter operation and descriptor master<p></p>
cfg automation, selected counter signal will be used to set the<p></p>
corresponding semaphore, descriptor SYN command header info<p></p>
SYN.op, SYN.msk_grp and SYN.msk will choose how to unset<p></p>
(clear) semaphore.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[2:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema0_sel">sema0_sel</a></p>
</td>
<td><p>0x2</p>
</td>
<td><p>Selects one of the internal events to set sema#0.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b3">reserved_b3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[6:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_sema1_sel">sema1_sel</a></p>
</td>
<td><p>0x3</p>
</td>
<td><p>Selects one of the internal events to set sema#1.<p></p>
Default setting selects the terminal count event.<p></p>
0x0 : OVERFLOW : Overflow event<p></p>
0x1 : UNDERFLOW : Underflow event<p></p>
0x2 : TC : Terminal count event (default selection)<p></p>
0x3 : CC0_MATCH : Compare match 0 event<p></p>
0x4 : CC1_MATCH : Compare match 1 event<p></p>
0x5 : LINE_OUT : PWM output signal "line_out"<p></p>
0x6 : Reserved6 : This setting is reserved. Do not use.<p></p>
0x7: Disabled : no event is selected (0 is selected)</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_CTRL_reserved_b7">reserved_b7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS">TCPWM_group011_SEMA_STS</a></p>
</td>
<td><p>32'h00000504</p>
</td>
<td><p>used to indicate two semaphores bit status, both Hardware and<p></p>
Software can access: counter will set semaphore status when the<p></p>
event defined by SEMA_CTRL occurs, SYN descriptor execution with<p></p>
OP code 4’b10 also set semaphore status; semaphore status is<p></p>
cleared when SYN descriptor with OP code 4’b11 is performed;<p></p>
Software can set semaphore status when an early SYN descriptor<p></p>
termination is required, this is useful during debug process.</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema0_val">sema0_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#0 status</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_SEMA_STS_sema1_val">sema1_val</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Indicate sema#1 status</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME">TCPWM_group011_DSHOT_FRAME</a></p>
</td>
<td><p>32'h00000508</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_FRAME_frame">frame</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT frame 16-bit value<p></p>
[10:0] 11-bit value for throttle command (0~2047)<p></p>
[11] 1-bit flag: 1 telemetry is requested from the drone ESC<p></p>
(Electronic Speed Controller); 0 otherwise<p></p>
[15:12] 4-bit checksum for error detection</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY">TCPWM_group011_DSHOT_DUTY</a></p>
</td>
<td><p>32'h0000050C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[15:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_high">high</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 1 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “1”</p>
</td>
</tr>
<tr><td><p>[31:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#counter_DSHOT_DUTY_low">low</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>DSHOT bit value 0 duty, used to decide clock cycle number of<p></p>
DSHOT pulse high during a DSHOT bit period when DSHOT bit is<p></p>
encoded as “0”</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL">TCPWM_cntclk0_DIVCTRL</a></p>
</td>
<td><p>32'h00000510</p>
</td>
<td><p>counter clock divider, array size is matched with HW parameter<p></p>
CDIVNUM</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[23:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL_int_div">int_div</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Integer division by (1+int_div). Allows for integer divisions in<p></p>
the range [1, 16,777,216]. Note: combined with fractional<p></p>
division, this divider type allows for a division in the range<p></p>
[1, 16,777,216 31/32] in 1/32 increments.</p>
</td>
</tr>
<tr><td><p>[28:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL_fra_div">fra_div</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Fractional division by (fra_div/32). Allows for fractional<p></p>
divisions in the range [0, 31/32]. Note that fractional<p></p>
division results in clock jitter as some clock periods may be 1<p></p>
"periClk" cycle longer than other clock periods.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVSTS">TCPWM_cntclk0_DIVSTS</a></p>
</td>
<td><p>32'h00000514</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVSTS_en">en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Divider enabled. HW sets this field to '1' as a result of an<p></p>
command from DIV_CMD.enable. HW sets this field to '0' as a<p></p>
result on a DIV_CMD.disable command.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL">TCPWM_cntclk1_DIVCTRL</a></p>
</td>
<td><p>32'h00000518</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[23:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL_int_div">int_div</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Integer division by (1+int_div). Allows for integer divisions in<p></p>
the range [1, 16,777,216]. Note: combined with fractional<p></p>
division, this divider type allows for a division in the range<p></p>
[1, 16,777,216 31/32] in 1/32 increments.</p>
</td>
</tr>
<tr><td><p>[28:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL_fra_div">fra_div</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Fractional division by (fra_div/32). Allows for fractional<p></p>
divisions in the range [0, 31/32]. Note that fractional<p></p>
division results in clock jitter as some clock periods may be 1<p></p>
"periClk" cycle longer than other clock periods.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVSTS">TCPWM_cntclk1_DIVSTS</a></p>
</td>
<td><p>32'h0000051C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVSTS_en">en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Divider enabled. HW sets this field to '1' as a result of an<p></p>
command from DIV_CMD.enable. HW sets this field to '0' as a<p></p>
result on a DIV_CMD.disable command.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL">TCPWM_cntclk2_DIVCTRL</a></p>
</td>
<td><p>32'h00000520</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[23:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL_int_div">int_div</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Integer division by (1+int_div). Allows for integer divisions in<p></p>
the range [1, 16,777,216]. Note: combined with fractional<p></p>
division, this divider type allows for a division in the range<p></p>
[1, 16,777,216 31/32] in 1/32 increments.</p>
</td>
</tr>
<tr><td><p>[28:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL_fra_div">fra_div</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Fractional division by (fra_div/32). Allows for fractional<p></p>
divisions in the range [0, 31/32]. Note that fractional<p></p>
division results in clock jitter as some clock periods may be 1<p></p>
"periClk" cycle longer than other clock periods.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVSTS">TCPWM_cntclk2_DIVSTS</a></p>
</td>
<td><p>32'h00000524</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVSTS_en">en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Divider enabled. HW sets this field to '1' as a result of an<p></p>
command from DIV_CMD.enable. HW sets this field to '0' as a<p></p>
result on a DIV_CMD.disable command.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL">TCPWM_cntclk3_DIVCTRL</a></p>
</td>
<td><p>32'h00000528</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[23:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL_int_div">int_div</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Integer division by (1+int_div). Allows for integer divisions in<p></p>
the range [1, 16,777,216]. Note: combined with fractional<p></p>
division, this divider type allows for a division in the range<p></p>
[1, 16,777,216 31/32] in 1/32 increments.</p>
</td>
</tr>
<tr><td><p>[28:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL_fra_div">fra_div</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Fractional division by (fra_div/32). Allows for fractional<p></p>
divisions in the range [0, 31/32]. Note that fractional<p></p>
division results in clock jitter as some clock periods may be 1<p></p>
"periClk" cycle longer than other clock periods.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVSTS">TCPWM_cntclk3_DIVSTS</a></p>
</td>
<td><p>32'h0000052C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVSTS_en">en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Divider enabled. HW sets this field to '1' as a result of an<p></p>
command from DIV_CMD.enable. HW sets this field to '0' as a<p></p>
result on a DIV_CMD.disable command.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL">TCPWM_cntclk4_DIVCTRL</a></p>
</td>
<td><p>32'h00000530</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[23:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL_int_div">int_div</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Integer division by (1+int_div). Allows for integer divisions in<p></p>
the range [1, 16,777,216]. Note: combined with fractional<p></p>
division, this divider type allows for a division in the range<p></p>
[1, 16,777,216 31/32] in 1/32 increments.</p>
</td>
</tr>
<tr><td><p>[28:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL_fra_div">fra_div</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Fractional division by (fra_div/32). Allows for fractional<p></p>
divisions in the range [0, 31/32]. Note that fractional<p></p>
division results in clock jitter as some clock periods may be 1<p></p>
"periClk" cycle longer than other clock periods.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVSTS">TCPWM_cntclk4_DIVSTS</a></p>
</td>
<td><p>32'h00000534</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVSTS_en">en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Divider enabled. HW sets this field to '1' as a result of an<p></p>
command from DIV_CMD.enable. HW sets this field to '0' as a<p></p>
result on a DIV_CMD.disable command.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL">TCPWM_cntclk5_DIVCTRL</a></p>
</td>
<td><p>32'h00000538</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[23:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL_int_div">int_div</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Integer division by (1+int_div). Allows for integer divisions in<p></p>
the range [1, 16,777,216]. Note: combined with fractional<p></p>
division, this divider type allows for a division in the range<p></p>
[1, 16,777,216 31/32] in 1/32 increments.</p>
</td>
</tr>
<tr><td><p>[28:24]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVCTRL_fra_div">fra_div</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Fractional division by (fra_div/32). Allows for fractional<p></p>
divisions in the range [0, 31/32]. Note that fractional<p></p>
division results in clock jitter as some clock periods may be 1<p></p>
"periClk" cycle longer than other clock periods.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVSTS">TCPWM_cntclk5_DIVSTS</a></p>
</td>
<td><p>32'h0000053C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#CLKDIV_DIVSTS_en">en</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Divider enabled. HW sets this field to '1' as a result of an<p></p>
command from DIV_CMD.enable. HW sets this field to '0' as a<p></p>
result on a DIV_CMD.disable command.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_CTRL">TCPWM_dsccfg0_CTRL</a></p>
</td>
<td><p>32'h00000540</p>
</td>
<td><p>Descriptor configure instances which is used to program TCPWM<p></p>
counters with automation, array size is matched to<p></p>
implementation Macro DSCCFGNUM defined in Table 2-2 TCPWM Macro<p></p>
Definition</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_CTRL_cmd_req">cmd_req</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>This bit is used to start descriptor configure instance for<p></p>
TCPWM counter register auto programming. Set to send command<p></p>
task request to descriptor configure instance, if descriptor<p></p>
configure instance is in idle state, it will accept the<p></p>
request, and this bit will be automatically cleared by<p></p>
descriptor master once the request is accepted.</p>
</td>
</tr>
<tr><td><p>[30:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_CTRL_reserved_b1tob30">reserved_b1tob30</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_CTRL_cmd_done_mask">cmd_done_mask</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for descriptor configure instance command task<p></p>
completion interrupt generation, when it is set, the TCPWM<p></p>
interrupt will ignore the status of STS.cmd_done.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_BASE">TCPWM_dsccfg0_BASE</a></p>
</td>
<td><p>32'h00000544</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[10:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_BASE_dscmem_addr">dscmem_addr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start (Byte) address of descriptor memory which is used by<p></p>
configure instance to store its 1st descriptor command, the<p></p>
descriptor stored in this address in most cases is a NXT<p></p>
command to jump to another location inside the descriptor<p></p>
memory.<p></p>
Note: the start (base) address of descriptor memory is 0</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS">TCPWM_dsccfg0_STS</a></p>
</td>
<td><p>32'h00000548</p>
</td>
<td><p>descriptor configure instance status</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS_idle">idle</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>If the state machine inside descriptor configure instance is<p></p>
idle (not in the middle of command execution), this bit will be<p></p>
set.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS_cmd_done">cmd_done</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Used to show descriptor configure instance signal cmd_done<p></p>
status, inside each descriptor configure instance cmd_done is<p></p>
used to indicate the command task completion, if cmd_done<p></p>
interrupt is not masked (CTRL.cmd_done_mask = 0), an interrupt<p></p>
will be issued to CPU, CPU write 1 action clears this bit<p></p>
(Note: write 1 clear is not implemented through RWC register<p></p>
type, CPU write 1 will move descriptor configure instance<p></p>
internal state machine to idle state, which causes cmd_done<p></p>
de-assertion)</p>
</td>
</tr>
<tr><td><p>[15:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS_reserved_b2tob15">reserved_b2tob15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS_dscmem_addr">dscmem_addr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Used to show current descriptor memory access address read by<p></p>
descriptor configure instance, this is useful information<p></p>
during debug when HW hangs.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_CTRL">TCPWM_dsccfg1_CTRL</a></p>
</td>
<td><p>32'h0000054C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_CTRL_cmd_req">cmd_req</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>This bit is used to start descriptor configure instance for<p></p>
TCPWM counter register auto programming. Set to send command<p></p>
task request to descriptor configure instance, if descriptor<p></p>
configure instance is in idle state, it will accept the<p></p>
request, and this bit will be automatically cleared by<p></p>
descriptor master once the request is accepted.</p>
</td>
</tr>
<tr><td><p>[30:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_CTRL_reserved_b1tob30">reserved_b1tob30</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_CTRL_cmd_done_mask">cmd_done_mask</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for descriptor configure instance command task<p></p>
completion interrupt generation, when it is set, the TCPWM<p></p>
interrupt will ignore the status of STS.cmd_done.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_BASE">TCPWM_dsccfg1_BASE</a></p>
</td>
<td><p>32'h00000550</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[10:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_BASE_dscmem_addr">dscmem_addr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start (Byte) address of descriptor memory which is used by<p></p>
configure instance to store its 1st descriptor command, the<p></p>
descriptor stored in this address in most cases is a NXT<p></p>
command to jump to another location inside the descriptor<p></p>
memory.<p></p>
Note: the start (base) address of descriptor memory is 0</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS">TCPWM_dsccfg1_STS</a></p>
</td>
<td><p>32'h00000554</p>
</td>
<td><p>descriptor configure instance status</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS_idle">idle</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>If the state machine inside descriptor configure instance is<p></p>
idle (not in the middle of command execution), this bit will be<p></p>
set.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS_cmd_done">cmd_done</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Used to show descriptor configure instance signal cmd_done<p></p>
status, inside each descriptor configure instance cmd_done is<p></p>
used to indicate the command task completion, if cmd_done<p></p>
interrupt is not masked (CTRL.cmd_done_mask = 0), an interrupt<p></p>
will be issued to CPU, CPU write 1 action clears this bit<p></p>
(Note: write 1 clear is not implemented through RWC register<p></p>
type, CPU write 1 will move descriptor configure instance<p></p>
internal state machine to idle state, which causes cmd_done<p></p>
de-assertion)</p>
</td>
</tr>
<tr><td><p>[15:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS_reserved_b2tob15">reserved_b2tob15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS_dscmem_addr">dscmem_addr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Used to show current descriptor memory access address read by<p></p>
descriptor configure instance, this is useful information<p></p>
during debug when HW hangs.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_CTRL">TCPWM_dsccfg2_CTRL</a></p>
</td>
<td><p>32'h00000558</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_CTRL_cmd_req">cmd_req</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>This bit is used to start descriptor configure instance for<p></p>
TCPWM counter register auto programming. Set to send command<p></p>
task request to descriptor configure instance, if descriptor<p></p>
configure instance is in idle state, it will accept the<p></p>
request, and this bit will be automatically cleared by<p></p>
descriptor master once the request is accepted.</p>
</td>
</tr>
<tr><td><p>[30:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_CTRL_reserved_b1tob30">reserved_b1tob30</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_CTRL_cmd_done_mask">cmd_done_mask</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Mask bit for descriptor configure instance command task<p></p>
completion interrupt generation, when it is set, the TCPWM<p></p>
interrupt will ignore the status of STS.cmd_done.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_BASE">TCPWM_dsccfg2_BASE</a></p>
</td>
<td><p>32'h0000055C</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[10:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_BASE_dscmem_addr">dscmem_addr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Start (Byte) address of descriptor memory which is used by<p></p>
configure instance to store its 1st descriptor command, the<p></p>
descriptor stored in this address in most cases is a NXT<p></p>
command to jump to another location inside the descriptor<p></p>
memory.<p></p>
Note: the start (base) address of descriptor memory is 0</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(R-)</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS">TCPWM_dsccfg2_STS</a></p>
</td>
<td><p>32'h00000560</p>
</td>
<td><p>descriptor configure instance status</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS_idle">idle</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>If the state machine inside descriptor configure instance is<p></p>
idle (not in the middle of command execution), this bit will be<p></p>
set.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS_cmd_done">cmd_done</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Used to show descriptor configure instance signal cmd_done<p></p>
status, inside each descriptor configure instance cmd_done is<p></p>
used to indicate the command task completion, if cmd_done<p></p>
interrupt is not masked (CTRL.cmd_done_mask = 0), an interrupt<p></p>
will be issued to CPU, CPU write 1 action clears this bit<p></p>
(Note: write 1 clear is not implemented through RWC register<p></p>
type, CPU write 1 will move descriptor configure instance<p></p>
internal state machine to idle state, which causes cmd_done<p></p>
de-assertion)</p>
</td>
</tr>
<tr><td><p>[15:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS_reserved_b2tob15">reserved_b2tob15</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[26:16]</p>
</td>
<td><p><a HREF="TCPWM.htm#DSCCFG_STS_dscmem_addr">dscmem_addr</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Used to show current descriptor memory access address read by<p></p>
descriptor configure instance, this is useful information<p></p>
during debug when HW hangs.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_DIV_CMD">TCPWM_DIV_CMD</a></p>
</td>
<td><p>32'h00000564</p>
</td>
<td><p>clock divider command</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_DIV_CMD_div_sel">div_sel</a></p>
</td>
<td><p>0xF</p>
</td>
<td><p>Specifies the clock divider on which the command<p></p>
(enable/disable) is performed. The valid range is 4’h0 ~<p></p>
CDIVNUM-1<p></p>
If div_sel is 4’hF, no clock divider is specified and no clock<p></p>
signal(s) are generated.</p>
</td>
</tr>
<tr><td><p>[7:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_DIV_CMD_reserved_b4tob7">reserved_b4tob7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[11:8]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_DIV_CMD_pa_div_sel">pa_div_sel</a></p>
</td>
<td><p>0xF</p>
</td>
<td><p>pa_div_sel allows a divider to be phase aligned with another<p></p>
divider. E.g., consider a 48 MHz "periClk", and a need for a 12<p></p>
MHz divided clock A and a 8 MHz divided clock B. Clock A uses<p></p>
divider #0 and is created by aligning it to "periClk"<p></p>
(pa_div_sel is 15) and CLKDIV#0.DIVCTRL.int_div is "4-1". Clock<p></p>
B uses divider #1 and is created by aligning it to clock A<p></p>
(pa_div_sel is 0) and CLKDIV#1.DIVCTRL.int_div "6-1". This<p></p>
guarantees that clock B is phase aligned with clock A: as the<p></p>
smallest common multiple of the two clock periods is 12<p></p>
"periClk" cycles, the clocks A and B will be aligned every 12<p></p>
"periClk" cycles. Note: clock B is phase aligned to clock A,<p></p>
but still uses "periClk" as a reference clock for its divider<p></p>
value.<p></p>
NOTE❶: clock divider will be phase aligned to periClk if<p></p>
pa_div_sel is in the range of CDIVNUM ~ 4’hF.<p></p>
NOTE❷: the clock divider has to be enabled before any other<p></p>
clock dividers are enabled to have phase alignment with it.</p>
</td>
</tr>
<tr><td><p>[29:12]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_DIV_CMD_reserved_b12tob29">reserved_b12tob29</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>[30:30]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_DIV_CMD_disable">disable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Clock divider disable command (mutually exclusive with enable).<p></p>
SW sets this field to ‘1’ and HW sets this field to ‘0’<p></p>
automatically, the div_sel field specifies which clock divider<p></p>
is to be disabled. If disable command is successful, the<p></p>
specified clock divider CLKDIV#.DIVSTS.en is 0.<p></p>
NOTE❶: disable bit has to be 0 before SW set it to 1, disable<p></p>
bit will not be cleared when previous divider disabling<p></p>
procedure is still in processing.<p></p>
NOTE❷: div_sel has to be set before disable bit, disable bit<p></p>
will automatically be cleared if div_sel is in the invalid<p></p>
range of CDIVNUM ~ 4’hF</p>
</td>
</tr>
<tr><td><p>[31:31]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_DIV_CMD_enable">enable</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>Clock divider enable command (mutually exclusive with disable).<p></p>
Typically, SW sets this field to '1' to enable a clock divider<p></p>
and HW sets this field to '0' automatically to indicate that<p></p>
clock divider enabling has completed. When a clock divider is<p></p>
enabled, its integer and fractional (if present) counters are<p></p>
initialized to "0". If a clock divider is to be re-enabled<p></p>
using different integer and fractional divider values, the SW<p></p>
should follow these steps:</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_OTRIGCLK_CTRL">TCPWM_OTRIGCLK_CTRL</a></p>
</td>
<td><p>32'h00000568</p>
</td>
<td><p><p></p>
</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[3:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_OTRIGCLK_CTRL_clkdiv_sel">clkdiv_sel</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>select the clock gating signal for otrigClk generation from a<p></p>
group of TCPWM clock dividers.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(P)</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_GRP_TR_CMD">TCPWM_GRP_TR_CMD</a></p>
</td>
<td><p>32'h0000056C</p>
</td>
<td><p>Counter group shared trigger command, this 8-bit trigger<p></p>
signals are sent out of TCPWM IP as output port, they will be<p></p>
connected back into TCPWM IP as bit[255:248] of 256 input<p></p>
triggers bus on SoC side, they are shared by all counters in<p></p>
the same counter group, the difference between GPR_TR_CMD and<p></p>
individual counter trigger command TR_CMD is that TR_CMD can<p></p>
only be used by each counter itself, GPR_TR_CMD is shared by<p></p>
all counters in the same counter group, and TR_CMD will be<p></p>
cleared by HW once it takes effect, GPR_TR_CMD is sticky bit,<p></p>
can NOT be cleared by HW. GPR_TR_CMD is mainly used for<p></p>
synchronized software-based event generation (such as starting<p></p>
multiple counters synchronously), it is possible by selecting<p></p>
the same trigger signal in all desired counters (via TRIN_CTRL0<p></p>
and TRIN_CTRL1).</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[0:0]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_GRP_TR_CMD_trigger_0">trigger_0</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW counter group trigger 0. When written with '1', a trigger is<p></p>
generated and the bit won’t be self-cleared until SW clear it.</p>
</td>
</tr>
<tr><td><p>[1:1]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_GRP_TR_CMD_trigger_1">trigger_1</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW counter group trigger 1. When written with '1', a trigger is<p></p>
generated and the bit won’t be self-cleared until SW clear it.</p>
</td>
</tr>
<tr><td><p>[2:2]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_GRP_TR_CMD_trigger_2">trigger_2</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW counter group trigger 2. When written with '1', a trigger is<p></p>
generated and the bit won’t be self-cleared until SW clear it.</p>
</td>
</tr>
<tr><td><p>[3:3]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_GRP_TR_CMD_trigger_3">trigger_3</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW counter group trigger 3. When written with '1', a trigger is<p></p>
generated and the bit won’t be self-cleared until SW clear it.</p>
</td>
</tr>
<tr><td><p>[4:4]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_GRP_TR_CMD_trigger_4">trigger_4</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW counter group trigger 4. When written with '1', a trigger is<p></p>
generated and the bit won’t be self-cleared until SW clear it.</p>
</td>
</tr>
<tr><td><p>[5:5]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_GRP_TR_CMD_trigger_5">trigger_5</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW counter group trigger 5. When written with '1', a trigger is<p></p>
generated and the bit won’t be self-cleared until SW clear it.</p>
</td>
</tr>
<tr><td><p>[6:6]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_GRP_TR_CMD_trigger_6">trigger_6</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW counter group trigger 6. When written with '1', a trigger is<p></p>
generated and the bit won’t be self-cleared until SW clear it.</p>
</td>
</tr>
<tr><td><p>[7:7]</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_GRP_TR_CMD_trigger_7">trigger_7</a></p>
</td>
<td><p>0x0</p>
</td>
<td><p>SW counter group trigger 7. When written with '1', a trigger is<p></p>
generated and the bit won’t be self-cleared until SW clear it.</p>
</td>
</tr>
</table><p><p></p>
</p>
<table width="100%"><tr><td><p>Access</p>
</td>
<td><p>Register</p>
</td>
<td><p>Address</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>(RW)</p>
</td>
<td><p><a HREF="TCPWM.htm#TCPWM_">TCPWM_mem</a></p>
</td>
<td><p>32'h00000800</p>
</td>
<td><p>Internal memory</p>
</td>
</tr>
<tr><td><p>Range</p>
</td>
<td><p>Field</p>
</td>
<td><p>Reset</p>
</td>
<td><p>Description</p>
</td>
</tr>
<tr><td><p>[31:0]</p>
</td>
<td><p>Memory</p>
</td>
<td><p><p></p>
</p>
</td>
<td><p>Memory</p>
</td>
</tr>
</table><p><p></p>
</p>
</body></html>