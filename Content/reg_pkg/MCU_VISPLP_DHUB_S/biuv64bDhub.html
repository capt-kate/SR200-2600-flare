<?xml version="1.0" encoding="utf-8"?><html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd"><head><title>v64bDhub</title></head>

<body>

<h1>v64bDhub

        </h1>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#v64bDhub_">v64bDhub_mem</a></p>

</td>

<td><p>32'h00000000</p>

</td>

<td><p>Real tcm size is 16KB 

Internal memory</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p>Memory</p>

</td>

<td><p> 

</p>

</td>

<td><p>Memory</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_Query">v64bDhub_dHub0_dHub_SemaFlexaHub_Query</a></p>

</td>

<td><p>32'h00004000</p>

</td>

<td><p>Used for 4ND channel Flexa handshaking operation 

Access address as defined above 

Internal memory</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p>Memory</p>

</td>

<td><p> 

</p>

</td>

<td><p>Memory</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell0_CFG</a></p>

</td>

<td><p>32'h00004080</p>

</td>

<td><p>Up-to 16 semaphore cells for Flexa operation</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell1_CFG</a></p>

</td>

<td><p>32'h00004084</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell2_CFG</a></p>

</td>

<td><p>32'h00004088</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell3_CFG</a></p>

</td>

<td><p>32'h0000408C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell4_CFG</a></p>

</td>

<td><p>32'h00004090</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell5_CFG</a></p>

</td>

<td><p>32'h00004094</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell6_CFG</a></p>

</td>

<td><p>32'h00004098</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell7_CFG</a></p>

</td>

<td><p>32'h0000409C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell8_CFG</a></p>

</td>

<td><p>32'h000040A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell9_CFG</a></p>

</td>

<td><p>32'h000040A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell10_CFG</a></p>

</td>

<td><p>32'h000040A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell11_CFG</a></p>

</td>

<td><p>32'h000040AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell12_CFG</a></p>

</td>

<td><p>32'h000040B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell13_CFG</a></p>

</td>

<td><p>32'h000040B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell14_CFG</a></p>

</td>

<td><p>32'h000040B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG">v64bDhub_dHub0_dHub_SemaFlexaHub_cell15_CFG</a></p>

</td>

<td><p>32'h000040BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaphoreFlexa_CFG_SEG_LINE">SEG_LINE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The number of lines in a data segment 

SemaphoreFlexa cells 

(xxxx_wrapper_U0.xxxxDhubTop_U0.u_semaHubFlexa.semaFlexaArr0.semaFlexaCellx) 

is used for dHub channel FLEXA SBI interface handshaking 

generation; when SEG_LINE field is set to 0, FLEXA SBI 

interface handshaking is disabled (output is 0, input is 

ignored)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(WOC-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty">v64bDhub_dHub0_dHub_SemaFlexaHub_empty</a></p>

</td>

<td><p>32'h000040C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_0i">ST_0i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_1i">ST_1i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_2i">ST_2i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_3i">ST_3i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_4i">ST_4i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_5i">ST_5i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_6i">ST_6i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_7i">ST_7i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_8i">ST_8i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[9:9]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_9i">ST_9i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_10i">ST_10i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_11i">ST_11i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[12:12]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_12i">ST_12i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[13:13]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_13i">ST_13i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_14i">ST_14i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_empty_ST_15i">ST_15i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>All cell 'empty' status</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(WOC-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full">v64bDhub_dHub0_dHub_SemaFlexaHub_full</a></p>

</td>

<td><p>32'h000040C4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_0i">ST_0i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_1i">ST_1i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_2i">ST_2i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_3i">ST_3i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_4i">ST_4i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_5i">ST_5i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_6i">ST_6i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_7i">ST_7i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_8i">ST_8i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[9:9]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_9i">ST_9i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_10i">ST_10i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_11i">ST_11i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[12:12]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_12i">ST_12i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[13:13]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_13i">ST_13i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_14i">ST_14i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaFlexaHub_full_ST_15i">ST_15i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>All cell 'full' status</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_Query">v64bDhub_dHub0_dHub_SemaHub_Query</a></p>

</td>

<td><p>32'h00004100</p>

</td>

<td><p>For dHub internal interrupts, also provide semaphore service for 

external (all channels will be opened to external to access). 

Channel 0 is used for dHub.HBO interrupt. 

Channel N+1 is used for dHub.Channel[N] interrupt. 

Access address as defined above 

Internal memory</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p>Memory</p>

</td>

<td><p> 

</p>

</td>

<td><p>Memory</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell0_CFG</a></p>

</td>

<td><p>32'h00004200</p>

</td>

<td><p>Up-to 32 semaphore cells</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell0_INTR0_mask</a></p>

</td>

<td><p>32'h00004204</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell0_INTR1_mask</a></p>

</td>

<td><p>32'h00004208</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell0_INTR2_mask</a></p>

</td>

<td><p>32'h0000420C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell0_mask</a></p>

</td>

<td><p>32'h00004210</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell0_thresh</a></p>

</td>

<td><p>32'h00004214</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when &gt;= level chosen 

For aEmp, the aEmp flag is set when &lt;= level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell1_CFG</a></p>

</td>

<td><p>32'h00004218</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell1_INTR0_mask</a></p>

</td>

<td><p>32'h0000421C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell1_INTR1_mask</a></p>

</td>

<td><p>32'h00004220</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell1_INTR2_mask</a></p>

</td>

<td><p>32'h00004224</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell1_mask</a></p>

</td>

<td><p>32'h00004228</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell1_thresh</a></p>

</td>

<td><p>32'h0000422C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when &gt;= level chosen 

For aEmp, the aEmp flag is set when &lt;= level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell2_CFG</a></p>

</td>

<td><p>32'h00004230</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell2_INTR0_mask</a></p>

</td>

<td><p>32'h00004234</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell2_INTR1_mask</a></p>

</td>

<td><p>32'h00004238</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell2_INTR2_mask</a></p>

</td>

<td><p>32'h0000423C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell2_mask</a></p>

</td>

<td><p>32'h00004240</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell2_thresh</a></p>

</td>

<td><p>32'h00004244</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when &gt;= level chosen 

For aEmp, the aEmp flag is set when &lt;= level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell3_CFG</a></p>

</td>

<td><p>32'h00004248</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell3_INTR0_mask</a></p>

</td>

<td><p>32'h0000424C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell3_INTR1_mask</a></p>

</td>

<td><p>32'h00004250</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell3_INTR2_mask</a></p>

</td>

<td><p>32'h00004254</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell3_mask</a></p>

</td>

<td><p>32'h00004258</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell3_thresh</a></p>

</td>

<td><p>32'h0000425C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell4_CFG</a></p>

</td>

<td><p>32'h00004260</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell4_INTR0_mask</a></p>

</td>

<td><p>32'h00004264</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell4_INTR1_mask</a></p>

</td>

<td><p>32'h00004268</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell4_INTR2_mask</a></p>

</td>

<td><p>32'h0000426C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell4_mask</a></p>

</td>

<td><p>32'h00004270</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell4_thresh</a></p>

</td>

<td><p>32'h00004274</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell5_CFG</a></p>

</td>

<td><p>32'h00004278</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell5_INTR0_mask</a></p>

</td>

<td><p>32'h0000427C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell5_INTR1_mask</a></p>

</td>

<td><p>32'h00004280</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell5_INTR2_mask</a></p>

</td>

<td><p>32'h00004284</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell5_mask</a></p>

</td>

<td><p>32'h00004288</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell5_thresh</a></p>

</td>

<td><p>32'h0000428C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell6_CFG</a></p>

</td>

<td><p>32'h00004290</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell6_INTR0_mask</a></p>

</td>

<td><p>32'h00004294</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell6_INTR1_mask</a></p>

</td>

<td><p>32'h00004298</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell6_INTR2_mask</a></p>

</td>

<td><p>32'h0000429C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell6_mask</a></p>

</td>

<td><p>32'h000042A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell6_thresh</a></p>

</td>

<td><p>32'h000042A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell7_CFG</a></p>

</td>

<td><p>32'h000042A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell7_INTR0_mask</a></p>

</td>

<td><p>32'h000042AC</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell7_INTR1_mask</a></p>

</td>

<td><p>32'h000042B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell7_INTR2_mask</a></p>

</td>

<td><p>32'h000042B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell7_mask</a></p>

</td>

<td><p>32'h000042B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell7_thresh</a></p>

</td>

<td><p>32'h000042BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell8_CFG</a></p>

</td>

<td><p>32'h000042C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell8_INTR0_mask</a></p>

</td>

<td><p>32'h000042C4</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell8_INTR1_mask</a></p>

</td>

<td><p>32'h000042C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell8_INTR2_mask</a></p>

</td>

<td><p>32'h000042CC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell8_mask</a></p>

</td>

<td><p>32'h000042D0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell8_thresh</a></p>

</td>

<td><p>32'h000042D4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell9_CFG</a></p>

</td>

<td><p>32'h000042D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell9_INTR0_mask</a></p>

</td>

<td><p>32'h000042DC</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell9_INTR1_mask</a></p>

</td>

<td><p>32'h000042E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell9_INTR2_mask</a></p>

</td>

<td><p>32'h000042E4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell9_mask</a></p>

</td>

<td><p>32'h000042E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell9_thresh</a></p>

</td>

<td><p>32'h000042EC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell10_CFG</a></p>

</td>

<td><p>32'h000042F0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell10_INTR0_mask</a></p>

</td>

<td><p>32'h000042F4</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell10_INTR1_mask</a></p>

</td>

<td><p>32'h000042F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell10_INTR2_mask</a></p>

</td>

<td><p>32'h000042FC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell10_mask</a></p>

</td>

<td><p>32'h00004300</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell10_thresh</a></p>

</td>

<td><p>32'h00004304</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell11_CFG</a></p>

</td>

<td><p>32'h00004308</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell11_INTR0_mask</a></p>

</td>

<td><p>32'h0000430C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell11_INTR1_mask</a></p>

</td>

<td><p>32'h00004310</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell11_INTR2_mask</a></p>

</td>

<td><p>32'h00004314</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell11_mask</a></p>

</td>

<td><p>32'h00004318</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell11_thresh</a></p>

</td>

<td><p>32'h0000431C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell12_CFG</a></p>

</td>

<td><p>32'h00004320</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell12_INTR0_mask</a></p>

</td>

<td><p>32'h00004324</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell12_INTR1_mask</a></p>

</td>

<td><p>32'h00004328</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell12_INTR2_mask</a></p>

</td>

<td><p>32'h0000432C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell12_mask</a></p>

</td>

<td><p>32'h00004330</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell12_thresh</a></p>

</td>

<td><p>32'h00004334</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell13_CFG</a></p>

</td>

<td><p>32'h00004338</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell13_INTR0_mask</a></p>

</td>

<td><p>32'h0000433C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell13_INTR1_mask</a></p>

</td>

<td><p>32'h00004340</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell13_INTR2_mask</a></p>

</td>

<td><p>32'h00004344</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell13_mask</a></p>

</td>

<td><p>32'h00004348</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell13_thresh</a></p>

</td>

<td><p>32'h0000434C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell14_CFG</a></p>

</td>

<td><p>32'h00004350</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell14_INTR0_mask</a></p>

</td>

<td><p>32'h00004354</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell14_INTR1_mask</a></p>

</td>

<td><p>32'h00004358</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell14_INTR2_mask</a></p>

</td>

<td><p>32'h0000435C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell14_mask</a></p>

</td>

<td><p>32'h00004360</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell14_thresh</a></p>

</td>

<td><p>32'h00004364</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell15_CFG</a></p>

</td>

<td><p>32'h00004368</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell15_INTR0_mask</a></p>

</td>

<td><p>32'h0000436C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell15_INTR1_mask</a></p>

</td>

<td><p>32'h00004370</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell15_INTR2_mask</a></p>

</td>

<td><p>32'h00004374</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell15_mask</a></p>

</td>

<td><p>32'h00004378</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell15_thresh</a></p>

</td>

<td><p>32'h0000437C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell16_CFG</a></p>

</td>

<td><p>32'h00004380</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell16_INTR0_mask</a></p>

</td>

<td><p>32'h00004384</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell16_INTR1_mask</a></p>

</td>

<td><p>32'h00004388</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell16_INTR2_mask</a></p>

</td>

<td><p>32'h0000438C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell16_mask</a></p>

</td>

<td><p>32'h00004390</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell16_thresh</a></p>

</td>

<td><p>32'h00004394</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell17_CFG</a></p>

</td>

<td><p>32'h00004398</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell17_INTR0_mask</a></p>

</td>

<td><p>32'h0000439C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell17_INTR1_mask</a></p>

</td>

<td><p>32'h000043A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell17_INTR2_mask</a></p>

</td>

<td><p>32'h000043A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell17_mask</a></p>

</td>

<td><p>32'h000043A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell17_thresh</a></p>

</td>

<td><p>32'h000043AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell18_CFG</a></p>

</td>

<td><p>32'h000043B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell18_INTR0_mask</a></p>

</td>

<td><p>32'h000043B4</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell18_INTR1_mask</a></p>

</td>

<td><p>32'h000043B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell18_INTR2_mask</a></p>

</td>

<td><p>32'h000043BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell18_mask</a></p>

</td>

<td><p>32'h000043C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell18_thresh</a></p>

</td>

<td><p>32'h000043C4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell19_CFG</a></p>

</td>

<td><p>32'h000043C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell19_INTR0_mask</a></p>

</td>

<td><p>32'h000043CC</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell19_INTR1_mask</a></p>

</td>

<td><p>32'h000043D0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell19_INTR2_mask</a></p>

</td>

<td><p>32'h000043D4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell19_mask</a></p>

</td>

<td><p>32'h000043D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell19_thresh</a></p>

</td>

<td><p>32'h000043DC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell20_CFG</a></p>

</td>

<td><p>32'h000043E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell20_INTR0_mask</a></p>

</td>

<td><p>32'h000043E4</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell20_INTR1_mask</a></p>

</td>

<td><p>32'h000043E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell20_INTR2_mask</a></p>

</td>

<td><p>32'h000043EC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell20_mask</a></p>

</td>

<td><p>32'h000043F0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell20_thresh</a></p>

</td>

<td><p>32'h000043F4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell21_CFG</a></p>

</td>

<td><p>32'h000043F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell21_INTR0_mask</a></p>

</td>

<td><p>32'h000043FC</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell21_INTR1_mask</a></p>

</td>

<td><p>32'h00004400</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell21_INTR2_mask</a></p>

</td>

<td><p>32'h00004404</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell21_mask</a></p>

</td>

<td><p>32'h00004408</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell21_thresh</a></p>

</td>

<td><p>32'h0000440C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell22_CFG</a></p>

</td>

<td><p>32'h00004410</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell22_INTR0_mask</a></p>

</td>

<td><p>32'h00004414</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell22_INTR1_mask</a></p>

</td>

<td><p>32'h00004418</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell22_INTR2_mask</a></p>

</td>

<td><p>32'h0000441C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell22_mask</a></p>

</td>

<td><p>32'h00004420</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell22_thresh</a></p>

</td>

<td><p>32'h00004424</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell23_CFG</a></p>

</td>

<td><p>32'h00004428</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell23_INTR0_mask</a></p>

</td>

<td><p>32'h0000442C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell23_INTR1_mask</a></p>

</td>

<td><p>32'h00004430</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell23_INTR2_mask</a></p>

</td>

<td><p>32'h00004434</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell23_mask</a></p>

</td>

<td><p>32'h00004438</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell23_thresh</a></p>

</td>

<td><p>32'h0000443C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell24_CFG</a></p>

</td>

<td><p>32'h00004440</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell24_INTR0_mask</a></p>

</td>

<td><p>32'h00004444</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell24_INTR1_mask</a></p>

</td>

<td><p>32'h00004448</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell24_INTR2_mask</a></p>

</td>

<td><p>32'h0000444C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell24_mask</a></p>

</td>

<td><p>32'h00004450</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell24_thresh</a></p>

</td>

<td><p>32'h00004454</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell25_CFG</a></p>

</td>

<td><p>32'h00004458</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell25_INTR0_mask</a></p>

</td>

<td><p>32'h0000445C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell25_INTR1_mask</a></p>

</td>

<td><p>32'h00004460</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell25_INTR2_mask</a></p>

</td>

<td><p>32'h00004464</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell25_mask</a></p>

</td>

<td><p>32'h00004468</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell25_thresh</a></p>

</td>

<td><p>32'h0000446C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell26_CFG</a></p>

</td>

<td><p>32'h00004470</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell26_INTR0_mask</a></p>

</td>

<td><p>32'h00004474</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell26_INTR1_mask</a></p>

</td>

<td><p>32'h00004478</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell26_INTR2_mask</a></p>

</td>

<td><p>32'h0000447C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell26_mask</a></p>

</td>

<td><p>32'h00004480</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell26_thresh</a></p>

</td>

<td><p>32'h00004484</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell27_CFG</a></p>

</td>

<td><p>32'h00004488</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell27_INTR0_mask</a></p>

</td>

<td><p>32'h0000448C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell27_INTR1_mask</a></p>

</td>

<td><p>32'h00004490</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell27_INTR2_mask</a></p>

</td>

<td><p>32'h00004494</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell27_mask</a></p>

</td>

<td><p>32'h00004498</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell27_thresh</a></p>

</td>

<td><p>32'h0000449C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell28_CFG</a></p>

</td>

<td><p>32'h000044A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell28_INTR0_mask</a></p>

</td>

<td><p>32'h000044A4</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell28_INTR1_mask</a></p>

</td>

<td><p>32'h000044A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell28_INTR2_mask</a></p>

</td>

<td><p>32'h000044AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell28_mask</a></p>

</td>

<td><p>32'h000044B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell28_thresh</a></p>

</td>

<td><p>32'h000044B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell29_CFG</a></p>

</td>

<td><p>32'h000044B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell29_INTR0_mask</a></p>

</td>

<td><p>32'h000044BC</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell29_INTR1_mask</a></p>

</td>

<td><p>32'h000044C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell29_INTR2_mask</a></p>

</td>

<td><p>32'h000044C4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell29_mask</a></p>

</td>

<td><p>32'h000044C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell29_thresh</a></p>

</td>

<td><p>32'h000044CC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell30_CFG</a></p>

</td>

<td><p>32'h000044D0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell30_INTR0_mask</a></p>

</td>

<td><p>32'h000044D4</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell30_INTR1_mask</a></p>

</td>

<td><p>32'h000044D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell30_INTR2_mask</a></p>

</td>

<td><p>32'h000044DC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell30_mask</a></p>

</td>

<td><p>32'h000044E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell30_thresh</a></p>

</td>

<td><p>32'h000044E4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_SemaHub_cell31_CFG</a></p>

</td>

<td><p>32'h000044E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell31_INTR0_mask</a></p>

</td>

<td><p>32'h000044EC</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell31_INTR1_mask</a></p>

</td>

<td><p>32'h000044F0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_SemaHub_cell31_INTR2_mask</a></p>

</td>

<td><p>32'h000044F4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_SemaHub_cell31_mask</a></p>

</td>

<td><p>32'h000044F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_SemaHub_cell31_thresh</a></p>

</td>

<td><p>32'h000044FC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_PUSH">v64bDhub_dHub0_dHub_SemaHub_PUSH</a></p>

</td>

<td><p>32'h00004500</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_PUSH_ID">ID</a></p>

</td>

<td><p> 

</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_PUSH_delta">delta</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>CPU increases PCounter by delta (0 as push 256)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_POP">v64bDhub_dHub0_dHub_SemaHub_POP</a></p>

</td>

<td><p>32'h00004504</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_POP_ID">ID</a></p>

</td>

<td><p> 

</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_POP_delta">delta</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>CPU decreases CCounter by delta (0 as pop 256)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(WOC-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty">v64bDhub_dHub0_dHub_SemaHub_empty</a></p>

</td>

<td><p>32'h00004508</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_0i">ST_0i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_1i">ST_1i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_2i">ST_2i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_3i">ST_3i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_4i">ST_4i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_5i">ST_5i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_6i">ST_6i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_7i">ST_7i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_8i">ST_8i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[9:9]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_9i">ST_9i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_10i">ST_10i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_11i">ST_11i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[12:12]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_12i">ST_12i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[13:13]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_13i">ST_13i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_14i">ST_14i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_15i">ST_15i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_16i">ST_16i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_17i">ST_17i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[18:18]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_18i">ST_18i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[19:19]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_19i">ST_19i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[20:20]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_20i">ST_20i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[21:21]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_21i">ST_21i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[22:22]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_22i">ST_22i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[23:23]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_23i">ST_23i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[24:24]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_24i">ST_24i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[25:25]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_25i">ST_25i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_26i">ST_26i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_27i">ST_27i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_28i">ST_28i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_29i">ST_29i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_30i">ST_30i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_31i">ST_31i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>All cell 'empty' status</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(WOC-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full">v64bDhub_dHub0_dHub_SemaHub_full</a></p>

</td>

<td><p>32'h0000450C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_0i">ST_0i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_1i">ST_1i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_2i">ST_2i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_3i">ST_3i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_4i">ST_4i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_5i">ST_5i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_6i">ST_6i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_7i">ST_7i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_8i">ST_8i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[9:9]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_9i">ST_9i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_10i">ST_10i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_11i">ST_11i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[12:12]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_12i">ST_12i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[13:13]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_13i">ST_13i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_14i">ST_14i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_15i">ST_15i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_16i">ST_16i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_17i">ST_17i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[18:18]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_18i">ST_18i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[19:19]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_19i">ST_19i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[20:20]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_20i">ST_20i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[21:21]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_21i">ST_21i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[22:22]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_22i">ST_22i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[23:23]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_23i">ST_23i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[24:24]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_24i">ST_24i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[25:25]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_25i">ST_25i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_26i">ST_26i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_27i">ST_27i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_28i">ST_28i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_29i">ST_29i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_30i">ST_30i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_31i">ST_31i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>All cell 'full' status</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(WOC-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty">v64bDhub_dHub0_dHub_SemaHub_almostEmpty</a></p>

</td>

<td><p>32'h00004510</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_0i">ST_0i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_1i">ST_1i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_2i">ST_2i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_3i">ST_3i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_4i">ST_4i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_5i">ST_5i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_6i">ST_6i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_7i">ST_7i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_8i">ST_8i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[9:9]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_9i">ST_9i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_10i">ST_10i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_11i">ST_11i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[12:12]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_12i">ST_12i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[13:13]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_13i">ST_13i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_14i">ST_14i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_15i">ST_15i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_16i">ST_16i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_17i">ST_17i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[18:18]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_18i">ST_18i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[19:19]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_19i">ST_19i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[20:20]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_20i">ST_20i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[21:21]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_21i">ST_21i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[22:22]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_22i">ST_22i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[23:23]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_23i">ST_23i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[24:24]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_24i">ST_24i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[25:25]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_25i">ST_25i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_26i">ST_26i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_27i">ST_27i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_28i">ST_28i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_29i">ST_29i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_30i">ST_30i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_31i">ST_31i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>All cell 'almostEmpty' status</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(WOC-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull">v64bDhub_dHub0_dHub_SemaHub_almostFull</a></p>

</td>

<td><p>32'h00004514</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_0i">ST_0i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_1i">ST_1i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_2i">ST_2i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_3i">ST_3i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_4i">ST_4i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_5i">ST_5i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_6i">ST_6i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_7i">ST_7i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_8i">ST_8i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[9:9]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_9i">ST_9i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_10i">ST_10i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_11i">ST_11i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[12:12]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_12i">ST_12i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[13:13]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_13i">ST_13i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_14i">ST_14i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_15i">ST_15i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_16i">ST_16i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_17i">ST_17i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[18:18]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_18i">ST_18i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[19:19]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_19i">ST_19i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[20:20]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_20i">ST_20i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[21:21]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_21i">ST_21i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[22:22]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_22i">ST_22i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[23:23]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_23i">ST_23i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[24:24]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_24i">ST_24i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[25:25]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_25i">ST_25i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_26i">ST_26i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_27i">ST_27i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_28i">ST_28i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_29i">ST_29i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_30i">ST_30i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_31i">ST_31i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>All cell 'almostFull' status</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_Query">v64bDhub_dHub0_dHub_HBO_FiFoCtl_Query</a></p>

</td>

<td><p>32'h00004600</p>

</td>

<td><p>For dHub channels (command/data queues), also provide (unused) 

FIFO service for external. 

Channel 2N is used for dHub.Channel[N] command. 

Channel 2N+1 is used for dHub.Channel[N] data. 

Access address as defined above 

Internal memory</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p>Memory</p>

</td>

<td><p> 

</p>

</td>

<td><p>Memory</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell0_CFG</a></p>

</td>

<td><p>32'h00004700</p>

</td>

<td><p>Up-to 32 semaphore cells</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell0_INTR0_mask</a></p>

</td>

<td><p>32'h00004704</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell0_INTR1_mask</a></p>

</td>

<td><p>32'h00004708</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell0_INTR2_mask</a></p>

</td>

<td><p>32'h0000470C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell0_mask</a></p>

</td>

<td><p>32'h00004710</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell0_thresh</a></p>

</td>

<td><p>32'h00004714</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell1_CFG</a></p>

</td>

<td><p>32'h00004718</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell1_INTR0_mask</a></p>

</td>

<td><p>32'h0000471C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell1_INTR1_mask</a></p>

</td>

<td><p>32'h00004720</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell1_INTR2_mask</a></p>

</td>

<td><p>32'h00004724</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell1_mask</a></p>

</td>

<td><p>32'h00004728</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell1_thresh</a></p>

</td>

<td><p>32'h0000472C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell2_CFG</a></p>

</td>

<td><p>32'h00004730</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell2_INTR0_mask</a></p>

</td>

<td><p>32'h00004734</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell2_INTR1_mask</a></p>

</td>

<td><p>32'h00004738</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell2_INTR2_mask</a></p>

</td>

<td><p>32'h0000473C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell2_mask</a></p>

</td>

<td><p>32'h00004740</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell2_thresh</a></p>

</td>

<td><p>32'h00004744</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell3_CFG</a></p>

</td>

<td><p>32'h00004748</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell3_INTR0_mask</a></p>

</td>

<td><p>32'h0000474C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell3_INTR1_mask</a></p>

</td>

<td><p>32'h00004750</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell3_INTR2_mask</a></p>

</td>

<td><p>32'h00004754</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell3_mask</a></p>

</td>

<td><p>32'h00004758</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell3_thresh</a></p>

</td>

<td><p>32'h0000475C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell4_CFG</a></p>

</td>

<td><p>32'h00004760</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell4_INTR0_mask</a></p>

</td>

<td><p>32'h00004764</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell4_INTR1_mask</a></p>

</td>

<td><p>32'h00004768</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell4_INTR2_mask</a></p>

</td>

<td><p>32'h0000476C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell4_mask</a></p>

</td>

<td><p>32'h00004770</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell4_thresh</a></p>

</td>

<td><p>32'h00004774</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell5_CFG</a></p>

</td>

<td><p>32'h00004778</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell5_INTR0_mask</a></p>

</td>

<td><p>32'h0000477C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell5_INTR1_mask</a></p>

</td>

<td><p>32'h00004780</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell5_INTR2_mask</a></p>

</td>

<td><p>32'h00004784</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell5_mask</a></p>

</td>

<td><p>32'h00004788</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell5_thresh</a></p>

</td>

<td><p>32'h0000478C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell6_CFG</a></p>

</td>

<td><p>32'h00004790</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell6_INTR0_mask</a></p>

</td>

<td><p>32'h00004794</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell6_INTR1_mask</a></p>

</td>

<td><p>32'h00004798</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell6_INTR2_mask</a></p>

</td>

<td><p>32'h0000479C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell6_mask</a></p>

</td>

<td><p>32'h000047A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell6_thresh</a></p>

</td>

<td><p>32'h000047A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell7_CFG</a></p>

</td>

<td><p>32'h000047A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell7_INTR0_mask</a></p>

</td>

<td><p>32'h000047AC</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell7_INTR1_mask</a></p>

</td>

<td><p>32'h000047B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell7_INTR2_mask</a></p>

</td>

<td><p>32'h000047B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell7_mask</a></p>

</td>

<td><p>32'h000047B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell7_thresh</a></p>

</td>

<td><p>32'h000047BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell8_CFG</a></p>

</td>

<td><p>32'h000047C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell8_INTR0_mask</a></p>

</td>

<td><p>32'h000047C4</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell8_INTR1_mask</a></p>

</td>

<td><p>32'h000047C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell8_INTR2_mask</a></p>

</td>

<td><p>32'h000047CC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell8_mask</a></p>

</td>

<td><p>32'h000047D0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell8_thresh</a></p>

</td>

<td><p>32'h000047D4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell9_CFG</a></p>

</td>

<td><p>32'h000047D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell9_INTR0_mask</a></p>

</td>

<td><p>32'h000047DC</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell9_INTR1_mask</a></p>

</td>

<td><p>32'h000047E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell9_INTR2_mask</a></p>

</td>

<td><p>32'h000047E4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell9_mask</a></p>

</td>

<td><p>32'h000047E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell9_thresh</a></p>

</td>

<td><p>32'h000047EC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell10_CFG</a></p>

</td>

<td><p>32'h000047F0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell10_INTR0_mask</a></p>

</td>

<td><p>32'h000047F4</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell10_INTR1_mask</a></p>

</td>

<td><p>32'h000047F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell10_INTR2_mask</a></p>

</td>

<td><p>32'h000047FC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell10_mask</a></p>

</td>

<td><p>32'h00004800</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell10_thresh</a></p>

</td>

<td><p>32'h00004804</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell11_CFG</a></p>

</td>

<td><p>32'h00004808</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell11_INTR0_mask</a></p>

</td>

<td><p>32'h0000480C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell11_INTR1_mask</a></p>

</td>

<td><p>32'h00004810</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell11_INTR2_mask</a></p>

</td>

<td><p>32'h00004814</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell11_mask</a></p>

</td>

<td><p>32'h00004818</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell11_thresh</a></p>

</td>

<td><p>32'h0000481C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell12_CFG</a></p>

</td>

<td><p>32'h00004820</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell12_INTR0_mask</a></p>

</td>

<td><p>32'h00004824</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell12_INTR1_mask</a></p>

</td>

<td><p>32'h00004828</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell12_INTR2_mask</a></p>

</td>

<td><p>32'h0000482C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell12_mask</a></p>

</td>

<td><p>32'h00004830</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell12_thresh</a></p>

</td>

<td><p>32'h00004834</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell13_CFG</a></p>

</td>

<td><p>32'h00004838</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell13_INTR0_mask</a></p>

</td>

<td><p>32'h0000483C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell13_INTR1_mask</a></p>

</td>

<td><p>32'h00004840</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell13_INTR2_mask</a></p>

</td>

<td><p>32'h00004844</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell13_mask</a></p>

</td>

<td><p>32'h00004848</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell13_thresh</a></p>

</td>

<td><p>32'h0000484C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell14_CFG</a></p>

</td>

<td><p>32'h00004850</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell14_INTR0_mask</a></p>

</td>

<td><p>32'h00004854</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell14_INTR1_mask</a></p>

</td>

<td><p>32'h00004858</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell14_INTR2_mask</a></p>

</td>

<td><p>32'h0000485C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell14_mask</a></p>

</td>

<td><p>32'h00004860</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell14_thresh</a></p>

</td>

<td><p>32'h00004864</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell15_CFG</a></p>

</td>

<td><p>32'h00004868</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell15_INTR0_mask</a></p>

</td>

<td><p>32'h0000486C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell15_INTR1_mask</a></p>

</td>

<td><p>32'h00004870</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell15_INTR2_mask</a></p>

</td>

<td><p>32'h00004874</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell15_mask</a></p>

</td>

<td><p>32'h00004878</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell15_thresh</a></p>

</td>

<td><p>32'h0000487C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell16_CFG</a></p>

</td>

<td><p>32'h00004880</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell16_INTR0_mask</a></p>

</td>

<td><p>32'h00004884</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell16_INTR1_mask</a></p>

</td>

<td><p>32'h00004888</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell16_INTR2_mask</a></p>

</td>

<td><p>32'h0000488C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell16_mask</a></p>

</td>

<td><p>32'h00004890</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell16_thresh</a></p>

</td>

<td><p>32'h00004894</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell17_CFG</a></p>

</td>

<td><p>32'h00004898</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell17_INTR0_mask</a></p>

</td>

<td><p>32'h0000489C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell17_INTR1_mask</a></p>

</td>

<td><p>32'h000048A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell17_INTR2_mask</a></p>

</td>

<td><p>32'h000048A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell17_mask</a></p>

</td>

<td><p>32'h000048A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell17_thresh</a></p>

</td>

<td><p>32'h000048AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell18_CFG</a></p>

</td>

<td><p>32'h000048B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell18_INTR0_mask</a></p>

</td>

<td><p>32'h000048B4</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell18_INTR1_mask</a></p>

</td>

<td><p>32'h000048B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell18_INTR2_mask</a></p>

</td>

<td><p>32'h000048BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell18_mask</a></p>

</td>

<td><p>32'h000048C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell18_thresh</a></p>

</td>

<td><p>32'h000048C4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell19_CFG</a></p>

</td>

<td><p>32'h000048C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell19_INTR0_mask</a></p>

</td>

<td><p>32'h000048CC</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell19_INTR1_mask</a></p>

</td>

<td><p>32'h000048D0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell19_INTR2_mask</a></p>

</td>

<td><p>32'h000048D4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell19_mask</a></p>

</td>

<td><p>32'h000048D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell19_thresh</a></p>

</td>

<td><p>32'h000048DC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell20_CFG</a></p>

</td>

<td><p>32'h000048E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell20_INTR0_mask</a></p>

</td>

<td><p>32'h000048E4</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell20_INTR1_mask</a></p>

</td>

<td><p>32'h000048E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell20_INTR2_mask</a></p>

</td>

<td><p>32'h000048EC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell20_mask</a></p>

</td>

<td><p>32'h000048F0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell20_thresh</a></p>

</td>

<td><p>32'h000048F4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell21_CFG</a></p>

</td>

<td><p>32'h000048F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell21_INTR0_mask</a></p>

</td>

<td><p>32'h000048FC</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell21_INTR1_mask</a></p>

</td>

<td><p>32'h00004900</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell21_INTR2_mask</a></p>

</td>

<td><p>32'h00004904</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell21_mask</a></p>

</td>

<td><p>32'h00004908</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell21_thresh</a></p>

</td>

<td><p>32'h0000490C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell22_CFG</a></p>

</td>

<td><p>32'h00004910</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell22_INTR0_mask</a></p>

</td>

<td><p>32'h00004914</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell22_INTR1_mask</a></p>

</td>

<td><p>32'h00004918</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell22_INTR2_mask</a></p>

</td>

<td><p>32'h0000491C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell22_mask</a></p>

</td>

<td><p>32'h00004920</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell22_thresh</a></p>

</td>

<td><p>32'h00004924</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell23_CFG</a></p>

</td>

<td><p>32'h00004928</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell23_INTR0_mask</a></p>

</td>

<td><p>32'h0000492C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell23_INTR1_mask</a></p>

</td>

<td><p>32'h00004930</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell23_INTR2_mask</a></p>

</td>

<td><p>32'h00004934</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell23_mask</a></p>

</td>

<td><p>32'h00004938</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell23_thresh</a></p>

</td>

<td><p>32'h0000493C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell24_CFG</a></p>

</td>

<td><p>32'h00004940</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell24_INTR0_mask</a></p>

</td>

<td><p>32'h00004944</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell24_INTR1_mask</a></p>

</td>

<td><p>32'h00004948</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell24_INTR2_mask</a></p>

</td>

<td><p>32'h0000494C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell24_mask</a></p>

</td>

<td><p>32'h00004950</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell24_thresh</a></p>

</td>

<td><p>32'h00004954</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell25_CFG</a></p>

</td>

<td><p>32'h00004958</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell25_INTR0_mask</a></p>

</td>

<td><p>32'h0000495C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell25_INTR1_mask</a></p>

</td>

<td><p>32'h00004960</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell25_INTR2_mask</a></p>

</td>

<td><p>32'h00004964</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell25_mask</a></p>

</td>

<td><p>32'h00004968</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell25_thresh</a></p>

</td>

<td><p>32'h0000496C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell26_CFG</a></p>

</td>

<td><p>32'h00004970</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell26_INTR0_mask</a></p>

</td>

<td><p>32'h00004974</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell26_INTR1_mask</a></p>

</td>

<td><p>32'h00004978</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell26_INTR2_mask</a></p>

</td>

<td><p>32'h0000497C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell26_mask</a></p>

</td>

<td><p>32'h00004980</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell26_thresh</a></p>

</td>

<td><p>32'h00004984</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell27_CFG</a></p>

</td>

<td><p>32'h00004988</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell27_INTR0_mask</a></p>

</td>

<td><p>32'h0000498C</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell27_INTR1_mask</a></p>

</td>

<td><p>32'h00004990</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell27_INTR2_mask</a></p>

</td>

<td><p>32'h00004994</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell27_mask</a></p>

</td>

<td><p>32'h00004998</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell27_thresh</a></p>

</td>

<td><p>32'h0000499C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell28_CFG</a></p>

</td>

<td><p>32'h000049A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell28_INTR0_mask</a></p>

</td>

<td><p>32'h000049A4</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell28_INTR1_mask</a></p>

</td>

<td><p>32'h000049A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell28_INTR2_mask</a></p>

</td>

<td><p>32'h000049AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell28_mask</a></p>

</td>

<td><p>32'h000049B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell28_thresh</a></p>

</td>

<td><p>32'h000049B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell29_CFG</a></p>

</td>

<td><p>32'h000049B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell29_INTR0_mask</a></p>

</td>

<td><p>32'h000049BC</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell29_INTR1_mask</a></p>

</td>

<td><p>32'h000049C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell29_INTR2_mask</a></p>

</td>

<td><p>32'h000049C4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell29_mask</a></p>

</td>

<td><p>32'h000049C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell29_thresh</a></p>

</td>

<td><p>32'h000049CC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell30_CFG</a></p>

</td>

<td><p>32'h000049D0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell30_INTR0_mask</a></p>

</td>

<td><p>32'h000049D4</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell30_INTR1_mask</a></p>

</td>

<td><p>32'h000049D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell30_INTR2_mask</a></p>

</td>

<td><p>32'h000049DC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell30_mask</a></p>

</td>

<td><p>32'h000049E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell30_thresh</a></p>

</td>

<td><p>32'h000049E4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell31_CFG</a></p>

</td>

<td><p>32'h000049E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_CFG_DEPTH">DEPTH</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>Max level of semaphore 

Note: write this register will trigger counter reset</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell31_INTR0_mask</a></p>

</td>

<td><p>32'h000049EC</p>

</td>

<td><p>Interrupt mask for 3 CPUs</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell31_INTR1_mask</a></p>

</td>

<td><p>32'h000049F0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell31_INTR2_mask</a></p>

</td>

<td><p>32'h000049F4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_empty">empty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'empty' condition</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'full' condition</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostEmpty">almostEmpty</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostEmpty' condition</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaINTR_mask_almostFull">almostFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Enable interrupt on 'almostFull' condition</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell31_mask</a></p>

</td>

<td><p>32'h000049F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_full">full</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_mask_emp">emp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When full bit is set to one, to the producer, the semaphore will 

never be full, so that the producer will never be blocked. 

When emp bit is set to one, to the consumer, the semaphore will 

never be empty, so that the consumer will never be blocked. 

When the emp/full bit is set, the semaphore/FIFO pointer will be 

maintained, but the counter will be not correct anymore.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh">v64bDhub_dHub0_dHub_HBO_FiFoCtl_cell31_thresh</a></p>

</td>

<td><p>32'h000049FC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aFull">aFull</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:2]</p>

</td>

<td><p><a HREF="vDhub.htm#Semaphore_thresh_aEmp">aEmp</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Selects almost full and almost empty threshold levels 

2'b0: 1/2 

2'b1: 1/4 

2'b2: 3/4 

2'b3: 1/8 for aEmp 7/8 for aFull 

For aFull, the aFull flag is set when >= level chosen 

For aEmp, the aEmp flag is set when < = level chosen.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_PUSH">v64bDhub_dHub0_dHub_HBO_FiFoCtl_PUSH</a></p>

</td>

<td><p>32'h00004A00</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_PUSH_ID">ID</a></p>

</td>

<td><p> 

</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_PUSH_delta">delta</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>CPU increases PCounter by delta (0 as push 256)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_POP">v64bDhub_dHub0_dHub_HBO_FiFoCtl_POP</a></p>

</td>

<td><p>32'h00004A04</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_POP_ID">ID</a></p>

</td>

<td><p> 

</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_POP_delta">delta</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>CPU decreases CCounter by delta (0 as pop 256)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(WOC-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty">v64bDhub_dHub0_dHub_HBO_FiFoCtl_empty</a></p>

</td>

<td><p>32'h00004A08</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_0i">ST_0i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_1i">ST_1i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_2i">ST_2i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_3i">ST_3i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_4i">ST_4i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_5i">ST_5i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_6i">ST_6i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_7i">ST_7i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_8i">ST_8i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[9:9]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_9i">ST_9i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_10i">ST_10i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_11i">ST_11i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[12:12]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_12i">ST_12i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[13:13]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_13i">ST_13i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_14i">ST_14i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_15i">ST_15i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_16i">ST_16i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_17i">ST_17i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[18:18]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_18i">ST_18i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[19:19]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_19i">ST_19i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[20:20]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_20i">ST_20i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[21:21]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_21i">ST_21i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[22:22]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_22i">ST_22i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[23:23]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_23i">ST_23i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[24:24]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_24i">ST_24i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[25:25]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_25i">ST_25i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_26i">ST_26i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_27i">ST_27i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_28i">ST_28i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_29i">ST_29i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_30i">ST_30i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_empty_ST_31i">ST_31i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>All cell 'empty' status</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(WOC-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full">v64bDhub_dHub0_dHub_HBO_FiFoCtl_full</a></p>

</td>

<td><p>32'h00004A0C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_0i">ST_0i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_1i">ST_1i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_2i">ST_2i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_3i">ST_3i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_4i">ST_4i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_5i">ST_5i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_6i">ST_6i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_7i">ST_7i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_8i">ST_8i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[9:9]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_9i">ST_9i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_10i">ST_10i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_11i">ST_11i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[12:12]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_12i">ST_12i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[13:13]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_13i">ST_13i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_14i">ST_14i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_15i">ST_15i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_16i">ST_16i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_17i">ST_17i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[18:18]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_18i">ST_18i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[19:19]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_19i">ST_19i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[20:20]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_20i">ST_20i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[21:21]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_21i">ST_21i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[22:22]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_22i">ST_22i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[23:23]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_23i">ST_23i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[24:24]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_24i">ST_24i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[25:25]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_25i">ST_25i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_26i">ST_26i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_27i">ST_27i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_28i">ST_28i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_29i">ST_29i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_30i">ST_30i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_full_ST_31i">ST_31i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>All cell 'full' status</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(WOC-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty">v64bDhub_dHub0_dHub_HBO_FiFoCtl_almostEmpty</a></p>

</td>

<td><p>32'h00004A10</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_0i">ST_0i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_1i">ST_1i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_2i">ST_2i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_3i">ST_3i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_4i">ST_4i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_5i">ST_5i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_6i">ST_6i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_7i">ST_7i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_8i">ST_8i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[9:9]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_9i">ST_9i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_10i">ST_10i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_11i">ST_11i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[12:12]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_12i">ST_12i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[13:13]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_13i">ST_13i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_14i">ST_14i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_15i">ST_15i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_16i">ST_16i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_17i">ST_17i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[18:18]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_18i">ST_18i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[19:19]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_19i">ST_19i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[20:20]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_20i">ST_20i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[21:21]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_21i">ST_21i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[22:22]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_22i">ST_22i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[23:23]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_23i">ST_23i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[24:24]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_24i">ST_24i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[25:25]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_25i">ST_25i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_26i">ST_26i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_27i">ST_27i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_28i">ST_28i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_29i">ST_29i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_30i">ST_30i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostEmpty_ST_31i">ST_31i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>All cell 'almostEmpty' status</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(WOC-)</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull">v64bDhub_dHub0_dHub_HBO_FiFoCtl_almostFull</a></p>

</td>

<td><p>32'h00004A14</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_0i">ST_0i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[1:1]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_1i">ST_1i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[2:2]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_2i">ST_2i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[3:3]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_3i">ST_3i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_4i">ST_4i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_5i">ST_5i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_6i">ST_6i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_7i">ST_7i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_8i">ST_8i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[9:9]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_9i">ST_9i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_10i">ST_10i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_11i">ST_11i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[12:12]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_12i">ST_12i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[13:13]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_13i">ST_13i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_14i">ST_14i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_15i">ST_15i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_16i">ST_16i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_17i">ST_17i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[18:18]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_18i">ST_18i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[19:19]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_19i">ST_19i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[20:20]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_20i">ST_20i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[21:21]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_21i">ST_21i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[22:22]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_22i">ST_22i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[23:23]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_23i">ST_23i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[24:24]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_24i">ST_24i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[25:25]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_25i">ST_25i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_26i">ST_26i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_27i">ST_27i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_28i">ST_28i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_29i">ST_29i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_30i">ST_30i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#SemaHub_almostFull_ST_31i">ST_31i</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>All cell 'almostFull' status</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo0_CFG</a></p>

</td>

<td><p>32'h00004B00</p>

</td>

<td><p>Up-to 32 FIFO channels 

FiFo[N] is controlled by HBO.FiFoCtl.Channel[N]</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo0_START</a></p>

</td>

<td><p>32'h00004B04</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo0_CLEAR</a></p>

</td>

<td><p>32'h00004B08</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo0_FLUSH</a></p>

</td>

<td><p>32'h00004B0C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo1_CFG</a></p>

</td>

<td><p>32'h00004B10</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo1_START</a></p>

</td>

<td><p>32'h00004B14</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo1_CLEAR</a></p>

</td>

<td><p>32'h00004B18</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo1_FLUSH</a></p>

</td>

<td><p>32'h00004B1C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo2_CFG</a></p>

</td>

<td><p>32'h00004B20</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo2_START</a></p>

</td>

<td><p>32'h00004B24</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo2_CLEAR</a></p>

</td>

<td><p>32'h00004B28</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo2_FLUSH</a></p>

</td>

<td><p>32'h00004B2C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo3_CFG</a></p>

</td>

<td><p>32'h00004B30</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo3_START</a></p>

</td>

<td><p>32'h00004B34</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo3_CLEAR</a></p>

</td>

<td><p>32'h00004B38</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo3_FLUSH</a></p>

</td>

<td><p>32'h00004B3C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo4_CFG</a></p>

</td>

<td><p>32'h00004B40</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo4_START</a></p>

</td>

<td><p>32'h00004B44</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo4_CLEAR</a></p>

</td>

<td><p>32'h00004B48</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo4_FLUSH</a></p>

</td>

<td><p>32'h00004B4C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo5_CFG</a></p>

</td>

<td><p>32'h00004B50</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo5_START</a></p>

</td>

<td><p>32'h00004B54</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo5_CLEAR</a></p>

</td>

<td><p>32'h00004B58</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo5_FLUSH</a></p>

</td>

<td><p>32'h00004B5C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo6_CFG</a></p>

</td>

<td><p>32'h00004B60</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo6_START</a></p>

</td>

<td><p>32'h00004B64</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo6_CLEAR</a></p>

</td>

<td><p>32'h00004B68</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo6_FLUSH</a></p>

</td>

<td><p>32'h00004B6C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo7_CFG</a></p>

</td>

<td><p>32'h00004B70</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo7_START</a></p>

</td>

<td><p>32'h00004B74</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo7_CLEAR</a></p>

</td>

<td><p>32'h00004B78</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo7_FLUSH</a></p>

</td>

<td><p>32'h00004B7C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo8_CFG</a></p>

</td>

<td><p>32'h00004B80</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo8_START</a></p>

</td>

<td><p>32'h00004B84</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo8_CLEAR</a></p>

</td>

<td><p>32'h00004B88</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo8_FLUSH</a></p>

</td>

<td><p>32'h00004B8C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo9_CFG</a></p>

</td>

<td><p>32'h00004B90</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo9_START</a></p>

</td>

<td><p>32'h00004B94</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo9_CLEAR</a></p>

</td>

<td><p>32'h00004B98</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo9_FLUSH</a></p>

</td>

<td><p>32'h00004B9C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo10_CFG</a></p>

</td>

<td><p>32'h00004BA0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo10_START</a></p>

</td>

<td><p>32'h00004BA4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo10_CLEAR</a></p>

</td>

<td><p>32'h00004BA8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo10_FLUSH</a></p>

</td>

<td><p>32'h00004BAC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo11_CFG</a></p>

</td>

<td><p>32'h00004BB0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo11_START</a></p>

</td>

<td><p>32'h00004BB4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo11_CLEAR</a></p>

</td>

<td><p>32'h00004BB8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo11_FLUSH</a></p>

</td>

<td><p>32'h00004BBC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo12_CFG</a></p>

</td>

<td><p>32'h00004BC0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo12_START</a></p>

</td>

<td><p>32'h00004BC4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo12_CLEAR</a></p>

</td>

<td><p>32'h00004BC8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo12_FLUSH</a></p>

</td>

<td><p>32'h00004BCC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo13_CFG</a></p>

</td>

<td><p>32'h00004BD0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo13_START</a></p>

</td>

<td><p>32'h00004BD4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo13_CLEAR</a></p>

</td>

<td><p>32'h00004BD8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo13_FLUSH</a></p>

</td>

<td><p>32'h00004BDC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo14_CFG</a></p>

</td>

<td><p>32'h00004BE0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo14_START</a></p>

</td>

<td><p>32'h00004BE4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo14_CLEAR</a></p>

</td>

<td><p>32'h00004BE8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo14_FLUSH</a></p>

</td>

<td><p>32'h00004BEC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo15_CFG</a></p>

</td>

<td><p>32'h00004BF0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo15_START</a></p>

</td>

<td><p>32'h00004BF4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo15_CLEAR</a></p>

</td>

<td><p>32'h00004BF8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo15_FLUSH</a></p>

</td>

<td><p>32'h00004BFC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo16_CFG</a></p>

</td>

<td><p>32'h00004C00</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo16_START</a></p>

</td>

<td><p>32'h00004C04</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo16_CLEAR</a></p>

</td>

<td><p>32'h00004C08</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo16_FLUSH</a></p>

</td>

<td><p>32'h00004C0C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo17_CFG</a></p>

</td>

<td><p>32'h00004C10</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo17_START</a></p>

</td>

<td><p>32'h00004C14</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo17_CLEAR</a></p>

</td>

<td><p>32'h00004C18</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo17_FLUSH</a></p>

</td>

<td><p>32'h00004C1C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo18_CFG</a></p>

</td>

<td><p>32'h00004C20</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo18_START</a></p>

</td>

<td><p>32'h00004C24</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo18_CLEAR</a></p>

</td>

<td><p>32'h00004C28</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo18_FLUSH</a></p>

</td>

<td><p>32'h00004C2C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo19_CFG</a></p>

</td>

<td><p>32'h00004C30</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo19_START</a></p>

</td>

<td><p>32'h00004C34</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo19_CLEAR</a></p>

</td>

<td><p>32'h00004C38</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo19_FLUSH</a></p>

</td>

<td><p>32'h00004C3C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo20_CFG</a></p>

</td>

<td><p>32'h00004C40</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo20_START</a></p>

</td>

<td><p>32'h00004C44</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo20_CLEAR</a></p>

</td>

<td><p>32'h00004C48</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo20_FLUSH</a></p>

</td>

<td><p>32'h00004C4C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo21_CFG</a></p>

</td>

<td><p>32'h00004C50</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo21_START</a></p>

</td>

<td><p>32'h00004C54</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo21_CLEAR</a></p>

</td>

<td><p>32'h00004C58</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo21_FLUSH</a></p>

</td>

<td><p>32'h00004C5C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo22_CFG</a></p>

</td>

<td><p>32'h00004C60</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo22_START</a></p>

</td>

<td><p>32'h00004C64</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo22_CLEAR</a></p>

</td>

<td><p>32'h00004C68</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo22_FLUSH</a></p>

</td>

<td><p>32'h00004C6C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo23_CFG</a></p>

</td>

<td><p>32'h00004C70</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo23_START</a></p>

</td>

<td><p>32'h00004C74</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo23_CLEAR</a></p>

</td>

<td><p>32'h00004C78</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo23_FLUSH</a></p>

</td>

<td><p>32'h00004C7C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo24_CFG</a></p>

</td>

<td><p>32'h00004C80</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo24_START</a></p>

</td>

<td><p>32'h00004C84</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo24_CLEAR</a></p>

</td>

<td><p>32'h00004C88</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo24_FLUSH</a></p>

</td>

<td><p>32'h00004C8C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo25_CFG</a></p>

</td>

<td><p>32'h00004C90</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo25_START</a></p>

</td>

<td><p>32'h00004C94</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo25_CLEAR</a></p>

</td>

<td><p>32'h00004C98</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo25_FLUSH</a></p>

</td>

<td><p>32'h00004C9C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo26_CFG</a></p>

</td>

<td><p>32'h00004CA0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo26_START</a></p>

</td>

<td><p>32'h00004CA4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo26_CLEAR</a></p>

</td>

<td><p>32'h00004CA8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo26_FLUSH</a></p>

</td>

<td><p>32'h00004CAC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo27_CFG</a></p>

</td>

<td><p>32'h00004CB0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo27_START</a></p>

</td>

<td><p>32'h00004CB4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo27_CLEAR</a></p>

</td>

<td><p>32'h00004CB8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo27_FLUSH</a></p>

</td>

<td><p>32'h00004CBC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo28_CFG</a></p>

</td>

<td><p>32'h00004CC0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo28_START</a></p>

</td>

<td><p>32'h00004CC4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo28_CLEAR</a></p>

</td>

<td><p>32'h00004CC8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo28_FLUSH</a></p>

</td>

<td><p>32'h00004CCC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo29_CFG</a></p>

</td>

<td><p>32'h00004CD0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo29_START</a></p>

</td>

<td><p>32'h00004CD4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo29_CLEAR</a></p>

</td>

<td><p>32'h00004CD8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo29_FLUSH</a></p>

</td>

<td><p>32'h00004CDC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo30_CFG</a></p>

</td>

<td><p>32'h00004CE0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo30_START</a></p>

</td>

<td><p>32'h00004CE4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo30_CLEAR</a></p>

</td>

<td><p>32'h00004CE8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo30_FLUSH</a></p>

</td>

<td><p>32'h00004CEC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG">v64bDhub_dHub0_dHub_HBO_FiFo31_CFG</a></p>

</td>

<td><p>32'h00004CF0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[19:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CFG_BASE">BASE</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Base address (byte-address) of a FIFO in the shared SRAM. A 

channel's read/write pointers will be added to this “BASE” to 

get exact location of shared SRAM. 

Note: aligned with base SRAM data bus. 

For example, if SRAM data is 64-bit, then base[2:0] should be 

3'b0;</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START">v64bDhub_dHub0_dHub_HBO_FiFo31_START</a></p>

</td>

<td><p>32'h00004CF4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to this register will enable this channel, or 0 to this 

register will disable this channel.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR">v64bDhub_dHub0_dHub_HBO_FiFo31_CLEAR</a></p>

</td>

<td><p>32'h00004CF8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to clear FIFO pointers to 0. 

Note : 

CPU should make sure to disabled the channel (write 0 to 

START_EN register) before issue clear command, otherwise the 

clear request will be ignored. 

Do not restart the channel when clear operation is in process. 

HW will make sure there is no pending transactions before 

execute the clear operation. 

Associated semaphore cell needs reset separately by re-write 

“CFG_DEPTH”</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH">v64bDhub_dHub0_dHub_HBO_FiFo31_FLUSH</a></p>

</td>

<td><p>32'h00004CFC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#FiFo_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>No support for now</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#HBO_BUSY">v64bDhub_dHub0_dHub_HBO_BUSY</a></p>

</td>

<td><p>32'h00004D00</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#HBO_BUSY_ST">ST</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Per channel status 

Indicate the clear operation status. 

1: clear is in process. 

0 : clear is done.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl0_CFG</a></p>

</td>

<td><p>32'h00004E00</p>

</td>

<td><p>Up-to 16 channels</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl0_ROB_MAP</a></p>

</td>

<td><p>32'h00004E04</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl0_AWQOS</a></p>

</td>

<td><p>32'h00004E08</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl0_ARQOS</a></p>

</td>

<td><p>32'h00004E0C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl0_AWPARAMS</a></p>

</td>

<td><p>32'h00004E10</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl0_ARPARAMS</a></p>

</td>

<td><p>32'h00004E14</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl0_START</a></p>

</td>

<td><p>32'h00004E18</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl0_CLEAR</a></p>

</td>

<td><p>32'h00004E1C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl0_FLUSH</a></p>

</td>

<td><p>32'h00004E20</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl1_CFG</a></p>

</td>

<td><p>32'h00004E24</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl1_ROB_MAP</a></p>

</td>

<td><p>32'h00004E28</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl1_AWQOS</a></p>

</td>

<td><p>32'h00004E2C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl1_ARQOS</a></p>

</td>

<td><p>32'h00004E30</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl1_AWPARAMS</a></p>

</td>

<td><p>32'h00004E34</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl1_ARPARAMS</a></p>

</td>

<td><p>32'h00004E38</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl1_START</a></p>

</td>

<td><p>32'h00004E3C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl1_CLEAR</a></p>

</td>

<td><p>32'h00004E40</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl1_FLUSH</a></p>

</td>

<td><p>32'h00004E44</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl2_CFG</a></p>

</td>

<td><p>32'h00004E48</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl2_ROB_MAP</a></p>

</td>

<td><p>32'h00004E4C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl2_AWQOS</a></p>

</td>

<td><p>32'h00004E50</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl2_ARQOS</a></p>

</td>

<td><p>32'h00004E54</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl2_AWPARAMS</a></p>

</td>

<td><p>32'h00004E58</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl2_ARPARAMS</a></p>

</td>

<td><p>32'h00004E5C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl2_START</a></p>

</td>

<td><p>32'h00004E60</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl2_CLEAR</a></p>

</td>

<td><p>32'h00004E64</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl2_FLUSH</a></p>

</td>

<td><p>32'h00004E68</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl3_CFG</a></p>

</td>

<td><p>32'h00004E6C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl3_ROB_MAP</a></p>

</td>

<td><p>32'h00004E70</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl3_AWQOS</a></p>

</td>

<td><p>32'h00004E74</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl3_ARQOS</a></p>

</td>

<td><p>32'h00004E78</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl3_AWPARAMS</a></p>

</td>

<td><p>32'h00004E7C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl3_ARPARAMS</a></p>

</td>

<td><p>32'h00004E80</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl3_START</a></p>

</td>

<td><p>32'h00004E84</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl3_CLEAR</a></p>

</td>

<td><p>32'h00004E88</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl3_FLUSH</a></p>

</td>

<td><p>32'h00004E8C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl4_CFG</a></p>

</td>

<td><p>32'h00004E90</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl4_ROB_MAP</a></p>

</td>

<td><p>32'h00004E94</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl4_AWQOS</a></p>

</td>

<td><p>32'h00004E98</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl4_ARQOS</a></p>

</td>

<td><p>32'h00004E9C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl4_AWPARAMS</a></p>

</td>

<td><p>32'h00004EA0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl4_ARPARAMS</a></p>

</td>

<td><p>32'h00004EA4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl4_START</a></p>

</td>

<td><p>32'h00004EA8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl4_CLEAR</a></p>

</td>

<td><p>32'h00004EAC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl4_FLUSH</a></p>

</td>

<td><p>32'h00004EB0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl5_CFG</a></p>

</td>

<td><p>32'h00004EB4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl5_ROB_MAP</a></p>

</td>

<td><p>32'h00004EB8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl5_AWQOS</a></p>

</td>

<td><p>32'h00004EBC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl5_ARQOS</a></p>

</td>

<td><p>32'h00004EC0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl5_AWPARAMS</a></p>

</td>

<td><p>32'h00004EC4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl5_ARPARAMS</a></p>

</td>

<td><p>32'h00004EC8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl5_START</a></p>

</td>

<td><p>32'h00004ECC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl5_CLEAR</a></p>

</td>

<td><p>32'h00004ED0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl5_FLUSH</a></p>

</td>

<td><p>32'h00004ED4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl6_CFG</a></p>

</td>

<td><p>32'h00004ED8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl6_ROB_MAP</a></p>

</td>

<td><p>32'h00004EDC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl6_AWQOS</a></p>

</td>

<td><p>32'h00004EE0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl6_ARQOS</a></p>

</td>

<td><p>32'h00004EE4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl6_AWPARAMS</a></p>

</td>

<td><p>32'h00004EE8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl6_ARPARAMS</a></p>

</td>

<td><p>32'h00004EEC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl6_START</a></p>

</td>

<td><p>32'h00004EF0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl6_CLEAR</a></p>

</td>

<td><p>32'h00004EF4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl6_FLUSH</a></p>

</td>

<td><p>32'h00004EF8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl7_CFG</a></p>

</td>

<td><p>32'h00004EFC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl7_ROB_MAP</a></p>

</td>

<td><p>32'h00004F00</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl7_AWQOS</a></p>

</td>

<td><p>32'h00004F04</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl7_ARQOS</a></p>

</td>

<td><p>32'h00004F08</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl7_AWPARAMS</a></p>

</td>

<td><p>32'h00004F0C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl7_ARPARAMS</a></p>

</td>

<td><p>32'h00004F10</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl7_START</a></p>

</td>

<td><p>32'h00004F14</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl7_CLEAR</a></p>

</td>

<td><p>32'h00004F18</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl7_FLUSH</a></p>

</td>

<td><p>32'h00004F1C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl8_CFG</a></p>

</td>

<td><p>32'h00004F20</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl8_ROB_MAP</a></p>

</td>

<td><p>32'h00004F24</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl8_AWQOS</a></p>

</td>

<td><p>32'h00004F28</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl8_ARQOS</a></p>

</td>

<td><p>32'h00004F2C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl8_AWPARAMS</a></p>

</td>

<td><p>32'h00004F30</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl8_ARPARAMS</a></p>

</td>

<td><p>32'h00004F34</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl8_START</a></p>

</td>

<td><p>32'h00004F38</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl8_CLEAR</a></p>

</td>

<td><p>32'h00004F3C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl8_FLUSH</a></p>

</td>

<td><p>32'h00004F40</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl9_CFG</a></p>

</td>

<td><p>32'h00004F44</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl9_ROB_MAP</a></p>

</td>

<td><p>32'h00004F48</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl9_AWQOS</a></p>

</td>

<td><p>32'h00004F4C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl9_ARQOS</a></p>

</td>

<td><p>32'h00004F50</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl9_AWPARAMS</a></p>

</td>

<td><p>32'h00004F54</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl9_ARPARAMS</a></p>

</td>

<td><p>32'h00004F58</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl9_START</a></p>

</td>

<td><p>32'h00004F5C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl9_CLEAR</a></p>

</td>

<td><p>32'h00004F60</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl9_FLUSH</a></p>

</td>

<td><p>32'h00004F64</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl10_CFG</a></p>

</td>

<td><p>32'h00004F68</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl10_ROB_MAP</a></p>

</td>

<td><p>32'h00004F6C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl10_AWQOS</a></p>

</td>

<td><p>32'h00004F70</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl10_ARQOS</a></p>

</td>

<td><p>32'h00004F74</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl10_AWPARAMS</a></p>

</td>

<td><p>32'h00004F78</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl10_ARPARAMS</a></p>

</td>

<td><p>32'h00004F7C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl10_START</a></p>

</td>

<td><p>32'h00004F80</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl10_CLEAR</a></p>

</td>

<td><p>32'h00004F84</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl10_FLUSH</a></p>

</td>

<td><p>32'h00004F88</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl11_CFG</a></p>

</td>

<td><p>32'h00004F8C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl11_ROB_MAP</a></p>

</td>

<td><p>32'h00004F90</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl11_AWQOS</a></p>

</td>

<td><p>32'h00004F94</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl11_ARQOS</a></p>

</td>

<td><p>32'h00004F98</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl11_AWPARAMS</a></p>

</td>

<td><p>32'h00004F9C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl11_ARPARAMS</a></p>

</td>

<td><p>32'h00004FA0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl11_START</a></p>

</td>

<td><p>32'h00004FA4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl11_CLEAR</a></p>

</td>

<td><p>32'h00004FA8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl11_FLUSH</a></p>

</td>

<td><p>32'h00004FAC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl12_CFG</a></p>

</td>

<td><p>32'h00004FB0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl12_ROB_MAP</a></p>

</td>

<td><p>32'h00004FB4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl12_AWQOS</a></p>

</td>

<td><p>32'h00004FB8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl12_ARQOS</a></p>

</td>

<td><p>32'h00004FBC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl12_AWPARAMS</a></p>

</td>

<td><p>32'h00004FC0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl12_ARPARAMS</a></p>

</td>

<td><p>32'h00004FC4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl12_START</a></p>

</td>

<td><p>32'h00004FC8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl12_CLEAR</a></p>

</td>

<td><p>32'h00004FCC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl12_FLUSH</a></p>

</td>

<td><p>32'h00004FD0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl13_CFG</a></p>

</td>

<td><p>32'h00004FD4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl13_ROB_MAP</a></p>

</td>

<td><p>32'h00004FD8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl13_AWQOS</a></p>

</td>

<td><p>32'h00004FDC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl13_ARQOS</a></p>

</td>

<td><p>32'h00004FE0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl13_AWPARAMS</a></p>

</td>

<td><p>32'h00004FE4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl13_ARPARAMS</a></p>

</td>

<td><p>32'h00004FE8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl13_START</a></p>

</td>

<td><p>32'h00004FEC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl13_CLEAR</a></p>

</td>

<td><p>32'h00004FF0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl13_FLUSH</a></p>

</td>

<td><p>32'h00004FF4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl14_CFG</a></p>

</td>

<td><p>32'h00004FF8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl14_ROB_MAP</a></p>

</td>

<td><p>32'h00004FFC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl14_AWQOS</a></p>

</td>

<td><p>32'h00005000</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl14_ARQOS</a></p>

</td>

<td><p>32'h00005004</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl14_AWPARAMS</a></p>

</td>

<td><p>32'h00005008</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl14_ARPARAMS</a></p>

</td>

<td><p>32'h0000500C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl14_START</a></p>

</td>

<td><p>32'h00005010</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl14_CLEAR</a></p>

</td>

<td><p>32'h00005014</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl14_FLUSH</a></p>

</td>

<td><p>32'h00005018</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG">v64bDhub_dHub0_dHub_channelCtl15_CFG</a></p>

</td>

<td><p>32'h0000501C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_MTU">MTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Minimum transfer unit of the channel 

Values > 9 are set to 4096byte 

Important note for 64-bit dHubs: 

Cannot set to values >= 9. A full 256-beat burst of 8-bytes is 

2048 bytes. 

Behavior is unpredictable if set to MTU = 4KB.</p>

</td>

</tr>

<tr><td><p>[4:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_QoS">QoS</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to turn on QoS detection 

When QoS detection is on, AxQOS values is dynamically chosen 

from AxQOS.HI and AxQOS.LO</p>

</td>

</tr>

<tr><td><p>[5:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_selfLoop">selfLoop</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable cmd looping support; 0 to turn off</p>

</td>

</tr>

<tr><td><p>[6:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_intrCtl">intrCtl</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0 : default vlaue, the interrupt is triggered by the finish of 

the dHub command if the interrupt bit is defined in the dHub 

command. 

1 : The interrupt is triggered if the dHub channel is idle ( no 

busy and no pending and the corresponding dHub command Q is 

empty).</p>

</td>

</tr>

<tr><td><p>[7:7]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_hScan">hScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 1D dHub command for the channel. 

When scan is set to 1 (invScan), the data (beat) inside the dHub 

command will be fetched in the inverse order. ie. The data from 

the last address will come first and the data (beat) from the 

first address will come lastly.</p>

</td>

</tr>

<tr><td><p>[8:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CFG_vScan">vScan</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>This parameter will only apply to read channels. 

It will affect 2D channels. 

When scan is set to 1 (invScan), 

The last address line (1D command) will be fetched first, and 

the first address line will be fetched lastly. 

Note: This parameter cannot be set to 1 if MTU results in > 

256byte. The cost of using a > 256byte buffer in current 

architecture is too much.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP">v64bDhub_dHub0_dHub_channelCtl15_ROB_MAP</a></p>

</td>

<td><p>32'h00005020</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ROB_MAP_ID">ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Maps a read channel to this ROB index. 

A user can configure from 1 to the number of read channel number 

of hardware ROBs. (Using .cfg) 

This field will map this channel if it is a read channel to the 

ROB specified here. Has no effect on write channels. 

ROBs are indexed from 0 to NUM_ROB-1 

If the setting is invalid, ie ID > NUM_ROB-1, then HW will remap 

it to 0.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS">v64bDhub_dHub0_dHub_channelCtl15_AWQOS</a></p>

</td>

<td><p>32'h00005024</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>AWQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>AWQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS">v64bDhub_dHub0_dHub_channelCtl15_ARQOS</a></p>

</td>

<td><p>32'h00005028</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[3:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_LO">LO</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>ARQOS value when low priority</p>

</td>

</tr>

<tr><td><p>[7:4]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARQOS_HI">HI</a></p>

</td>

<td><p>0xF</p>

</td>

<td><p>ARQOS value when high priority</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS">v64bDhub_dHub0_dHub_channelCtl15_AWPARAMS</a></p>

</td>

<td><p>32'h0000502C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWUSER[15:10] value. Whether upper four bits is 

sent out the AXI interface is determined by USER_HI_EN bit. 

AWUSER[9:0] is controlled by dHubCmd</p>

</td>

</tr>

<tr><td><p>[13:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:1] value. AWCACHE[0], non-bufferable bit, 

is controlled by dHub hardware</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_AWPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: AWUSER[15:12] = Channel ID 

1: AWUSER[15:12] = AWPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of AWUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS">v64bDhub_dHub0_dHub_channelCtl15_ARPARAMS</a></p>

</td>

<td><p>32'h00005030</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[1:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_LOCK">LOCK</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARLOCK[1:0] value</p>

</td>

</tr>

<tr><td><p>[4:2]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_PROT">PROT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARPROT[2:0] value</p>

</td>

</tr>

<tr><td><p>[10:5]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER">USER</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable ARUSER[15:10] value. ARUSER[9:0] is controlled by 

dHubCmd</p>

</td>

</tr>

<tr><td><p>[14:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_CACHE">CACHE</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Programmable AWCACHE[3:0] value</p>

</td>

</tr>

<tr><td><p>[15:15]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_ARPARAMS_USER_HI_EN">USER_HI_EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: ARUSER[15:12] = Channel ID 

1: ARUSER[15:12] = ARPARAMS.USER[5:2] 

If user does not configure dHub with Multi ID Enabled but wants 

to identify the originating channel of the transaction, the 

user can use the MSB of ARUSER for this purpose.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START">v64bDhub_dHub0_dHub_channelCtl15_START</a></p>

</td>

<td><p>32'h00005034</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR">v64bDhub_dHub0_dHub_channelCtl15_CLEAR</a></p>

</td>

<td><p>32'h00005038</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the channel controller state</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH">v64bDhub_dHub0_dHub_channelCtl15_FLUSH</a></p>

</td>

<td><p>32'h0000503C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubChannel_FLUSH_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to start the data flushing process. Invalid for 

read (M2H) channels 

end dHubChannel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_BUSY">v64bDhub_dHub0_dHub_BUSY</a></p>

</td>

<td><p>32'h00005040</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_BUSY_ST">ST</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Per channel status 

0: no ongoing command is being processed, and no flushing is 

taking place 

1: channel controller is busy</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_PENDING">v64bDhub_dHub0_dHub_PENDING</a></p>

</td>

<td><p>32'h00005044</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_PENDING_ST">ST</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Per channel status 

0: Response queue is empty, meaning no outstanding AXI 

transactions 

1: there exist some outstanding AXI transactions</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_busRstEn">v64bDhub_dHub0_dHub_busRstEn</a></p>

</td>

<td><p>32'h00005048</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_busRstEn_reg">reg</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write one to this register will trigger gate-keeper to take over 

the AXI bus.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_busRstDone">v64bDhub_dHub0_dHub_busRstDone</a></p>

</td>

<td><p>32'h0000504C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_busRstDone_reg">reg</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>After gate-keeper take over the AXI bus, it will assert this bit 

once there is no outstanding transactions on AXI bus.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_flowCtl">v64bDhub_dHub0_dHub_flowCtl</a></p>

</td>

<td><p>32'h00005050</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_flowCtl_rAlpha">rAlpha</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[15:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_flowCtl_wAlpha">wAlpha</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Flow control parameter for read and write axi master. 

clkCnt=(alpha*bstLen) > >4. 

This # of clock cycles will be blocked for the axi master after 

an axi command with the burst length of “bstLen”. 

When set alpha to be 0, the master will never be blocked.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_axiCmdCol">v64bDhub_dHub0_dHub_axiCmdCol</a></p>

</td>

<td><p>32'h00005054</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_axiCmdCol_rCnt">rCnt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>[31:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_axiCmdCol_wCnt">wCnt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Axi command collection. The counter value indicate read/write do 

the command collection for # of clock cycles, start from the 

first command pushed to an empty command Q. Here are the 

conditions that will trigger the Axi master to send out 

command. 

Cmd Q full or the counter count down to “0” from the programmed 

value. 

Set the counter to 0 will disable the command collection.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_axiMultiIdEn">v64bDhub_dHub0_dHub_axiMultiIdEn</a></p>

</td>

<td><p>32'h00005058</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg_axiMultiIdEn_reg">reg</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When 0, the read channel will have AXI_ID = ROB_ID. ROB_ID is 

dependent on which ROB the read channel is mapped to in 

dHubChannel.ROB_MAP.ID 

write channel will have AXI_ID = 0. 

Write one to this register to enable multi-ID support. 

Multi-ID when enabled will issue AXI IDs = channel number for 

each AXI transaction. 

Note: If set to 1, the read slave return must never interleave 

RIDs. If slave return interleaves RID, this bit must never be 

set to 1. 

end dHubReg</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D0_MEM</a></p>

</td>

<td><p>32'h00005100</p>

</td>

<td><p>Up-to 16 2D channels. 

2D Channel[N] is connected to dHub.Channel[N] command queue, 

that is, dHub.HBO.Channel[2N] 

Note: Number of 2D channels could be less than dHub channels 

(rest of are 1D only)</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D0_DESC</a></p>

</td>

<td><p>32'h00005104</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D0_START</a></p>

</td>

<td><p>32'h00005108</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D0_CLEAR</a></p>

</td>

<td><p>32'h0000510C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D0_HDR0_DESC</a></p>

</td>

<td><p>32'h00005110</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D0_HDR1_DESC</a></p>

</td>

<td><p>32'h00005114</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D0_HDR2_DESC</a></p>

</td>

<td><p>32'h00005118</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D0_HDR3_DESC</a></p>

</td>

<td><p>32'h0000511C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D1_MEM</a></p>

</td>

<td><p>32'h00005120</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D1_DESC</a></p>

</td>

<td><p>32'h00005124</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D1_START</a></p>

</td>

<td><p>32'h00005128</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D1_CLEAR</a></p>

</td>

<td><p>32'h0000512C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D1_HDR0_DESC</a></p>

</td>

<td><p>32'h00005130</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D1_HDR1_DESC</a></p>

</td>

<td><p>32'h00005134</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D1_HDR2_DESC</a></p>

</td>

<td><p>32'h00005138</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D1_HDR3_DESC</a></p>

</td>

<td><p>32'h0000513C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D2_MEM</a></p>

</td>

<td><p>32'h00005140</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D2_DESC</a></p>

</td>

<td><p>32'h00005144</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D2_START</a></p>

</td>

<td><p>32'h00005148</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D2_CLEAR</a></p>

</td>

<td><p>32'h0000514C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D2_HDR0_DESC</a></p>

</td>

<td><p>32'h00005150</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D2_HDR1_DESC</a></p>

</td>

<td><p>32'h00005154</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D2_HDR2_DESC</a></p>

</td>

<td><p>32'h00005158</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D2_HDR3_DESC</a></p>

</td>

<td><p>32'h0000515C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D3_MEM</a></p>

</td>

<td><p>32'h00005160</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D3_DESC</a></p>

</td>

<td><p>32'h00005164</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D3_START</a></p>

</td>

<td><p>32'h00005168</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D3_CLEAR</a></p>

</td>

<td><p>32'h0000516C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D3_HDR0_DESC</a></p>

</td>

<td><p>32'h00005170</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D3_HDR1_DESC</a></p>

</td>

<td><p>32'h00005174</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D3_HDR2_DESC</a></p>

</td>

<td><p>32'h00005178</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D3_HDR3_DESC</a></p>

</td>

<td><p>32'h0000517C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D4_MEM</a></p>

</td>

<td><p>32'h00005180</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D4_DESC</a></p>

</td>

<td><p>32'h00005184</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D4_START</a></p>

</td>

<td><p>32'h00005188</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D4_CLEAR</a></p>

</td>

<td><p>32'h0000518C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D4_HDR0_DESC</a></p>

</td>

<td><p>32'h00005190</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D4_HDR1_DESC</a></p>

</td>

<td><p>32'h00005194</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D4_HDR2_DESC</a></p>

</td>

<td><p>32'h00005198</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D4_HDR3_DESC</a></p>

</td>

<td><p>32'h0000519C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D5_MEM</a></p>

</td>

<td><p>32'h000051A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D5_DESC</a></p>

</td>

<td><p>32'h000051A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D5_START</a></p>

</td>

<td><p>32'h000051A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D5_CLEAR</a></p>

</td>

<td><p>32'h000051AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D5_HDR0_DESC</a></p>

</td>

<td><p>32'h000051B0</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D5_HDR1_DESC</a></p>

</td>

<td><p>32'h000051B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D5_HDR2_DESC</a></p>

</td>

<td><p>32'h000051B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D5_HDR3_DESC</a></p>

</td>

<td><p>32'h000051BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D6_MEM</a></p>

</td>

<td><p>32'h000051C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D6_DESC</a></p>

</td>

<td><p>32'h000051C4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D6_START</a></p>

</td>

<td><p>32'h000051C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D6_CLEAR</a></p>

</td>

<td><p>32'h000051CC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D6_HDR0_DESC</a></p>

</td>

<td><p>32'h000051D0</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D6_HDR1_DESC</a></p>

</td>

<td><p>32'h000051D4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D6_HDR2_DESC</a></p>

</td>

<td><p>32'h000051D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D6_HDR3_DESC</a></p>

</td>

<td><p>32'h000051DC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D7_MEM</a></p>

</td>

<td><p>32'h000051E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D7_DESC</a></p>

</td>

<td><p>32'h000051E4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D7_START</a></p>

</td>

<td><p>32'h000051E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D7_CLEAR</a></p>

</td>

<td><p>32'h000051EC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D7_HDR0_DESC</a></p>

</td>

<td><p>32'h000051F0</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D7_HDR1_DESC</a></p>

</td>

<td><p>32'h000051F4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D7_HDR2_DESC</a></p>

</td>

<td><p>32'h000051F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D7_HDR3_DESC</a></p>

</td>

<td><p>32'h000051FC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D8_MEM</a></p>

</td>

<td><p>32'h00005200</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D8_DESC</a></p>

</td>

<td><p>32'h00005204</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D8_START</a></p>

</td>

<td><p>32'h00005208</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D8_CLEAR</a></p>

</td>

<td><p>32'h0000520C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D8_HDR0_DESC</a></p>

</td>

<td><p>32'h00005210</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D8_HDR1_DESC</a></p>

</td>

<td><p>32'h00005214</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D8_HDR2_DESC</a></p>

</td>

<td><p>32'h00005218</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D8_HDR3_DESC</a></p>

</td>

<td><p>32'h0000521C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D9_MEM</a></p>

</td>

<td><p>32'h00005220</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D9_DESC</a></p>

</td>

<td><p>32'h00005224</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D9_START</a></p>

</td>

<td><p>32'h00005228</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D9_CLEAR</a></p>

</td>

<td><p>32'h0000522C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D9_HDR0_DESC</a></p>

</td>

<td><p>32'h00005230</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D9_HDR1_DESC</a></p>

</td>

<td><p>32'h00005234</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D9_HDR2_DESC</a></p>

</td>

<td><p>32'h00005238</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D9_HDR3_DESC</a></p>

</td>

<td><p>32'h0000523C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D10_MEM</a></p>

</td>

<td><p>32'h00005240</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D10_DESC</a></p>

</td>

<td><p>32'h00005244</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D10_START</a></p>

</td>

<td><p>32'h00005248</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D10_CLEAR</a></p>

</td>

<td><p>32'h0000524C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D10_HDR0_DESC</a></p>

</td>

<td><p>32'h00005250</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D10_HDR1_DESC</a></p>

</td>

<td><p>32'h00005254</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D10_HDR2_DESC</a></p>

</td>

<td><p>32'h00005258</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D10_HDR3_DESC</a></p>

</td>

<td><p>32'h0000525C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D11_MEM</a></p>

</td>

<td><p>32'h00005260</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D11_DESC</a></p>

</td>

<td><p>32'h00005264</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D11_START</a></p>

</td>

<td><p>32'h00005268</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D11_CLEAR</a></p>

</td>

<td><p>32'h0000526C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D11_HDR0_DESC</a></p>

</td>

<td><p>32'h00005270</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D11_HDR1_DESC</a></p>

</td>

<td><p>32'h00005274</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D11_HDR2_DESC</a></p>

</td>

<td><p>32'h00005278</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D11_HDR3_DESC</a></p>

</td>

<td><p>32'h0000527C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D12_MEM</a></p>

</td>

<td><p>32'h00005280</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D12_DESC</a></p>

</td>

<td><p>32'h00005284</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D12_START</a></p>

</td>

<td><p>32'h00005288</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D12_CLEAR</a></p>

</td>

<td><p>32'h0000528C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D12_HDR0_DESC</a></p>

</td>

<td><p>32'h00005290</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D12_HDR1_DESC</a></p>

</td>

<td><p>32'h00005294</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D12_HDR2_DESC</a></p>

</td>

<td><p>32'h00005298</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D12_HDR3_DESC</a></p>

</td>

<td><p>32'h0000529C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D13_MEM</a></p>

</td>

<td><p>32'h000052A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D13_DESC</a></p>

</td>

<td><p>32'h000052A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D13_START</a></p>

</td>

<td><p>32'h000052A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D13_CLEAR</a></p>

</td>

<td><p>32'h000052AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D13_HDR0_DESC</a></p>

</td>

<td><p>32'h000052B0</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D13_HDR1_DESC</a></p>

</td>

<td><p>32'h000052B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D13_HDR2_DESC</a></p>

</td>

<td><p>32'h000052B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D13_HDR3_DESC</a></p>

</td>

<td><p>32'h000052BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D14_MEM</a></p>

</td>

<td><p>32'h000052C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D14_DESC</a></p>

</td>

<td><p>32'h000052C4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D14_START</a></p>

</td>

<td><p>32'h000052C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D14_CLEAR</a></p>

</td>

<td><p>32'h000052CC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D14_HDR0_DESC</a></p>

</td>

<td><p>32'h000052D0</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D14_HDR1_DESC</a></p>

</td>

<td><p>32'h000052D4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D14_HDR2_DESC</a></p>

</td>

<td><p>32'h000052D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D14_HDR3_DESC</a></p>

</td>

<td><p>32'h000052DC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM">v64bDhub_dHub0_Cmd2D15_MEM</a></p>

</td>

<td><p>32'h000052E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_MEM_addr">addr</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC">v64bDhub_dHub0_Cmd2D15_DESC</a></p>

</td>

<td><p>32'h000052E4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_stride">stride</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Line stride size in bytes</p>

</td>

</tr>

<tr><td><p>[28:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_numLine">numLine</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Number of lines in buffer. Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[30:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_hdrLoop">hdrLoop</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Size of line-loop for choosing dHubCmdHDR 

0 is treated as 4</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

1: set the last 1D command interrupt bit. 

0 : use the default 1D command interrupt bit.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START">v64bDhub_dHub0_Cmd2D15_START</a></p>

</td>

<td><p>32'h000052E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel; 0 to pause the channel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR">v64bDhub_dHub0_Cmd2D15_CLEAR</a></p>

</td>

<td><p>32'h000052EC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2D_CLEAR_EN">EN</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Write anything to reset the 2D engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D15_HDR0_DESC</a></p>

</td>

<td><p>32'h000052F0</p>

</td>

<td><p>Headers used in generating dHubCmd for each line in looping 

order, loop size (1,2,3,4) specified by DESC_hdrLoop 

end dHubCmd2D</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D15_HDR1_DESC</a></p>

</td>

<td><p>32'h000052F4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D15_HDR2_DESC</a></p>

</td>

<td><p>32'h000052F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC">v64bDhub_dHub0_Cmd2D15_HDR3_DESC</a></p>

</td>

<td><p>32'h000052FC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_size">size</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>amount of data to be transferred, in bytes or MTU. 

Size of 0 is forbidden.</p>

</td>

</tr>

<tr><td><p>[16:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_sizeMTU">sizeMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: size given in bytes; 

1: size given in MTU (see dHubChCtl.CFG.MTU for MTU size 

definition)</p>

</td>

</tr>

<tr><td><p>[17:17]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_semOpMTU">semOpMTU</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: semaphore operations applied on dHubCmd level 

1: semaphore operations applied on MTU level</p>

</td>

</tr>

<tr><td><p>[22:18]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to check before cmd / MTU; 

0 indicates semaphore check is disabled</p>

</td>

</tr>

<tr><td><p>[27:23]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_updSemId">updSemId</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>ID of semaphore to update after cmd / MTU; 

0 indicates semaphore update is disabled</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_interrupt">interrupt</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>1: raise interrupt upon command finish</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0: AxQOS selection between HI value and LO value is a function 

of FIFO occupancy 

1: AxQOS selection between HI value and LO value is determined 

by qosSel in dHubCmd</p>

</td>

</tr>

<tr><td><p>[30:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_disSem">disSem</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Changes the way the *SemId 10-bit field are used. 

0: 

updSemId and chkSemId operates as normal, AxUser[9:0] = 0; 

1: 

Disables updSemId and chkSemId, 

AxUser[9:0] = {updSemId[4:0], chkSemId[4:0]}</p>

</td>

</tr>

<tr><td><p>[31:31]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmdHDR_DESC_qosSel">qosSel</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>0 : Select dHubChannel.AxQOS.LO value 

1 : Select dHubChannel.AxQOS.HI value 

end dHubCmdHDR</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND0_MEM</a></p>

</td>

<td><p>32'h00005300</p>

</td>

<td><p>Up-to 16 2ND channels. 

2ND Channel[N] is connected to dHub.Channel[N] command queue, 

that is, dHub.HBO.Channel[2N] 

Note: 2ND engines are instantiated in the same way as the old 2D 

engine. It is allowed to have multiple 1D, 2D, 2ND and 4ND 

channels in a dHub. Restriction is each channel can only have 

one type.</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND0_DESC</a></p>

</td>

<td><p>32'h00005304</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND0_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005308</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND0_DESC_1D_SZ</a></p>

</td>

<td><p>32'h0000530C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND0_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005310</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND0_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005314</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND0_START</a></p>

</td>

<td><p>32'h00005318</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND0_CLEAR</a></p>

</td>

<td><p>32'h0000531C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND1_MEM</a></p>

</td>

<td><p>32'h00005320</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND1_DESC</a></p>

</td>

<td><p>32'h00005324</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND1_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005328</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND1_DESC_1D_SZ</a></p>

</td>

<td><p>32'h0000532C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND1_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005330</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND1_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005334</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND1_START</a></p>

</td>

<td><p>32'h00005338</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND1_CLEAR</a></p>

</td>

<td><p>32'h0000533C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND2_MEM</a></p>

</td>

<td><p>32'h00005340</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND2_DESC</a></p>

</td>

<td><p>32'h00005344</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND2_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005348</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND2_DESC_1D_SZ</a></p>

</td>

<td><p>32'h0000534C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND2_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005350</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND2_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005354</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND2_START</a></p>

</td>

<td><p>32'h00005358</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND2_CLEAR</a></p>

</td>

<td><p>32'h0000535C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND3_MEM</a></p>

</td>

<td><p>32'h00005360</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND3_DESC</a></p>

</td>

<td><p>32'h00005364</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND3_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005368</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND3_DESC_1D_SZ</a></p>

</td>

<td><p>32'h0000536C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND3_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005370</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND3_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005374</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND3_START</a></p>

</td>

<td><p>32'h00005378</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND3_CLEAR</a></p>

</td>

<td><p>32'h0000537C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND4_MEM</a></p>

</td>

<td><p>32'h00005380</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND4_DESC</a></p>

</td>

<td><p>32'h00005384</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND4_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005388</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND4_DESC_1D_SZ</a></p>

</td>

<td><p>32'h0000538C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND4_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005390</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND4_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005394</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND4_START</a></p>

</td>

<td><p>32'h00005398</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND4_CLEAR</a></p>

</td>

<td><p>32'h0000539C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND5_MEM</a></p>

</td>

<td><p>32'h000053A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND5_DESC</a></p>

</td>

<td><p>32'h000053A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND5_DESC_1D_ST</a></p>

</td>

<td><p>32'h000053A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND5_DESC_1D_SZ</a></p>

</td>

<td><p>32'h000053AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND5_DESC_2D_ST</a></p>

</td>

<td><p>32'h000053B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND5_DESC_2D_SZ</a></p>

</td>

<td><p>32'h000053B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND5_START</a></p>

</td>

<td><p>32'h000053B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND5_CLEAR</a></p>

</td>

<td><p>32'h000053BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND6_MEM</a></p>

</td>

<td><p>32'h000053C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND6_DESC</a></p>

</td>

<td><p>32'h000053C4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND6_DESC_1D_ST</a></p>

</td>

<td><p>32'h000053C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND6_DESC_1D_SZ</a></p>

</td>

<td><p>32'h000053CC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND6_DESC_2D_ST</a></p>

</td>

<td><p>32'h000053D0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND6_DESC_2D_SZ</a></p>

</td>

<td><p>32'h000053D4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND6_START</a></p>

</td>

<td><p>32'h000053D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND6_CLEAR</a></p>

</td>

<td><p>32'h000053DC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND7_MEM</a></p>

</td>

<td><p>32'h000053E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND7_DESC</a></p>

</td>

<td><p>32'h000053E4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND7_DESC_1D_ST</a></p>

</td>

<td><p>32'h000053E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND7_DESC_1D_SZ</a></p>

</td>

<td><p>32'h000053EC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND7_DESC_2D_ST</a></p>

</td>

<td><p>32'h000053F0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND7_DESC_2D_SZ</a></p>

</td>

<td><p>32'h000053F4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND7_START</a></p>

</td>

<td><p>32'h000053F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND7_CLEAR</a></p>

</td>

<td><p>32'h000053FC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND8_MEM</a></p>

</td>

<td><p>32'h00005400</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND8_DESC</a></p>

</td>

<td><p>32'h00005404</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND8_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005408</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND8_DESC_1D_SZ</a></p>

</td>

<td><p>32'h0000540C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND8_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005410</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND8_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005414</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND8_START</a></p>

</td>

<td><p>32'h00005418</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND8_CLEAR</a></p>

</td>

<td><p>32'h0000541C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND9_MEM</a></p>

</td>

<td><p>32'h00005420</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND9_DESC</a></p>

</td>

<td><p>32'h00005424</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND9_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005428</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND9_DESC_1D_SZ</a></p>

</td>

<td><p>32'h0000542C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND9_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005430</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND9_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005434</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND9_START</a></p>

</td>

<td><p>32'h00005438</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND9_CLEAR</a></p>

</td>

<td><p>32'h0000543C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND10_MEM</a></p>

</td>

<td><p>32'h00005440</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND10_DESC</a></p>

</td>

<td><p>32'h00005444</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND10_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005448</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND10_DESC_1D_SZ</a></p>

</td>

<td><p>32'h0000544C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND10_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005450</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND10_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005454</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND10_START</a></p>

</td>

<td><p>32'h00005458</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND10_CLEAR</a></p>

</td>

<td><p>32'h0000545C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND11_MEM</a></p>

</td>

<td><p>32'h00005460</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND11_DESC</a></p>

</td>

<td><p>32'h00005464</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND11_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005468</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND11_DESC_1D_SZ</a></p>

</td>

<td><p>32'h0000546C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND11_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005470</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND11_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005474</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND11_START</a></p>

</td>

<td><p>32'h00005478</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND11_CLEAR</a></p>

</td>

<td><p>32'h0000547C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND12_MEM</a></p>

</td>

<td><p>32'h00005480</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND12_DESC</a></p>

</td>

<td><p>32'h00005484</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND12_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005488</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND12_DESC_1D_SZ</a></p>

</td>

<td><p>32'h0000548C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND12_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005490</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND12_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005494</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND12_START</a></p>

</td>

<td><p>32'h00005498</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND12_CLEAR</a></p>

</td>

<td><p>32'h0000549C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND13_MEM</a></p>

</td>

<td><p>32'h000054A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND13_DESC</a></p>

</td>

<td><p>32'h000054A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND13_DESC_1D_ST</a></p>

</td>

<td><p>32'h000054A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND13_DESC_1D_SZ</a></p>

</td>

<td><p>32'h000054AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND13_DESC_2D_ST</a></p>

</td>

<td><p>32'h000054B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND13_DESC_2D_SZ</a></p>

</td>

<td><p>32'h000054B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND13_START</a></p>

</td>

<td><p>32'h000054B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND13_CLEAR</a></p>

</td>

<td><p>32'h000054BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND14_MEM</a></p>

</td>

<td><p>32'h000054C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND14_DESC</a></p>

</td>

<td><p>32'h000054C4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND14_DESC_1D_ST</a></p>

</td>

<td><p>32'h000054C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND14_DESC_1D_SZ</a></p>

</td>

<td><p>32'h000054CC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND14_DESC_2D_ST</a></p>

</td>

<td><p>32'h000054D0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND14_DESC_2D_SZ</a></p>

</td>

<td><p>32'h000054D4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND14_START</a></p>

</td>

<td><p>32'h000054D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND14_CLEAR</a></p>

</td>

<td><p>32'h000054DC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM">v64bDhub_dHub0_Cmd2ND15_MEM</a></p>

</td>

<td><p>32'h000054E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 2D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC">v64bDhub_dHub0_Cmd2ND15_DESC</a></p>

</td>

<td><p>32'h000054E4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

2ND engine</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 2D command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 2D 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST">v64bDhub_dHub0_Cmd2ND15_DESC_1D_ST</a></p>

</td>

<td><p>32'h000054E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd2ND15_DESC_1D_SZ</a></p>

</td>

<td><p>32'h000054EC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST">v64bDhub_dHub0_Cmd2ND15_DESC_2D_ST</a></p>

</td>

<td><p>32'h000054F0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd2ND15_DESC_2D_SZ</a></p>

</td>

<td><p>32'h000054F4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START">v64bDhub_dHub0_Cmd2ND15_START</a></p>

</td>

<td><p>32'h000054F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 2D buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR">v64bDhub_dHub0_Cmd2ND15_CLEAR</a></p>

</td>

<td><p>32'h000054FC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd2ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 2D engine. 

end dHubCmd2ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND0_MEM</a></p>

</td>

<td><p>32'h00005500</p>

</td>

<td><p>Up-to 16 4ND channels. 

4ND Channel[N] is connected to dHub.Channel[N] command queue, 

that is, dHub.HBO.Channel[2N] 

Note: 4ND engines are instantiated in the same way as the old 2D 

engine. It is allowed to have multiple 1D, 2D, 2ND and 4ND 

channels in a dHub. Restriction is each channel can only have 

one type.</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND0_DESC</a></p>

</td>

<td><p>32'h00005504</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND0_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005508</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND0_DESC_1D_SZ</a></p>

</td>

<td><p>32'h0000550C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND0_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005510</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND0_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005514</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND0_DESC_3D_ST</a></p>

</td>

<td><p>32'h00005518</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND0_DESC_3D_SZ</a></p>

</td>

<td><p>32'h0000551C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND0_DESC_4D_ST</a></p>

</td>

<td><p>32'h00005520</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND0_DESC_4D_SZ</a></p>

</td>

<td><p>32'h00005524</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND0_START</a></p>

</td>

<td><p>32'h00005528</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND0_CLEAR</a></p>

</td>

<td><p>32'h0000552C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND0_FLEXA</a></p>

</td>

<td><p>32'h00005530</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND0_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h00005534</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND0_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h00005538</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND1_MEM</a></p>

</td>

<td><p>32'h0000553C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND1_DESC</a></p>

</td>

<td><p>32'h00005540</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND1_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005544</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND1_DESC_1D_SZ</a></p>

</td>

<td><p>32'h00005548</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND1_DESC_2D_ST</a></p>

</td>

<td><p>32'h0000554C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND1_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005550</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND1_DESC_3D_ST</a></p>

</td>

<td><p>32'h00005554</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND1_DESC_3D_SZ</a></p>

</td>

<td><p>32'h00005558</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND1_DESC_4D_ST</a></p>

</td>

<td><p>32'h0000555C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND1_DESC_4D_SZ</a></p>

</td>

<td><p>32'h00005560</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND1_START</a></p>

</td>

<td><p>32'h00005564</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND1_CLEAR</a></p>

</td>

<td><p>32'h00005568</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND1_FLEXA</a></p>

</td>

<td><p>32'h0000556C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND1_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h00005570</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND1_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h00005574</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND2_MEM</a></p>

</td>

<td><p>32'h00005578</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND2_DESC</a></p>

</td>

<td><p>32'h0000557C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND2_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005580</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND2_DESC_1D_SZ</a></p>

</td>

<td><p>32'h00005584</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND2_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005588</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND2_DESC_2D_SZ</a></p>

</td>

<td><p>32'h0000558C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND2_DESC_3D_ST</a></p>

</td>

<td><p>32'h00005590</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND2_DESC_3D_SZ</a></p>

</td>

<td><p>32'h00005594</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND2_DESC_4D_ST</a></p>

</td>

<td><p>32'h00005598</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND2_DESC_4D_SZ</a></p>

</td>

<td><p>32'h0000559C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND2_START</a></p>

</td>

<td><p>32'h000055A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND2_CLEAR</a></p>

</td>

<td><p>32'h000055A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND2_FLEXA</a></p>

</td>

<td><p>32'h000055A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND2_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h000055AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND2_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h000055B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND3_MEM</a></p>

</td>

<td><p>32'h000055B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND3_DESC</a></p>

</td>

<td><p>32'h000055B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND3_DESC_1D_ST</a></p>

</td>

<td><p>32'h000055BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND3_DESC_1D_SZ</a></p>

</td>

<td><p>32'h000055C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND3_DESC_2D_ST</a></p>

</td>

<td><p>32'h000055C4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND3_DESC_2D_SZ</a></p>

</td>

<td><p>32'h000055C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND3_DESC_3D_ST</a></p>

</td>

<td><p>32'h000055CC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND3_DESC_3D_SZ</a></p>

</td>

<td><p>32'h000055D0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND3_DESC_4D_ST</a></p>

</td>

<td><p>32'h000055D4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND3_DESC_4D_SZ</a></p>

</td>

<td><p>32'h000055D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND3_START</a></p>

</td>

<td><p>32'h000055DC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND3_CLEAR</a></p>

</td>

<td><p>32'h000055E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND3_FLEXA</a></p>

</td>

<td><p>32'h000055E4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND3_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h000055E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND3_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h000055EC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND4_MEM</a></p>

</td>

<td><p>32'h000055F0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND4_DESC</a></p>

</td>

<td><p>32'h000055F4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND4_DESC_1D_ST</a></p>

</td>

<td><p>32'h000055F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND4_DESC_1D_SZ</a></p>

</td>

<td><p>32'h000055FC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND4_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005600</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND4_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005604</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND4_DESC_3D_ST</a></p>

</td>

<td><p>32'h00005608</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND4_DESC_3D_SZ</a></p>

</td>

<td><p>32'h0000560C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND4_DESC_4D_ST</a></p>

</td>

<td><p>32'h00005610</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND4_DESC_4D_SZ</a></p>

</td>

<td><p>32'h00005614</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND4_START</a></p>

</td>

<td><p>32'h00005618</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND4_CLEAR</a></p>

</td>

<td><p>32'h0000561C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND4_FLEXA</a></p>

</td>

<td><p>32'h00005620</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND4_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h00005624</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND4_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h00005628</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND5_MEM</a></p>

</td>

<td><p>32'h0000562C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND5_DESC</a></p>

</td>

<td><p>32'h00005630</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND5_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005634</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND5_DESC_1D_SZ</a></p>

</td>

<td><p>32'h00005638</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND5_DESC_2D_ST</a></p>

</td>

<td><p>32'h0000563C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND5_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005640</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND5_DESC_3D_ST</a></p>

</td>

<td><p>32'h00005644</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND5_DESC_3D_SZ</a></p>

</td>

<td><p>32'h00005648</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND5_DESC_4D_ST</a></p>

</td>

<td><p>32'h0000564C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND5_DESC_4D_SZ</a></p>

</td>

<td><p>32'h00005650</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND5_START</a></p>

</td>

<td><p>32'h00005654</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND5_CLEAR</a></p>

</td>

<td><p>32'h00005658</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND5_FLEXA</a></p>

</td>

<td><p>32'h0000565C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND5_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h00005660</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND5_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h00005664</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND6_MEM</a></p>

</td>

<td><p>32'h00005668</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND6_DESC</a></p>

</td>

<td><p>32'h0000566C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND6_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005670</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND6_DESC_1D_SZ</a></p>

</td>

<td><p>32'h00005674</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND6_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005678</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND6_DESC_2D_SZ</a></p>

</td>

<td><p>32'h0000567C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND6_DESC_3D_ST</a></p>

</td>

<td><p>32'h00005680</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND6_DESC_3D_SZ</a></p>

</td>

<td><p>32'h00005684</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND6_DESC_4D_ST</a></p>

</td>

<td><p>32'h00005688</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND6_DESC_4D_SZ</a></p>

</td>

<td><p>32'h0000568C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND6_START</a></p>

</td>

<td><p>32'h00005690</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND6_CLEAR</a></p>

</td>

<td><p>32'h00005694</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND6_FLEXA</a></p>

</td>

<td><p>32'h00005698</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND6_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h0000569C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND6_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h000056A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND7_MEM</a></p>

</td>

<td><p>32'h000056A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND7_DESC</a></p>

</td>

<td><p>32'h000056A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND7_DESC_1D_ST</a></p>

</td>

<td><p>32'h000056AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND7_DESC_1D_SZ</a></p>

</td>

<td><p>32'h000056B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND7_DESC_2D_ST</a></p>

</td>

<td><p>32'h000056B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND7_DESC_2D_SZ</a></p>

</td>

<td><p>32'h000056B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND7_DESC_3D_ST</a></p>

</td>

<td><p>32'h000056BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND7_DESC_3D_SZ</a></p>

</td>

<td><p>32'h000056C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND7_DESC_4D_ST</a></p>

</td>

<td><p>32'h000056C4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND7_DESC_4D_SZ</a></p>

</td>

<td><p>32'h000056C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND7_START</a></p>

</td>

<td><p>32'h000056CC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND7_CLEAR</a></p>

</td>

<td><p>32'h000056D0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND7_FLEXA</a></p>

</td>

<td><p>32'h000056D4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND7_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h000056D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND7_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h000056DC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND8_MEM</a></p>

</td>

<td><p>32'h000056E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND8_DESC</a></p>

</td>

<td><p>32'h000056E4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND8_DESC_1D_ST</a></p>

</td>

<td><p>32'h000056E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND8_DESC_1D_SZ</a></p>

</td>

<td><p>32'h000056EC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND8_DESC_2D_ST</a></p>

</td>

<td><p>32'h000056F0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND8_DESC_2D_SZ</a></p>

</td>

<td><p>32'h000056F4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND8_DESC_3D_ST</a></p>

</td>

<td><p>32'h000056F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND8_DESC_3D_SZ</a></p>

</td>

<td><p>32'h000056FC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND8_DESC_4D_ST</a></p>

</td>

<td><p>32'h00005700</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND8_DESC_4D_SZ</a></p>

</td>

<td><p>32'h00005704</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND8_START</a></p>

</td>

<td><p>32'h00005708</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND8_CLEAR</a></p>

</td>

<td><p>32'h0000570C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND8_FLEXA</a></p>

</td>

<td><p>32'h00005710</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND8_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h00005714</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND8_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h00005718</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND9_MEM</a></p>

</td>

<td><p>32'h0000571C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND9_DESC</a></p>

</td>

<td><p>32'h00005720</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND9_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005724</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND9_DESC_1D_SZ</a></p>

</td>

<td><p>32'h00005728</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND9_DESC_2D_ST</a></p>

</td>

<td><p>32'h0000572C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND9_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005730</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND9_DESC_3D_ST</a></p>

</td>

<td><p>32'h00005734</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND9_DESC_3D_SZ</a></p>

</td>

<td><p>32'h00005738</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND9_DESC_4D_ST</a></p>

</td>

<td><p>32'h0000573C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND9_DESC_4D_SZ</a></p>

</td>

<td><p>32'h00005740</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND9_START</a></p>

</td>

<td><p>32'h00005744</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND9_CLEAR</a></p>

</td>

<td><p>32'h00005748</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND9_FLEXA</a></p>

</td>

<td><p>32'h0000574C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND9_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h00005750</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND9_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h00005754</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND10_MEM</a></p>

</td>

<td><p>32'h00005758</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND10_DESC</a></p>

</td>

<td><p>32'h0000575C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND10_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005760</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND10_DESC_1D_SZ</a></p>

</td>

<td><p>32'h00005764</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND10_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005768</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND10_DESC_2D_SZ</a></p>

</td>

<td><p>32'h0000576C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND10_DESC_3D_ST</a></p>

</td>

<td><p>32'h00005770</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND10_DESC_3D_SZ</a></p>

</td>

<td><p>32'h00005774</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND10_DESC_4D_ST</a></p>

</td>

<td><p>32'h00005778</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND10_DESC_4D_SZ</a></p>

</td>

<td><p>32'h0000577C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND10_START</a></p>

</td>

<td><p>32'h00005780</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND10_CLEAR</a></p>

</td>

<td><p>32'h00005784</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND10_FLEXA</a></p>

</td>

<td><p>32'h00005788</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND10_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h0000578C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND10_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h00005790</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND11_MEM</a></p>

</td>

<td><p>32'h00005794</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND11_DESC</a></p>

</td>

<td><p>32'h00005798</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND11_DESC_1D_ST</a></p>

</td>

<td><p>32'h0000579C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND11_DESC_1D_SZ</a></p>

</td>

<td><p>32'h000057A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND11_DESC_2D_ST</a></p>

</td>

<td><p>32'h000057A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND11_DESC_2D_SZ</a></p>

</td>

<td><p>32'h000057A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND11_DESC_3D_ST</a></p>

</td>

<td><p>32'h000057AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND11_DESC_3D_SZ</a></p>

</td>

<td><p>32'h000057B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND11_DESC_4D_ST</a></p>

</td>

<td><p>32'h000057B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND11_DESC_4D_SZ</a></p>

</td>

<td><p>32'h000057B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND11_START</a></p>

</td>

<td><p>32'h000057BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND11_CLEAR</a></p>

</td>

<td><p>32'h000057C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND11_FLEXA</a></p>

</td>

<td><p>32'h000057C4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND11_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h000057C8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND11_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h000057CC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND12_MEM</a></p>

</td>

<td><p>32'h000057D0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND12_DESC</a></p>

</td>

<td><p>32'h000057D4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND12_DESC_1D_ST</a></p>

</td>

<td><p>32'h000057D8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND12_DESC_1D_SZ</a></p>

</td>

<td><p>32'h000057DC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND12_DESC_2D_ST</a></p>

</td>

<td><p>32'h000057E0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND12_DESC_2D_SZ</a></p>

</td>

<td><p>32'h000057E4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND12_DESC_3D_ST</a></p>

</td>

<td><p>32'h000057E8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND12_DESC_3D_SZ</a></p>

</td>

<td><p>32'h000057EC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND12_DESC_4D_ST</a></p>

</td>

<td><p>32'h000057F0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND12_DESC_4D_SZ</a></p>

</td>

<td><p>32'h000057F4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND12_START</a></p>

</td>

<td><p>32'h000057F8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND12_CLEAR</a></p>

</td>

<td><p>32'h000057FC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND12_FLEXA</a></p>

</td>

<td><p>32'h00005800</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND12_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h00005804</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND12_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h00005808</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND13_MEM</a></p>

</td>

<td><p>32'h0000580C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND13_DESC</a></p>

</td>

<td><p>32'h00005810</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND13_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005814</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND13_DESC_1D_SZ</a></p>

</td>

<td><p>32'h00005818</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND13_DESC_2D_ST</a></p>

</td>

<td><p>32'h0000581C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND13_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005820</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND13_DESC_3D_ST</a></p>

</td>

<td><p>32'h00005824</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND13_DESC_3D_SZ</a></p>

</td>

<td><p>32'h00005828</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND13_DESC_4D_ST</a></p>

</td>

<td><p>32'h0000582C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND13_DESC_4D_SZ</a></p>

</td>

<td><p>32'h00005830</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND13_START</a></p>

</td>

<td><p>32'h00005834</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND13_CLEAR</a></p>

</td>

<td><p>32'h00005838</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND13_FLEXA</a></p>

</td>

<td><p>32'h0000583C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND13_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h00005840</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND13_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h00005844</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND14_MEM</a></p>

</td>

<td><p>32'h00005848</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND14_DESC</a></p>

</td>

<td><p>32'h0000584C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND14_DESC_1D_ST</a></p>

</td>

<td><p>32'h00005850</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND14_DESC_1D_SZ</a></p>

</td>

<td><p>32'h00005854</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND14_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005858</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND14_DESC_2D_SZ</a></p>

</td>

<td><p>32'h0000585C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND14_DESC_3D_ST</a></p>

</td>

<td><p>32'h00005860</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND14_DESC_3D_SZ</a></p>

</td>

<td><p>32'h00005864</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND14_DESC_4D_ST</a></p>

</td>

<td><p>32'h00005868</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND14_DESC_4D_SZ</a></p>

</td>

<td><p>32'h0000586C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND14_START</a></p>

</td>

<td><p>32'h00005870</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND14_CLEAR</a></p>

</td>

<td><p>32'h00005874</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND14_FLEXA</a></p>

</td>

<td><p>32'h00005878</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND14_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h0000587C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND14_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h00005880</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM">v64bDhub_dHub0_Cmd4ND15_MEM</a></p>

</td>

<td><p>32'h00005884</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_MEM_addr">addr</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>DRAM data address of the 4D buffer, in bytes.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC">v64bDhub_dHub0_Cmd4ND15_DESC</a></p>

</td>

<td><p>32'h00005888</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_burst">burst</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to transfer per step. 

Value of 0 is invalid and treated as 1 

Equivalent to dHubCmdHDR.size</p>

</td>

</tr>

<tr><td><p>[20:16]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_chkSemId">chkSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore check is disabled 

ID: ID of semaphore to check for the first command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, chkSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[25:21]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_updSemId">updSemId</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: Semaphore update is disabled 

ID: ID of semaphore to update for the last command sent out by 

4ND engine 

Note: when semaFlexaHub.semaphoreFlexa[i].SEG_LINE is set to non 

zero value, updSemId won’t take effect, the corresponding 

channel ID will be used as Flexa semaphore ID</p>

</td>

</tr>

<tr><td><p>[26:26]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_interrupt">interrupt</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>1: raise interrupt upon whole 4ND command finish. 

0 : no interrupt 

Equivalent to setting dHubCmdHDR.interrupt on the last 4ND 

command.</p>

</td>

</tr>

<tr><td><p>[27:27]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_ovrdQos">ovrdQos</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHDR.ovrdQos</p>

</td>

</tr>

<tr><td><p>[28:28]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_disSem">disSem</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.disSem 

Note: to support Flexa SBI handshaking, disSem has to be set to 

0</p>

</td>

</tr>

<tr><td><p>[29:29]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_qosSel">qosSel</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Follows the definition of dHubCmdHdr.qosSel</p>

</td>

</tr>

<tr><td><p>[31:30]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_mode">mode</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>0: 4ND mode 

1: 1D mode 

2: 2ND mode 

3: 3ND mode</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST">v64bDhub_dHub0_Cmd4ND15_DESC_1D_ST</a></p>

</td>

<td><p>32'h0000588C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per address. 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ">v64bDhub_dHub0_Cmd4ND15_DESC_1D_SZ</a></p>

</td>

<td><p>32'h00005890</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_1D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per dimension 

Value of 0 is invalid and treated as 1 

Note: to support Flexa SBI handshaking, DESC_1D_SZ has to be 1, 

such that for every scan line defined by 1D only the 1st MTU do 

semaphore check and the last MTU do semaphore update</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST">v64bDhub_dHub0_Cmd4ND15_DESC_2D_ST</a></p>

</td>

<td><p>32'h00005894</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 2D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 2D dimension 

specified by: DESC_1D_SZ.size * DESC_1D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ">v64bDhub_dHub0_Cmd4ND15_DESC_2D_SZ</a></p>

</td>

<td><p>32'h00005898</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_2D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 2D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST">v64bDhub_dHub0_Cmd4ND15_DESC_3D_ST</a></p>

</td>

<td><p>32'h0000589C</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 3D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 3D dimension 

specified by: DESC_2D_SZ.size * DESC_2D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ">v64bDhub_dHub0_Cmd4ND15_DESC_3D_SZ</a></p>

</td>

<td><p>32'h000058A0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_3D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 3D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST">v64bDhub_dHub0_Cmd4ND15_DESC_4D_ST</a></p>

</td>

<td><p>32'h000058A4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_ST_step">step</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of bytes to step per 4D dimension 

Signed 24-bit 2's complement number 

-8M to +8M 

Value of 0 is used for a circular buffer in 4D dimension 

specified by: DESC_3D_SZ.size * DESC_3D_ST.step</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ">v64bDhub_dHub0_Cmd4ND15_DESC_4D_SZ</a></p>

</td>

<td><p>32'h000058A8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[23:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_DESC_4D_SZ_size">size</a></p>

</td>

<td><p>0x1</p>

</td>

<td><p>Number of steps per 4D dimension 

Value of 0 is invalid and treated as 1</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START">v64bDhub_dHub0_Cmd4ND15_START</a></p>

</td>

<td><p>32'h000058AC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_START_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write 1 to enable the channel. Will step through full 4ND buffer 

till done (!busy)</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(W-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR">v64bDhub_dHub0_Cmd4ND15_CLEAR</a></p>

</td>

<td><p>32'h000058B0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[0:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_CLEAR_EN">EN</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Write anything to reset the 4ND engine.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA">v64bDhub_dHub0_Cmd4ND15_FLEXA</a></p>

</td>

<td><p>32'h000058B4</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[7:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_STREAM_ID">STREAM_ID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>The FLEXA stream ID</p>

</td>

</tr>

<tr><td><p>[9:8]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_CID">CID</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Consumer ID</p>

</td>

</tr>

<tr><td><p>[10:10]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_ENDOFSTR">ENDOFSTR</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>When this bit is set, Flexa interface PR_END (for producer) or 

CR_END (for consumer) will be issued once the completion of 

frame defined by 4ND engine</p>

</td>

</tr>

<tr><td><p>[11:11]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_WITHOUT_WAIT">WITHOUT_WAIT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Request for a segment without waiting for data consumer (or 

producer)</p>

</td>

</tr>

<tr><td><p>[13:12]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_TIMEOUT">TIMEOUT</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Select the FLEXA handshaking timeout thresholds at the FLEXA 

Synchronizer side. 

0: no timeout, wait forever; 

1: 1 cycle timeout; 

2: short timeout threshold; 

3: long timeout threshold;</p>

</td>

</tr>

<tr><td><p>[14:14]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_END">END</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Software can enforce Flexa data producer or data consumer to 

issue PR_END (stop streaming) or CR_END (to be offline) in the 

middle of data frame transmission through this bit, this bit 

will be cleared automatically by HW once PR_END or CR_END 

acknowledged by Flexa Synchronizer with the status of 

“successful”.</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA">v64bDhub_dHub0_Cmd4ND15_FLEXA_INTR_STA</a></p>

</td>

<td><p>32'h000058B8</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b00, write ‘1’ to clear bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b01, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_STA_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Data producer or consumer request gets abnormal status response 

from FLEXA Synchronizer when {p(or c)r_start, p(or c)r_end = 

2’b10, write ‘1’ to clear each bit: 

[0]: p(or c)r_status is 2’b01, not initialized; 

[1]: p(or c)r_status is 2’b10, timeout error or buffer full; 

[2]: p(or c)r_status is 2’b11, out-of-sync</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(P)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK">v64bDhub_dHub0_Cmd4ND15_FLEXA_INTR_MSK</a></p>

</td>

<td><p>32'h000058BC</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[2:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_00">outsync_00</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_00</p>

</td>

</tr>

<tr><td><p>[5:3]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_01">outsync_01</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_01</p>

</td>

</tr>

<tr><td><p>[8:6]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubCmd4ND_FLEXA_INTR_MSK_outsync_10">outsync_10</a></p>

</td>

<td><p>0x0</p>

</td>

<td><p>Set to disable the 4ND engine FLEXA outsync interrupt generated 

from INTR_STA.outsync_10 

end dHubCmd4ND</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(R-)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg2D_BUSY">v64bDhub_dHub0_BUSY</a></p>

</td>

<td><p>32'h000058C0</p>

</td>

<td><p> 

</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[15:0]</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg2D_BUSY_ST">ST</a></p>

</td>

<td><p> 

</p>

</td>

<td><p>Per channel status 

0: no ongoing command is being processed 

1: channel controller is busy</p>

</td>

</tr>

</table><p> 

</p>

<table width="100%"><tr><td><p>Access</p>

</td>

<td><p>Register</p>

</td>

<td><p>Address</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>(RW)</p>

</td>

<td><p><a HREF="vDhub.htm#dHubReg2D_">v64bDhub_dHub0_mem</a></p>

</td>

<td><p>32'h00005900</p>

</td>

<td><p>end dHubReg2D 

Internal memory</p>

</td>

</tr>

<tr><td><p>Range</p>

</td>

<td><p>Field</p>

</td>

<td><p>Reset</p>

</td>

<td><p>Description</p>

</td>

</tr>

<tr><td><p>[31:0]</p>

</td>

<td><p>Memory</p>

</td>

<td><p> 

</p>

</td>

<td><p>Memory</p>

</td>

</tr>

</table><p> 

</p>

</body></html>